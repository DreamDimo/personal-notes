## 并发编程

### 一、进程与线程

#### 1. 线程状态

```java
public static enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

### 二、JUC 常用包

#### 1. ThreadPoolExecutor - 线程池核心实现

基本用法

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100)
);

executor.execute(() -> System.out.println("执行任务"));
executor.shutdown();
```

常用方法

- `execute(Runnable)` - 执行任务
- `submit(Callable/Runnable)` - 提交任务并返回Future
- `shutdown()` - 优雅关闭
- `getActiveCount()` - 获取活跃线程数

#### 2. Executors - 线程池工厂类

基本用法

```java
// 固定大小线程池
ExecutorService fixed = Executors.newFixedThreadPool(5);

// 缓存线程池
ExecutorService cached = Executors.newCachedThreadPool();

// 单线程池
ExecutorService single = Executors.newSingleThreadExecutor();
```

常用方法

- `newFixedThreadPool(int)` - 创建固定大小线程池
- `newCachedThreadPool()` - 创建缓存线程池
- `newSingleThreadExecutor()` - 创建单线程池
- `newScheduledThreadPool(int)` - 创建定时线程池

#### 3. ScheduledThreadPoolExecutor - 定时任务线程池

基本用法

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

// 延迟执行
scheduler.schedule(() -> System.out.println("延迟任务"), 5, TimeUnit.SECONDS);

// 周期执行
scheduler.scheduleAtFixedRate(() -> System.out.println("周期任务"), 0, 2, TimeUnit.SECONDS);
```

常用方法

- `schedule(Runnable, delay, unit)` - 延迟执行
- `scheduleAtFixedRate(Runnable, initialDelay, period, unit)` - 固定频率执行
- `scheduleWithFixedDelay(Runnable, initialDelay, delay, unit)` - 固定延迟执行

#### 4.CompletableFuture - 异步编程

基本用法

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "异步结果";
});

future.thenAccept(System.out::println);
String result = future.get(); // 阻塞获取结果
```

常用方法

- `supplyAsync(Supplier)` - 异步执行有返回值任务
- `runAsync(Runnable)` - 异步执行无返回值任务
- `thenApply(Function)` - 结果转换
- `thenAccept(Consumer)` - 消费结果

#### 5. ReentrantLock - 可重入锁

基本用法

```java
ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    // 临界区代码
} finally {
    lock.unlock();
}
```

常用方法

- `lock()` - 获取锁
- `unlock()` - 释放锁
- `tryLock()` - 尝试获取锁
- `newCondition()` - 创建条件变量

#### 6. CountDownLatch - 倒计时门闩

基本用法

```java
CountDownLatch latch = new CountDownLatch(3);

// 工作线程
new Thread(() -> {
    // 执行任务
    latch.countDown();
}).start();

// 主线程等待
latch.await();
```

常用方法

- `await()` - 等待计数归零
- `countDown()` - 计数减1
- `getCount()` - 获取当前计数
- `await(timeout, unit)` - 超时等待

#### 7. Semaphore - 信号量

基本用法

```java
Semaphore semaphore = new Semaphore(3); // 允许3个线程同时访问

semaphore.acquire();
try {
    // 访问共享资源
} finally {
    semaphore.release();
}
```

常用方法

- `acquire()` - 获取许可
- `release()` - 释放许可
- `tryAcquire()` - 尝试获取许可
- `availablePermits()` - 可用许可数

#### 8. Exchanger - 两线程数据交换

基本用法

```java
Exchanger<String> exchanger = new Exchanger<>();

// 线程1
new Thread(() -> {
    try {
        String received = exchanger.exchange("数据1");
        System.out.println("收到: " + received);
    } catch (InterruptedException e) {}
}).start();

// 线程2
new Thread(() -> {
    try {
        String received = exchanger.exchange("数据2");
        System.out.println("收到: " + received);
    } catch (InterruptedException e) {}
}).start();
```

常用方法

- `exchange(V)` - 交换数据并等待
- `exchange(V, timeout, unit)` - 超时交换

#### 9. ConcurrentHashMap - 线程安全哈希表

基本用法

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

map.put("key1", 1);
Integer value = map.get("key1");
map.putIfAbsent("key2", 2);
map.compute("key1", (k, v) -> v + 1);
```

常用方法

- `put(K, V)` - 添加元素
- `get(K)` - 获取元素
- `putIfAbsent(K, V)` - 不存在时添加
- `compute(K, BiFunction)` - 计算新值

#### 10. Future/FutureTask - 异步计算结果

基本用法

```java
// 使用Future
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(() -> "异步结果");
String result = future.get();

// 使用FutureTask
FutureTask<String> task = new FutureTask<>(() -> "任务结果");
new Thread(task).start();
String taskResult = task.get();
```

常用方法

- `get()` - 阻塞获取结果
- `get(timeout, unit)` - 超时获取结果
- `isDone()` - 判断是否完成
- `cancel(boolean)` - 取消任务