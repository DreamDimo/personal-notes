## å¹¶å‘ç¼–ç¨‹

### ä¸€ã€è¿›ç¨‹ã€çº¿ç¨‹ã€åç¨‹

#### 1. çº¿ç¨‹çŠ¶æ€

```java
public static enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

#### 2. åç¨‹

##### 2.1 å®šä¹‰

**åç¨‹ï¼ˆCoroutineï¼‰** æ˜¯ä¸€ç§æ¯”çº¿ç¨‹æ›´è½»é‡çº§çš„å¹¶å‘å•ä½ã€‚
 ç®€å•æ¥è¯´ï¼Œå®ƒæ˜¯â€œ**å¯æŒ‚èµ·ï¼ˆsuspendï¼‰å’Œæ¢å¤ï¼ˆresumeï¼‰çš„å‡½æ•°**â€ï¼Œå…è®¸ä½ åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æš‚åœã€åˆ‡æ¢åˆ°åˆ«çš„ä»»åŠ¡ï¼Œå†å›æ¥ç»§ç»­æ‰§è¡Œã€‚

##### 2.2 ç‰¹ç‚¹

åç¨‹æ˜¯ä¸€ç§**ç”¨æˆ·æ€çš„å¹¶å‘æœºåˆ¶**ï¼Œä¸éœ€è¦æ“ä½œç³»ç»Ÿä»‹å…¥åˆ‡æ¢ï¼Œä»è€Œå®ç°é«˜æ•ˆçš„å¼‚æ­¥æ‰§è¡Œã€‚

ä¼ ç»Ÿå¹¶å‘æ–¹å¼ï¼š

- **å¤šçº¿ç¨‹**ï¼šå¼€é”€å¤§ã€è°ƒåº¦ç”±å†…æ ¸æ§åˆ¶ã€é¢‘ç¹åˆ‡æ¢æµªè´¹æ€§èƒ½ï¼›
- **å›è°ƒï¼ˆcallbackï¼‰**ï¼šä»£ç ç»“æ„æ··ä¹±ã€éš¾ä»¥ç»´æŠ¤ï¼ˆâ€œå›è°ƒåœ°ç‹±â€ï¼‰ã€‚

åç¨‹çš„ä¼˜åŠ¿ï¼š

- ä¸éœ€è¦å¤šçº¿ç¨‹ï¼Œä¹Ÿèƒ½å®ç°é«˜å¹¶å‘ï¼›
- ä»£ç ç»“æ„çœ‹èµ·æ¥æ˜¯â€œåŒæ­¥â€çš„ï¼Œä½†åº•å±‚æ˜¯å¼‚æ­¥æ‰§è¡Œï¼›
- é¿å…é”ç«äº‰ï¼Œä¸ä¼šå‡ºç°çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚

##### 2.3 åŸç†

**ä¿å­˜å½“å‰å‡½æ•°çš„æ‰§è¡ŒçŠ¶æ€ï¼ˆæ ˆå¸§ï¼‰**ï¼Œå¹¶åœ¨ç¨åæ¢å¤å®ƒã€‚

äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰ï¼šè´Ÿè´£è°ƒåº¦å’Œç®¡ç†åç¨‹çš„è¿è¡Œï¼Œæ˜¯æ•´ä¸ªåç¨‹ç³»ç»Ÿçš„â€œå¿ƒè„â€ã€‚

åç¨‹è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰ï¼šå†³å®šå“ªä¸ªåç¨‹å¯ä»¥æ‰§è¡Œã€å“ªä¸ªè¦ç­‰å¾…ï¼ˆä¾‹å¦‚ç­‰å¾… I/Oï¼‰ã€‚

æŒ‚èµ·ä¸æ¢å¤ï¼ˆSuspend/Resumeï¼‰ï¼šå½“åç¨‹é‡åˆ° I/O æ“ä½œæ—¶ï¼Œå®ƒä¼šä¸»åŠ¨æŒ‚èµ·ï¼ˆyieldï¼‰ï¼Œè®©å‡ºæ‰§è¡Œæƒï¼›å½“ I/O å®Œæˆåï¼Œè°ƒåº¦å™¨å†æ¢å¤è¯¥åç¨‹çš„æ‰§è¡Œ

##### 2.4 å®è·µ

æ‰€æœ‰å¼‚æ­¥æ“ä½œéƒ½è¦åŠ  `await`ï¼›ç”¨ `asyncio.gather()` æ¥å¹¶å‘è¿è¡Œå¤šä¸ªä»»åŠ¡ï¼›é¿å…åœ¨åç¨‹ä¸­ä½¿ç”¨é˜»å¡å‡½æ•°ï¼ˆå¦‚ `time.sleep()`ï¼‰ï¼›ç½‘ç»œã€I/O æ“ä½œè¦ç”¨å¼‚æ­¥åº“ï¼ˆå¦‚ `aiohttp`ã€`aiomysql`ï¼‰ï¼›ç”¨ `asyncio.run()` å¯åŠ¨ä¸»äº‹ä»¶å¾ªç¯ã€‚

ä¸‹é¢çš„ä¾‹å­ä¸­æ˜¯å¯åŠ¨å¾ªç¯ï¼Œç„¶ååŒæ—¶è®¿é—®ä¸‰ä¸ªç½‘ç«™ï¼Œ`run` æ˜¯å¯åŠ¨äº‹ä»¶å¾ªç¯ï¼Œ`await` æ˜¯é˜»å¡äº‹ä»¶è°ƒç”¨ï¼Œè¡¨ç¤ºæ‰§è¡Œå®Œè·å¾—ç»“æœåæ‰ç»§ç»­ï¼Œæ‰€ä»¥çœŸæ­£èµ·åˆ°å¹¶å‘ä½œç”¨çš„æ˜¯ `gather`

```python
import asyncio
import aiohttp  # å¼‚æ­¥ HTTP åº“

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            print(f"è·å– {url} çŠ¶æ€ç : {resp.status}")
            return await resp.text()

async def main():
    urls = [
        "https://www.python.org",
        "https://docs.python.org/3/",
        "https://www.github.com"
    ]
    results = await asyncio.gather(*(fetch(url) for url in urls))
    print("å·²è·å–ç½‘é¡µæ•°é‡ï¼š", len(results))

asyncio.run(main())
```

##### 2.5 workeråç¨‹

**Worker åç¨‹**å¯ä»¥ç†è§£ä¸ºï¼š

> â€œä¸€ä¸ªæŒç»­è¿è¡Œã€ä¸æ–­ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶å¼‚æ­¥æ‰§è¡Œçš„åç¨‹å·¥ä½œè€…ã€‚â€

æ¢å¥è¯è¯´ï¼š

- ä¸»çº¿ç¨‹æˆ–ä¸Šæ¸¸é€»è¾‘è´Ÿè´£ **ç”Ÿäº§ä»»åŠ¡ï¼ˆProducerï¼‰**ï¼›
- è‹¥å¹²ä¸ª **Worker åç¨‹** è´Ÿè´£ **æ¶ˆè´¹ä»»åŠ¡ï¼ˆConsumerï¼‰**ï¼›
- ä¸¤è€…ä¹‹é—´é€šè¿‡ä¸€ä¸ª **å¼‚æ­¥é˜Ÿåˆ—ï¼ˆasyncio.Queueï¼‰** é€šä¿¡ã€‚

è¿™ç§æ¨¡å¼ä¹Ÿç§°ä¸º **ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼ˆProducer-Consumer Patternï¼‰** çš„å¼‚æ­¥ç‰ˆæœ¬ã€‚

```python
import asyncio
import random

async def worker(name, queue):
    while True:
        task = await queue.get()  # ä»é˜Ÿåˆ—å–ä»»åŠ¡ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
        if task is None:  # é€€å‡ºä¿¡å·
            print(f"ğŸ§¹ {name} åœæ­¢å·¥ä½œ")
            break
        print(f"âš™ï¸ {name} å¼€å§‹æ‰§è¡Œä»»åŠ¡ {task}")
        await asyncio.sleep(random.uniform(0.5, 2.0))  # æ¨¡æ‹ŸI/Oæ“ä½œ
        print(f"âœ… {name} å®Œæˆä»»åŠ¡ {task}")
        queue.task_done()  # æ ‡è®°ä»»åŠ¡å®Œæˆ

async def main():
    queue = asyncio.Queue()

    # åˆ›å»ºå¤šä¸ª worker åç¨‹
    workers = [asyncio.create_task(worker(f"Worker-{i}", queue)) for i in range(3)]

    # æ¨¡æ‹Ÿç”Ÿäº§ä»»åŠ¡
    for i in range(10):
        await queue.put(i)
        print(f"ğŸ“¦ æ”¾å…¥ä»»åŠ¡ {i}")

    # ç­‰å¾…ä»»åŠ¡å…¨éƒ¨å®Œæˆ
    await queue.join()

    # é€šçŸ¥æ‰€æœ‰ worker é€€å‡º
    for _ in workers:
        await queue.put(None)

    # ç­‰å¾…æ‰€æœ‰ worker åç¨‹é€€å‡º
    await asyncio.gather(*workers)

asyncio.run(main())
```

#### 3. é˜»å¡

##### 3.1 æ™®é€šå¤šçº¿ç¨‹ç¨‹åº

```python
import threading
import time

def task(name):
    print(f"{name} å¼€å§‹")
    time.sleep(3)  # é˜»å¡å½“å‰çº¿ç¨‹
    print(f"{name} ç»“æŸ")

t1 = threading.Thread(target=task, args=("ä»»åŠ¡1",))
t2 = threading.Thread(target=task, args=("ä»»åŠ¡2",))

t1.start()
t2.start()
```

ğŸ” è¯´æ˜ï¼š

- `time.sleep(3)` é˜»å¡çš„æ˜¯**è¯¥çº¿ç¨‹è‡ªå·±**ï¼›
- ä½†å…¶ä»–çº¿ç¨‹ï¼ˆå¦‚ `t2`ï¼‰ä»ç„¶å¯ä»¥è¿è¡Œï¼›
- æ‰€ä»¥æ•´ä¸ªç¨‹åº**å¹¶ä¸ä¼šå¡ä½**ã€‚

âœ… **ç»“è®º**ï¼š

> åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ï¼Œä¸€ä¸ªçº¿ç¨‹é˜»å¡ï¼Œä¸ä¼šå½±å“å…¶ä»–çº¿ç¨‹çš„æ‰§è¡Œã€‚

##### 3.2 å¼‚æ­¥åç¨‹

```python
import asyncio
import time

async def bad_task():
    print("å¼€å§‹")
    time.sleep(3)  # âŒ è¿™æ˜¯é˜»å¡æ“ä½œ
    print("ç»“æŸ")

async def good_task():
    print("å¼€å§‹å¼‚æ­¥ç­‰å¾…")
    await asyncio.sleep(3)  # âœ… éé˜»å¡
    print("ç»“æŸå¼‚æ­¥ç­‰å¾…")

async def main():
    await asyncio.gather(bad_task(), good_task())

asyncio.run(main())
```

âš ï¸ è¾“å‡ºç»“æœï¼š

```
å¼€å§‹
ï¼ˆæ•´ä¸ªç¨‹åºå¡ä½3ç§’ï¼‰
ç»“æŸ
å¼€å§‹å¼‚æ­¥ç­‰å¾…
ç»“æŸå¼‚æ­¥ç­‰å¾…
```

ğŸ” åŸå› ï¼š

- `time.sleep(3)` æ˜¯**çœŸæ­£çš„é˜»å¡è°ƒç”¨**ï¼›
- å®ƒä¼šè®©æ•´ä¸ªäº‹ä»¶å¾ªç¯å¡ä½ï¼Œå¯¼è‡´å…¶ä»–åç¨‹æ— æ³•è¿è¡Œï¼›
- åªæœ‰æ”¹ç”¨ `await asyncio.sleep(3)`ï¼ˆå¼‚æ­¥ç­‰å¾…ï¼‰ï¼Œæ‰ä¸ä¼šé˜»å¡äº‹ä»¶å¾ªç¯ã€‚

âœ… **ç»“è®ºï¼š**

> åœ¨å¼‚æ­¥ï¼ˆåç¨‹ï¼‰ç¨‹åºä¸­ï¼Œä¸€ä¸ªâ€œé˜»å¡æ“ä½œâ€å¯èƒ½è®©**æ•´ä¸ªäº‹ä»¶å¾ªç¯éƒ½æš‚åœ**ï¼Œä»è€Œæ‰€æœ‰åç¨‹éƒ½æ— æ³•æ‰§è¡Œã€‚

##### 3.3 é˜»å¡ä¸çº¿ç¨‹æ± çš„å…³ç³»

å‡è®¾ä½ æœ‰ä¸€ä¸ªçº¿ç¨‹æ± ï¼ˆæ¯”å¦‚ 10 ä¸ªçº¿ç¨‹ï¼‰ï¼š

- å¦‚æœå…¶ä¸­ 1 ä¸ªçº¿ç¨‹é˜»å¡ï¼Œåªæ˜¯**é‚£ä¸€ä¸ªçº¿ç¨‹**åœ¨ç­‰ï¼›
- å…¶ä»– 9 ä¸ªçº¿ç¨‹ä»ç„¶å¯ä»¥ç»§ç»­æ‰§è¡Œï¼›
- é™¤éä½ æäº¤çš„æ‰€æœ‰ä»»åŠ¡éƒ½é˜»å¡ï¼Œé‚£æ•´ä¸ªçº¿ç¨‹æ± çœ‹èµ·æ¥å°±â€œæ²¡ååº”â€äº†ã€‚

```python
from concurrent.futures import ThreadPoolExecutor
import time

def slow_task(n):
    print(f"çº¿ç¨‹ {n} å¼€å§‹")
    time.sleep(3)  # é˜»å¡å½“å‰çº¿ç¨‹
    print(f"çº¿ç¨‹ {n} ç»“æŸ")

with ThreadPoolExecutor(max_workers=3) as pool:
    for i in range(6):
        pool.submit(slow_task, i)
```

ğŸ” è§£é‡Šï¼š

- åŒæ—¶æœ€å¤š 3 ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œï¼›
- è¿™ 3 ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œåï¼Œçº¿ç¨‹æ± å†ç»§ç»­å¤„ç†å…¶ä»–ä»»åŠ¡ï¼›
- çº¿ç¨‹æ± æ•´ä½“æ²¡æœ‰è¢«â€œé”æ­»â€ï¼Œåªæ˜¯â€œå¿™ç¢Œâ€ã€‚

âœ… **ç»“è®ºï¼š**

> çº¿ç¨‹æ± ä¸­ä¸€ä¸ªçº¿ç¨‹é˜»å¡ï¼Œä¸ä¼šè®©æ•´ä¸ªæ± åœæ‰ï¼Œé™¤éæ‰€æœ‰çº¿ç¨‹éƒ½é˜»å¡ã€‚

#### 4. ä¸Šä¸‹æ–‡ç®¡ç†

##### 4.1. **ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®ï¼ˆContext Manager Protocolï¼‰**

ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®é€šå¸¸é€šè¿‡ `__enter__` å’Œ `__exit__` æ–¹æ³•å®ç°ã€‚å¸¸è§çš„ç”¨æ³•æ˜¯ï¼š

```
with some_resource as resource:
    # ä½¿ç”¨ resource
```

è¿™ä¸ª `with` è¯­å¥ä¼šè°ƒç”¨èµ„æºçš„ `__enter__` æ–¹æ³•ï¼Œå¹¶åœ¨ `with` ä»£ç å—æ‰§è¡Œå®Œæ¯•åè°ƒç”¨ `__exit__` æ–¹æ³•ï¼Œä»¥ç¡®ä¿èµ„æºå¾—åˆ°æ­£ç¡®çš„ç®¡ç†å’Œé‡Šæ”¾ã€‚

##### 4.2. **å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆAsync Context Managerï¼‰**

å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®ä¸å¸¸è§„ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®éå¸¸ç›¸ä¼¼ï¼Œä½†å®ƒéœ€è¦ä½¿ç”¨ `async def` å®šä¹‰ `__aenter__` å’Œ `__aexit__` æ–¹æ³•ã€‚å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨é€‚ç”¨äºé‚£äº›éœ€è¦å¼‚æ­¥æ“ä½œçš„èµ„æºï¼Œå¦‚å¼‚æ­¥æ•°æ®åº“è¿æ¥ã€å¼‚æ­¥æ–‡ä»¶æ“ä½œç­‰ã€‚

- **`__aenter__`**ï¼šå¼‚æ­¥å…¥å£æ–¹æ³•ï¼Œç”¨äºè¿›å…¥ä¸Šä¸‹æ–‡ã€‚
- **`__aexit__`**ï¼šå¼‚æ­¥é€€å‡ºæ–¹æ³•ï¼Œç”¨äºé€€å‡ºä¸Šä¸‹æ–‡å¹¶å¤„ç†æ¸…ç†å·¥ä½œã€‚

##### 4.3. **`async with` çš„å·¥ä½œåŸç†**

`async with` è¯­å¥çš„å·¥ä½œåŸç†ä¸æ™®é€šçš„ `with` ç±»ä¼¼ï¼Œåªæ˜¯å®ƒæ˜¯å¼‚æ­¥çš„ï¼Œä½¿ç”¨ `await` æ¥ç­‰å¾…å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„èµ„æºåˆå§‹åŒ–å’Œæ¸…ç†æ“ä½œã€‚

ä¸‹é¢æ˜¯å¦‚ä½•ä½¿ç”¨å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„ä¸€ä¸ªç®€å•ç¤ºä¾‹ï¼š

```python
import asyncio

class AsyncContextManager:
    async def __aenter__(self):
        print("Entering the context")
        # å¯ä»¥å¼‚æ­¥è¿›è¡ŒæŸäº›æ“ä½œï¼Œä¾‹å¦‚æ‰“å¼€å¼‚æ­¥æ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥
        await asyncio.sleep(1)
        return self  # è¿”å›ä½ æƒ³è¦çš„èµ„æº

    async def __aexit__(self, exc_type, exc, tb):
        print("Exiting the context")
        # å¯ä»¥å¼‚æ­¥è¿›è¡Œèµ„æºæ¸…ç†æ“ä½œ
        await asyncio.sleep(1)

async def main():
    async with AsyncContextManager() as manager:
        print("Inside the context")
        await asyncio.sleep(1)
    print("Outside the context")

asyncio.run(main())
```

è¾“å‡ºï¼š

```
Entering the context
Inside the context
Exiting the context
Outside the context
```

è¿™é‡Œçš„ `AsyncContextManager` å®ç°äº†å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®ã€‚`__aenter__` å’Œ `__aexit__` æ–¹æ³•è¢«å®šä¹‰ä¸ºå¼‚æ­¥å‡½æ•°ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥æ‰§è¡Œå¼‚æ­¥æ“ä½œã€‚åœ¨ `async with` è¯­å¥å—å†…ï¼Œ`__aenter__` è¢«è°ƒç”¨ï¼Œè€Œåœ¨ä»£ç å—ç»“æŸåï¼Œ`__aexit__` è¢«è°ƒç”¨ã€‚

##### 4.4. **`async with` çš„åº”ç”¨åœºæ™¯**

`async with` ä¸»è¦ç”¨äºå¼‚æ­¥èµ„æºç®¡ç†ï¼Œç‰¹åˆ«æ˜¯åœ¨ I/O å¯†é›†å‹ä»»åŠ¡ä¸­ã€‚å¸¸è§çš„åº”ç”¨åœºæ™¯åŒ…æ‹¬ï¼š

- å¼‚æ­¥æ•°æ®åº“è¿æ¥å’ŒæŸ¥è¯¢
- å¼‚æ­¥ç½‘ç»œè¯·æ±‚
- å¼‚æ­¥æ–‡ä»¶æ“ä½œ
- å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—

##### 4.5. **åº“ä¸­çš„å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨**

è®¸å¤šå¼‚æ­¥åº“ï¼ˆå¦‚ `asyncio`, `aiohttp`, `aiomysql`, `aiopg` ç­‰ï¼‰å®ç°äº†å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç®€åŒ–äº†èµ„æºç®¡ç†ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ `aiohttp` è¿›è¡Œå¼‚æ­¥ HTTP è¯·æ±‚æ—¶ï¼Œ`async with` å¯ä»¥è‡ªåŠ¨ç®¡ç†è¿æ¥æ± å’Œä¼šè¯ï¼š

```python
import aiohttp
import asyncio

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    url = 'http://example.com'
    html = await fetch(url)
    print(html)

asyncio.run(main())
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`aiohttp.ClientSession()` å’Œ `session.get()` éƒ½æ˜¯å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç¡®ä¿åœ¨ä½¿ç”¨å®Œä¹‹åè‡ªåŠ¨å…³é—­ HTTP è¿æ¥ã€‚

### äºŒã€JUC å¸¸ç”¨åŒ…

#### 1. ThreadPoolExecutor - çº¿ç¨‹æ± æ ¸å¿ƒå®ç°

æ¦‚å¿µ

**çº¿ç¨‹æ± **æ˜¯ä¸€ç§**çº¿ç¨‹å¤ç”¨æœºåˆ¶**ï¼Œç”¨äºç®¡ç†å’Œè°ƒåº¦å¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œã€‚ç®€å•è¯´ï¼Œå®ƒæ˜¯â€œ**æå‰åˆ›å»ºå¥½è‹¥å¹²å·¥ä½œçº¿ç¨‹**â€ï¼Œå½“æœ‰ä»»åŠ¡æäº¤æ—¶ï¼Œå°±ä»æ± é‡Œå–å‡ºç©ºé—²çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œæ‰§è¡Œå®Œå†æ”¾å›æ± ä¸­ç­‰å¾…ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚

| ç»„ä»¶                             | ä½œç”¨                     |
| -------------------------------- | ------------------------ |
| **ä»»åŠ¡é˜Ÿåˆ—ï¼ˆTask Queueï¼‰**       | ä¿å­˜å¾…æ‰§è¡Œçš„ä»»åŠ¡         |
| **å·¥ä½œçº¿ç¨‹ï¼ˆWorker Threadsï¼‰**   | ä¸æ–­ä»é˜Ÿåˆ—å–ä»»åŠ¡æ‰§è¡Œ     |
| **çº¿ç¨‹æ± ç®¡ç†å™¨**                 | è´Ÿè´£åˆ›å»ºã€é”€æ¯ã€è°ƒåº¦çº¿ç¨‹ |
| **æ‹’ç»ç­–ç•¥ï¼ˆRejection Policyï¼‰** | å½“ä»»åŠ¡å¤ªå¤šæ—¶å†³å®šæ€ä¹ˆå¤„ç† |

åŸºæœ¬ç”¨æ³•

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100)
);

executor.execute(() -> System.out.println("æ‰§è¡Œä»»åŠ¡"));
executor.shutdown();
```

å¸¸ç”¨æ–¹æ³•

- `execute(Runnable)` - æ‰§è¡Œä»»åŠ¡
- `submit(Callable/Runnable)` - æäº¤ä»»åŠ¡å¹¶è¿”å›Future
- `shutdown()` - ä¼˜é›…å…³é—­
- `getActiveCount()` - è·å–æ´»è·ƒçº¿ç¨‹æ•°

#### 2. Executors - çº¿ç¨‹æ± å·¥å‚ç±»

åŸºæœ¬ç”¨æ³•

```java
// å›ºå®šå¤§å°çº¿ç¨‹æ± 
ExecutorService fixed = Executors.newFixedThreadPool(5);

// ç¼“å­˜çº¿ç¨‹æ± 
ExecutorService cached = Executors.newCachedThreadPool();

// å•çº¿ç¨‹æ± 
ExecutorService single = Executors.newSingleThreadExecutor();
```

å¸¸ç”¨æ–¹æ³•

- `newFixedThreadPool(int)` - åˆ›å»ºå›ºå®šå¤§å°çº¿ç¨‹æ± 
- `newCachedThreadPool()` - åˆ›å»ºç¼“å­˜çº¿ç¨‹æ± 
- `newSingleThreadExecutor()` - åˆ›å»ºå•çº¿ç¨‹æ± 
- `newScheduledThreadPool(int)` - åˆ›å»ºå®šæ—¶çº¿ç¨‹æ± 

#### 3. ScheduledThreadPoolExecutor - å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 

åŸºæœ¬ç”¨æ³•

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

// å»¶è¿Ÿæ‰§è¡Œ
scheduler.schedule(() -> System.out.println("å»¶è¿Ÿä»»åŠ¡"), 5, TimeUnit.SECONDS);

// å‘¨æœŸæ‰§è¡Œ
scheduler.scheduleAtFixedRate(() -> System.out.println("å‘¨æœŸä»»åŠ¡"), 0, 2, TimeUnit.SECONDS);
```

å¸¸ç”¨æ–¹æ³•

- `schedule(Runnable, delay, unit)` - å»¶è¿Ÿæ‰§è¡Œ
- `scheduleAtFixedRate(Runnable, initialDelay, period, unit)` - å›ºå®šé¢‘ç‡æ‰§è¡Œ
- `scheduleWithFixedDelay(Runnable, initialDelay, delay, unit)` - å›ºå®šå»¶è¿Ÿæ‰§è¡Œ

#### 4.CompletableFuture - å¼‚æ­¥ç¼–ç¨‹

åŸºæœ¬ç”¨æ³•

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "å¼‚æ­¥ç»“æœ";
});

future.thenAccept(System.out::println);
String result = future.get(); // é˜»å¡è·å–ç»“æœ
```

å¸¸ç”¨æ–¹æ³•

- `supplyAsync(Supplier)` - å¼‚æ­¥æ‰§è¡Œæœ‰è¿”å›å€¼ä»»åŠ¡
- `runAsync(Runnable)` - å¼‚æ­¥æ‰§è¡Œæ— è¿”å›å€¼ä»»åŠ¡
- `thenApply(Function)` - ç»“æœè½¬æ¢
- `thenAccept(Consumer)` - æ¶ˆè´¹ç»“æœ

#### 5. ReentrantLock - å¯é‡å…¥é”

åŸºæœ¬ç”¨æ³•

```java
ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    // ä¸´ç•ŒåŒºä»£ç 
} finally {
    lock.unlock();
}
```

å¸¸ç”¨æ–¹æ³•

- `lock()` - è·å–é”
- `unlock()` - é‡Šæ”¾é”
- `tryLock()` - å°è¯•è·å–é”
- `newCondition()` - åˆ›å»ºæ¡ä»¶å˜é‡

#### 6. CountDownLatch - å€’è®¡æ—¶é—¨é—©

åŸºæœ¬ç”¨æ³•

```java
CountDownLatch latch = new CountDownLatch(3);

// å·¥ä½œçº¿ç¨‹
new Thread(() -> {
    // æ‰§è¡Œä»»åŠ¡
    latch.countDown();
}).start();

// ä¸»çº¿ç¨‹ç­‰å¾…
latch.await();
```

å¸¸ç”¨æ–¹æ³•

- `await()` - ç­‰å¾…è®¡æ•°å½’é›¶
- `countDown()` - è®¡æ•°å‡1
- `getCount()` - è·å–å½“å‰è®¡æ•°
- `await(timeout, unit)` - è¶…æ—¶ç­‰å¾…

#### 7. Semaphore - ä¿¡å·é‡

åŸºæœ¬ç”¨æ³•

```java
Semaphore semaphore = new Semaphore(3); // å…è®¸3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®

semaphore.acquire();
try {
    // è®¿é—®å…±äº«èµ„æº
} finally {
    semaphore.release();
}
```

å¸¸ç”¨æ–¹æ³•

- `acquire()` - è·å–è®¸å¯
- `release()` - é‡Šæ”¾è®¸å¯
- `tryAcquire()` - å°è¯•è·å–è®¸å¯
- `availablePermits()` - å¯ç”¨è®¸å¯æ•°

#### 8. Exchanger - ä¸¤çº¿ç¨‹æ•°æ®äº¤æ¢

åŸºæœ¬ç”¨æ³•

```java
Exchanger<String> exchanger = new Exchanger<>();

// çº¿ç¨‹1
new Thread(() -> {
    try {
        String received = exchanger.exchange("æ•°æ®1");
        System.out.println("æ”¶åˆ°: " + received);
    } catch (InterruptedException e) {}
}).start();

// çº¿ç¨‹2
new Thread(() -> {
    try {
        String received = exchanger.exchange("æ•°æ®2");
        System.out.println("æ”¶åˆ°: " + received);
    } catch (InterruptedException e) {}
}).start();
```

å¸¸ç”¨æ–¹æ³•

- `exchange(V)` - äº¤æ¢æ•°æ®å¹¶ç­‰å¾…
- `exchange(V, timeout, unit)` - è¶…æ—¶äº¤æ¢

#### 9. ConcurrentHashMap - çº¿ç¨‹å®‰å…¨å“ˆå¸Œè¡¨

åŸºæœ¬ç”¨æ³•

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

map.put("key1", 1);
Integer value = map.get("key1");
map.putIfAbsent("key2", 2);
map.compute("key1", (k, v) -> v + 1);
```

å¸¸ç”¨æ–¹æ³•

- `put(K, V)` - æ·»åŠ å…ƒç´ 
- `get(K)` - è·å–å…ƒç´ 
- `putIfAbsent(K, V)` - ä¸å­˜åœ¨æ—¶æ·»åŠ 
- `compute(K, BiFunction)` - è®¡ç®—æ–°å€¼

#### 10. Future/FutureTask - å¼‚æ­¥è®¡ç®—ç»“æœ

åŸºæœ¬ç”¨æ³•

```java
// ä½¿ç”¨Future
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(() -> "å¼‚æ­¥ç»“æœ");
String result = future.get();

// ä½¿ç”¨FutureTask
FutureTask<String> task = new FutureTask<>(() -> "ä»»åŠ¡ç»“æœ");
new Thread(task).start();
String taskResult = task.get();
```

å¸¸ç”¨æ–¹æ³•

- `get()` - é˜»å¡è·å–ç»“æœ
- `get(timeout, unit)` - è¶…æ—¶è·å–ç»“æœ
- `isDone()` - åˆ¤æ–­æ˜¯å¦å®Œæˆ
- `cancel(boolean)` - å–æ¶ˆä»»åŠ¡

### ä¸‰ã€webscraperä¸­ä½¿ç”¨çš„å¹¶å‘

#### 1. æµè§ˆå™¨æ± 

è®¾è®¡æ€è·¯ï¼šæµè§ˆå™¨å®ä¾‹å¤ç”¨ï¼ŒèŠ‚çœ2.5ç§’/URLï¼›è‡ªåŠ¨ç®¡ç†é¡µé¢èµ„æºï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ï¼›ä¿¡å·é‡æ§åˆ¶æ¯ä¸ªæµè§ˆå™¨çš„é¡µé¢æ•°ï¼Œé˜²æ­¢è¿‡è½½ï¼›ä¸Šä¸‹æ–‡ç®¡ç†å™¨ä¿è¯é¡µé¢è‡ªåŠ¨å…³é—­ï¼› æ”¯æŒé™çº§ï¼Œå‘åå…¼å®¹

é—®é¢˜åˆ†æï¼š

å½“å‰æ¯ä¸ª `extract_xxx` å‡½æ•°éƒ½ç‹¬ç«‹åˆ›å»ºbrowserï¼š
```python
async with async_playwright() as p:
    browser = await p.chromium.launch()  # æ¯æ¬¡2ç§’
    # ... ä½¿ç”¨
    await browser.close()  # æ¯æ¬¡0.5ç§’
```

**ç—›ç‚¹**ï¼š50ä¸ªURL Ã— 2.5ç§’ = 125ç§’æµªè´¹åœ¨æµè§ˆå™¨åˆ›å»º/é”€æ¯ä¸Š

è§£å†³æ–¹æ¡ˆï¼šåˆ›å»ºå•ç½‘ç«™æµè§ˆå™¨æ± 

**æ–°å»ºæ–‡ä»¶ï¼š`crawler/sites_shopping/browser_pool.py`**

```python
"""
å•ç½‘ç«™Playwrightæµè§ˆå™¨è¿æ¥æ± 
ç”Ÿå‘½å‘¨æœŸï¼šç½‘ç«™å¼€å§‹æ—¶åˆ›å»º â†’ å¤„ç†æ‰€æœ‰URL â†’ ç½‘ç«™ç»“æŸæ—¶é”€æ¯
"""
import asyncio
from playwright.async_api import async_playwright, Browser, Page
from typing import Optional, List
from contextlib import asynccontextmanager
from config import logger

class BrowserPool:
    """å•ç½‘ç«™Playwrightæµè§ˆå™¨è¿æ¥æ± """

    def __init__(self, pool_size: int = 3, max_pages_per_browser: int = 5):
        """
        åˆå§‹åŒ–æµè§ˆå™¨æ± 

        Args:
            pool_size: æµè§ˆå™¨å®ä¾‹æ•°é‡ï¼ˆé»˜è®¤3ä¸ªï¼‰
            max_pages_per_browser: æ¯ä¸ªæµè§ˆå™¨æœ€å¤šæ‰“å¼€çš„é¡µé¢æ•°ï¼ˆé»˜è®¤5ä¸ªï¼‰
        """
        self.pool_size = pool_size
        self.max_pages_per_browser = max_pages_per_browser

        self.playwright = None
        self.browsers: List[Browser] = []
        self.page_semaphores: List[asyncio.Semaphore] = []
        self.initialized = False
        self.current_browser_index = 0  # è½®è¯¢ç´¢å¼•

    async def initialize(self):
        """åˆå§‹åŒ–æµè§ˆå™¨æ± ï¼ˆç½‘ç«™å¼€å§‹æ—¶è°ƒç”¨ï¼‰"""
        if self.initialized:
            return

        logger.info(f"ğŸš€ åˆå§‹åŒ–æµè§ˆå™¨æ± : {self.pool_size} ä¸ªæµè§ˆå™¨")

        self.playwright = await async_playwright().start()

        for i in range(self.pool_size):
            browser = await self.playwright.chromium.launch(
                headless=True,
                # å¯é€‰ï¼šæ·»åŠ å¯åŠ¨å‚æ•°ä¼˜åŒ–æ€§èƒ½
                args=['--disable-blink-features=AutomationControlled']
            )
            self.browsers.append(browser)

            # æ¯ä¸ªæµè§ˆå™¨æœ‰ç‹¬ç«‹çš„é¡µé¢ä¿¡å·é‡
            self.page_semaphores.append(
                asyncio.Semaphore(self.max_pages_per_browser)
            )
            logger.info(f"  âœ… æµè§ˆå™¨ #{i+1} å·²å¯åŠ¨")

        self.initialized = True
        logger.info("âœ… æµè§ˆå™¨æ± åˆå§‹åŒ–å®Œæˆ")

    @asynccontextmanager
    async def get_page(self):
        """
        è·å–ä¸€ä¸ªé¡µé¢ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰

        Yields:
            Page: Playwrighté¡µé¢å¯¹è±¡

        ä½¿ç”¨ç¤ºä¾‹ï¼š
            async with browser_pool.get_page() as page:
                await page.goto(url)
                content = await page.content()
        """
        if not self.initialized:
            await self.initialize()

        # è½®è¯¢é€‰æ‹©æµè§ˆå™¨ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
        browser_index = self.current_browser_index % self.pool_size
        self.current_browser_index += 1

        browser = self.browsers[browser_index]
        semaphore = self.page_semaphores[browser_index]

        # ç­‰å¾…è·å–é¡µé¢èµ„æº
        async with semaphore:
            page = await browser.new_page()

            # è®¾ç½®é»˜è®¤çš„User-Agent
            await page.set_extra_http_headers({
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) '
                             'AppleWebKit/537.36 (KHTML, like Gecko) '
                             'Chrome/120.0.0.0 Safari/537.36'
            })

            try:
                yield page
            finally:
                # ç¡®ä¿é¡µé¢å…³é—­
                await page.close()

    async def close(self):
        """å…³é—­æµè§ˆå™¨æ± ï¼ˆç½‘ç«™ç»“æŸæ—¶è°ƒç”¨ï¼‰"""
        if not self.initialized:
            return

        logger.info("ğŸ”’ å…³é—­æµè§ˆå™¨æ± ...")

        for i, browser in enumerate(self.browsers):
            await browser.close()
            logger.info(f"  âœ… æµè§ˆå™¨ #{i+1} å·²å…³é—­")

        if self.playwright:
            await self.playwright.stop()

        self.browsers.clear()
        self.page_semaphores.clear()
        self.initialized = False

        logger.info("âœ… æµè§ˆå™¨æ± å·²å…³é—­")
```

åœ¨ extractor_llm.py ä¸­é›†æˆæµè§ˆå™¨æ± ï¼š

**ShoppingLLM ç±»æ·»åŠ æµè§ˆå™¨æ± ç®¡ç†ï¼š**
```python
class ShoppingLLM:
    def __init__(self, ..., enable_concurrent=False):
        # ... åŸæœ‰åˆå§‹åŒ–
        self.enable_concurrent = enable_concurrent
        self.browser_pool = None  # æµè§ˆå™¨è¿æ¥æ± 

    async def initialize_browser_pool(self):
        """åˆå§‹åŒ–æµè§ˆå™¨æ± ï¼ˆç½‘ç«™å¼€å§‹æ—¶ï¼‰"""
        if self.browser_pool is None:
            from .browser_pool import BrowserPool
            self.browser_pool = BrowserPool(
                pool_size=CONCURRENT_CONFIG['browser_pool_size'],
                max_pages_per_browser=CONCURRENT_CONFIG['max_pages_per_browser']
            )
            await self.browser_pool.initialize()

    async def close_browser_pool(self):
        """å…³é—­æµè§ˆå™¨æ± ï¼ˆç½‘ç«™ç»“æŸæ—¶ï¼‰"""
        if self.browser_pool:
            await self.browser_pool.close()
            self.browser_pool = None
```

ä¿®æ”¹å„ extractor_xxx.py ä½¿ç”¨æµè§ˆå™¨æ± ï¼š

**ä¿®æ”¹å‰ï¼ˆextractor_slickdeals.pyï¼‰ï¼š**
```python
async def extract_deals_from_slickdeals(url, extract_by_llm=False):
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)  # 2ç§’
        page = await browser.new_page()
        # ... çˆ¬å–é€»è¾‘
        await browser.close()  # 0.5ç§’
```

**ä¿®æ”¹åï¼š**
```python
async def extract_deals_from_slickdeals(url, extract_by_llm=False, browser_pool=None):
    """
    æ·»åŠ  browser_pool å‚æ•°ï¼Œç”± extractor_llm ä¼ å…¥
    """
    if browser_pool:
        # ä½¿ç”¨ä¼ å…¥çš„æµè§ˆå™¨æ± 
        async with browser_pool.get_page() as page:
            # ... çˆ¬å–é€»è¾‘ï¼ˆå…¶ä»–ä¸å˜ï¼‰
            await page.goto(url, wait_until='domcontentloaded')
            content = await page.content()
            # ...
    else:
        # é™çº§ï¼šå¦‚æœæ²¡æœ‰æµè§ˆå™¨æ± ï¼Œä½¿ç”¨åŸæœ‰æ–¹å¼
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            page = await browser.new_page()
            # ... çˆ¬å–é€»è¾‘
            await browser.close()
```

**åœ¨ extractor_llm.py è°ƒç”¨æ—¶ä¼ å…¥ï¼š**
```python
async def run_as_preset(self, url, parent=None, extract_by_llm=False):
    # ... åŸæœ‰é€»è¾‘
    func = func_dic.get('page')
    # ä¼ å…¥æµè§ˆå™¨æ± 
    res, site_info = await func(url, browser_pool=self.browser_pool)
    # ...
```

#### 2. åç¨‹å¹¶å‘

æ·»åŠ  `enable_concurrent` å‚æ•°ï¼Œæ”¯æŒæ¸è¿›å¼å‡çº§ï¼› ä½¿ç”¨ `asyncio.Semaphore` é™åˆ¶å¹¶å‘æ•°ï¼›åˆ†æ‰¹æ‰§è¡Œé¿å…ä»»åŠ¡è¿‡å¤šï¼›ä¿ç•™åŸä¸²è¡Œæ–¹æ³•ä½œä¸ºfallback

```python
class ShoppingLLM:
    def __init__(self, ..., enable_concurrent=False):
        # ... åŸæœ‰åˆå§‹åŒ–
        self.enable_concurrent = enable_concurrent
        self.url_semaphore = asyncio.Semaphore(
            CONCURRENT_CONFIG['max_urls_per_site']
        ) if enable_concurrent else None
        self.browser_pool = None  # æµè§ˆå™¨è¿æ¥æ± ï¼ˆåç»­å®ç°ï¼‰

    async def process_level_urls_concurrent(self, level):
        """å¹¶å‘å¤„ç†æŒ‡å®šå±‚çº§çš„æ‰€æœ‰URL"""
        logger.info(f"ğŸ“‹ å¼€å§‹å¹¶å‘å¤„ç† Level {level}")

        # 1. æ”¶é›†å½“å‰å±‚çº§çš„æ‰€æœ‰URL
        level_urls = []
        temp_queue = deque()
        while self.url_queue:
            url, parent, url_level = self.url_queue.popleft()
            if url_level == level:
                level_urls.append((url, parent, url_level))
            else:
                temp_queue.append((url, parent, url_level))
        self.url_queue = temp_queue

        if not level_urls:
            return

        logger.info(f"ğŸ“Š Level {level}: {len(level_urls)} ä¸ªURLå¾…å¤„ç†")

        # 2. åˆ›å»ºå¹¶å‘ä»»åŠ¡ï¼ˆå¸¦ä¿¡å·é‡æ§åˆ¶ï¼‰
        async def process_url_with_semaphore(url, parent, url_level):
            """å¸¦ä¿¡å·é‡æ§åˆ¶çš„URLå¤„ç†"""
            async with self.url_semaphore:
                if url in self.visited_urls:
                    return

                self.visited_urls.add(url)
                logger.info(f"ğŸ”„ å¤„ç†URL: {url}")

                try:
                    await self.analyze_single_url(url, parent, url_level)
                    logger.info(f"âœ… å®ŒæˆURL: {url}")
                except Exception as e:
                    logger.error(f"âŒ URLå¤„ç†å¤±è´¥ {url}: {e}")

        # 3. åˆ›å»ºæ‰€æœ‰ä»»åŠ¡
        tasks = [
            asyncio.create_task(
                process_url_with_semaphore(url, parent, url_level)
            )
            for url, parent, url_level in level_urls
            if url not in self.visited_urls
        ]

        # 4. åˆ†æ‰¹æ‰§è¡Œï¼ˆé¿å…ä¸€æ¬¡æ€§æäº¤å¤ªå¤šä»»åŠ¡ï¼‰
        batch_size = CONCURRENT_CONFIG['max_urls_per_site'] * 2
        for i in range(0, len(tasks), batch_size):
            batch = tasks[i:i + batch_size]
            await asyncio.gather(*batch, return_exceptions=True)
            logger.info(f"  æ‰¹æ¬¡ {i//batch_size + 1} å®Œæˆ")

    async def analyze(self, url, parent=None):
        """åˆ†æURLçš„ä¸»æ–¹æ³•ï¼ˆæ”¯æŒå¹¶å‘ï¼‰"""
        logger.info(f"ğŸ” å¼€å§‹åˆ†æ: {url}")
        await self.add_url_to_queue(url, parent=parent, level=0)

        # é€å±‚å¤„ç†
        for level in range(self.max_level + 1):
            if not self.url_queue:
                break

            self.current_level = level
            logger.info(f"ğŸ”„ å¤„ç† Level {level}...")

            # æ ¹æ®é…ç½®é€‰æ‹©å¹¶å‘æˆ–ä¸²è¡Œ
            if self.enable_concurrent:
                await self.process_level_urls_concurrent(level)
            else:
                await self.process_level_urls(level)  # ä¿ç•™åŸä¸²è¡Œæ–¹æ³•

            logger.info(f"âœ… Level {level} å®Œæˆ")

        logger.info(f"ğŸ‰ åˆ†æå®Œæˆ: å…±å¤„ç† {len(self.visited_urls)} ä¸ªURL")
```

#### 3. Gemini åŸç”Ÿå¼‚æ­¥

1. âœ… **çœŸæ­£çš„å¼‚æ­¥ I/O**
   - `await chat.aio.send_message()` æ˜¯éé˜»å¡è°ƒç”¨
   - ç½‘ç»œè¯·æ±‚æ—¶é‡Šæ”¾äº‹ä»¶å¾ªç¯ï¼Œå¯ä»¥å¤„ç†å…¶ä»–ä»»åŠ¡

2. âœ… **æ— çº¿ç¨‹æ± é™åˆ¶**
   - ç›´æ¥åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
   - 20 å¹¶å‘ = 20 åç¨‹ï¼Œå…¨éƒ¨åŒæ—¶æ‰§è¡Œ

3. âœ… **å†…å­˜å ç”¨ä½**
   - æ¯ä¸ªåç¨‹ ~1KB
   - 20 ä¸ªåç¨‹ = 20KB

```python
async def _async_chat_with_continuation(...):
    from google import genai
    from google.genai import types

    # åˆ›å»ºå¼‚æ­¥å®¢æˆ·ç«¯
    client = genai.Client(api_key=api_key)

    try:
        # åˆ›å»º Chat ä¼šè¯
        chat = client.chats.create(model='gemini-2.5-flash')

        # âœ… åŸç”Ÿå¼‚æ­¥è°ƒç”¨ï¼ˆä¸é˜»å¡ï¼‰
        response = await chat.aio.send_message(prompt, config=...)

        # æ”¯æŒ continuationï¼ˆå¤šè½®å¯¹è¯ï¼‰
        if is_truncated(response.text):
            response2 = await chat.aio.send_message("continue", ...)
            merged = merge_fragments([response.text, response2.text])

        return json.loads(merged)

    finally:
        # å…³é—­å¼‚æ­¥å®¢æˆ·ç«¯
        await client.aio.aclose()
```

geminiåŸç”Ÿå¼‚æ­¥åœ¨æ¯æ¬¡è¯·æ±‚éƒ½ä¼šåˆ›å»ºå®¢æˆ·ç«¯ï¼Œä¸”ä¸æ”¯æŒ async with ä¸Šä¸‹æ–‡ç®¡ç†å™¨åè®®ï¼Œéœ€è¦ GeminiClientPool ç±»æ¥ç®¡ç†

```python
# ä»å…¨å±€æ± è·å– Clientï¼ˆèµ„æºå¤ç”¨ï¼‰
client_pool = await get_client_pool()
client = await client_pool.get_client(api_key)
try:
    chat = client.aio.chats.create(model='gemini-2.5-flash')
    # ... ä½¿ç”¨ Client
finally:
    # é‡Šæ”¾ Clientï¼ˆå‡å°‘æ´»è·ƒè®¡æ•°ï¼‰
    await client_pool.release_client(api_key)
```

**èµ„æºæ¸…ç†æ–¹æ³•ï¼š**

1. **è‡ªåŠ¨æ¸…ç†ï¼ˆatexitï¼‰**ï¼š
   - ç¨‹åºé€€å‡ºæ—¶è‡ªåŠ¨è°ƒç”¨ `_sync_cleanup()`
   - é€‚é…ä¸åŒçš„äº‹ä»¶å¾ªç¯çŠ¶æ€

2. **æ˜¾å¼æ¸…ç†**ï¼š
   - æä¾› `cleanup_client_pool()` å‡½æ•°
   - å¯åœ¨ç¨‹åºæ­£å¸¸ç»“æŸæ—¶ä¸»åŠ¨è°ƒç”¨

3. **é‡æ–°åˆå§‹åŒ–**ï¼š
   - æ¸…ç†åå¯ä»¥é‡æ–°ä½¿ç”¨æ± 
   - è‡ªåŠ¨æ£€æµ‹å¹¶é‡æ–°åˆå§‹åŒ–

#### 4. æµç¨‹å›¾

é€šè¿‡ LLM æ± å¯ä»¥æ§åˆ¶å¹¶å‘é€Ÿç‡ï¼Œä¿è¯ key å¯ä»¥è½®æ¢ï¼ŒåŒæ—¶å¯ä»¥è¿›è¡Œç»Ÿè®¡å’Œç›‘æ§

```mermaid
flowchart TD

    subgraph APP["åº”ç”¨å±‚ï¼ˆExtractorï¼‰"]
        A1["ç½‘ç«™Açˆ¬å– â†’ ç”ŸæˆMarkdown"]
        A2["ç½‘ç«™Bçˆ¬å– â†’ ç”ŸæˆMarkdown"]
        A3["ç½‘ç«™Cçˆ¬å– â†’ ç”ŸæˆMarkdown"]
        A1 -->|æäº¤ä»»åŠ¡| Q["å…¨å±€LLMæ± "]
        A2 -->|æäº¤ä»»åŠ¡| Q
        A3 -->|æäº¤ä»»åŠ¡| Q
    end

    subgraph LLMPOOL["å…¨å±€LLMæ± ç®¡ç†å™¨ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰"]
        subgraph QUEUE["æ— ç•Œä»»åŠ¡é˜Ÿåˆ—ï¼ˆasyncio.Queueï¼‰"]
            Q1["æ‰€æœ‰ç½‘ç«™çš„Markdownä»»åŠ¡æ”¾å…¥æ­¤é˜Ÿåˆ—"]
            Q2["FIFO é¡ºåºå¤„ç†"]
        end

        subgraph WORKERS["20ä¸ª Worker åç¨‹å¹¶å‘å¤„ç†"]
            W1["ä»é˜Ÿåˆ—å–ä»»åŠ¡ â†’ è·å–Key â†’ è°ƒAPI â†’ è¿”å›ç»“æœ"]
            W2["Semaphoreæ§åˆ¶æœ€å¤§å¹¶å‘æ•° = 20"]
        end

        subgraph KEYROTATOR["API Keyè½®æ¢å™¨"]
            K1["Key1: AIzaSy...CAï¼ˆ50%æµé‡ï¼‰"]
            K2["Key2: AIzaSy...nQï¼ˆ50%æµé‡ï¼‰"]
            K3["Round Robinè½®è¯¢ + å¥åº·æ£€æŸ¥ + æ•…éšœåˆ‡æ¢"]
        end

        subgraph GEMINI["Gemini APIè°ƒç”¨ï¼ˆclient.aio åŸç”Ÿå¼‚æ­¥ï¼‰"]
            G1["è¶…æ—¶æ§åˆ¶ï¼š120ç§’"]
            G2["é‡è¯•æœºåˆ¶ï¼š3æ¬¡ï¼ˆæŒ‡æ•°é€€é¿ï¼‰"]
            G3["Rate Limitå¤„ç†ï¼šè‡ªåŠ¨åˆ‡æ¢Key"]
            G4["çœŸæ­£çš„å¼‚æ­¥ I/Oï¼ˆä¸ä½¿ç”¨çº¿ç¨‹æ± ï¼‰"]
        end
    end

    APP --> LLMPOOL
    QUEUE --> WORKERS
    WORKERS --> KEYROTATOR
    KEYROTATOR --> GEMINI
    GEMINI --> R["è¿”å›JSONç»“æœ"]

```





