算法常见模板与思想

### 一、基础算法

#### 1.归并排序求逆序对

```c++
long long merge_sort(int q[], int l, int r)  // 归并排序
{
    if(l >= r)return 0;
    int mid = l + r >> 1;
    long long res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ], res += mid - i + 1;
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
    return res;
}
```

#### 2.高精度

```c++
//高精度加法
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

int main()
{
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');

    auto C = add(A, B);

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
    cout << endl;

    return 0;
}


//高精度减法
bool cmp(vector<int> &A, vector<int> &B)
{
    if (A.size() != B.size()) return A.size() > B.size();

    for (int i = A.size() - 1; i >= 0; i -- )
        if (A[i] != B[i])
            return A[i] > B[i];

    return true;
}

vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');

    vector<int> C;

    if (cmp(A, B)) C = sub(A, B);
    else C = sub(B, A), cout << '-';

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
    cout << endl;

    return 0;
}

//高精度乘法
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}

//高精度除法
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 3.离散化

```c++
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());
```

#### 4.区间问题

##### 1.合并区间

将所给的区间合并

```c++
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

##### 2.区间选点

选一些点使得所有区间都至少有一个点被选择

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (range[i].l > ed)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}
```

##### 3.选择最多的不相交的区间

给一些区间，选择一些区间他们不相交

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (range[i].l > ed)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}
```

##### 4.区间分组

将区间分成若干组，组内区间不相交

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else
        {
            heap.pop();
            heap.push(r.r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}
```

##### 5.区间覆盖

给一个线段和一些区间，选择最少区间将其覆盖

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else
        {
            heap.pop();
            heap.push(r.r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}
```

##### 6.64位乘法（龟速乘）

```c++
LL qadd(LL a, LL b, LL p)
{
    LL res = 0;
    while (b)
    {
        if (b & 1) res = (res + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    LL a, b, p;
    scanf("%lld%lld%lld", &a, &b, &p);
    printf("%lld\n", qadd(a, b, p));

    return 0;
}
```

### 二、数据结构

#### 1.单调栈问题

给一个长度为$N$的整数数列，求出每个数左边第一个比他小的数字

如果一个数字比另一个数字大且在左边他一定没有用，所以我们维护一个单调递增的栈

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;
        if (!tt) printf("-1 ");
        else printf("%d ", stk[tt]);
        stk[ ++ tt] = x;
    }

    return 0;
}
```

#### 2.单调队列

给一个长度为 $n$ 的数列，和一个长度为 $k$ 的窗口，窗口向后移动，求出每个窗口内部的最小值和最大值

用一个队列维护下标，如果队头下标超过长度弹出去，维护最小值的时候维护一个单调递增的序列

```c++
int a[N], q[N];

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    int hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ;

        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }

    puts("");

    hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ;

        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }

    puts("");

    return 0;
}
```

#### 3.KMP

```c++
int main()
{
    cin >> n >> p + 1 >> m >> s + 1;

    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }

    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}
```

#### 4.Trie树

注意 $son[N][26]$ 中 $N$ 的大小为字符串的总长度

```c++
int son[N * 26][26], idx;
int cnt[N * 26];
void insert(string s){
	int p = 0;
	for (int i = 0; i < s.size(); i ++){
		int x = s[i] - 'a';
		if(!son[p][x])son[p][x] = ++ idx;
		p = son[p][x];
	}
	cnt[p] ++;
}
int query(string s){
	int p = 0;
	for (int i = 0; i < s.size(); i ++){
		int x = s[i] - 'a';
		if(!son[p][x])return 0;
		p = son[p][x];
	}
	return cnt[p];
}
```

#### 5.并查集

##### 1.带权并查集

食物链为例 $1 X Y$ 表示 $X$ 和 $Y$ 是同类，2表示异类，如果有一句话和前面的真话冲突则错误

```c++
int p[N], d[N];
int find(int x){
	if(p[x] == x || p[p[x]] == p[x]){
		return p[x];
	}
	else {
		int t = find(p[x]);
		d[x] += d[p[x]];
		p[x] = t;
		return p[x];
	}
}
void solve(){
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)p[i] = i;
	int ans = 0;
	while(m --){
		int op, x, y;cin >> op >> x >> y;
		if(x > n || y > n){
			ans ++;
			continue;
		}
		int pa = find(x), pb = find(y);
		if(op == 1){
			if(pa != pb) {
				d[pa] = (d[y] - d[x]) % 3;
				p[pa] = pb;
			}
			else if((d[x] - d[y]) % 3){
				ans ++;
			}
		}
		else {
			if(pa != pb) {
				d[pa] = (d[y] - d[x] + 1) % 3;
				p[pa] = pb;
			}
			else if((d[x] - d[y] - 1) % 3){
				ans ++;
			}
		}
	}
	cout << ans << "\n"; 
}
```

##### 2.扩展域并查集

给一个01串，每次说出 $[l, r]$ 这个区间的1的个数为奇数还是偶数，求第几个问题开始出错

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 40010, Base = N / 2;

int n, m;
int p[N];
unordered_map<int, int> S;

int get(int x)
{
    if (S.count(x) == 0) S[x] = ++ n;
    return S[x];
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    n = 0;

    for (int i = 0; i < N; i ++ ) p[i] = i;

    int res = m;
    for (int i = 1; i <= m; i ++ )
    {
        int a, b;
        string type;
        cin >> a >> b >> type;
        a = get(a - 1), b = get(b);

        if (type == "even")
        {
            if (find(a + Base) == find(b))
            {
                res = i - 1;
                break;
            }
            p[find(a)] = find(b);
            p[find(a + Base)] = find(b + Base);
        }
        else
        {
            if (find(a) == find(b))
            {
                res = i - 1;
                break;
            }

            p[find(a + Base)] = find(b);
            p[find(a)] = find(b + Base);
        }
    }

    cout << res << endl;

    return 0;
}
```

#### 6.字符串哈希

```c++
struct Hash {
    static constexpr LL P = (LL)1E16 + 99;
    static constexpr int B = 233;
    int n;
    vector<LL> h, p;
    Hash(const string &s) : n(s.size()), h(n + 1), p(n + 1) {
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * B % P;
            h[i + 1] = (h[i] * B + s[i]) % P;
        }
    }

    LL get(int l, int r) {
        return (h[r] + (__int128)h[l] * (P - p[r - l])) % P;
    }
};
//0下标，左闭右开[l, r)
```

#### 7.树状数组

```c++
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;

    Fenwick(int n) : n(n), tr(n + 1, 0){}

    int lowbit(int x){
        return x & -x;
    }

    void modify(int x, T c){
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }

    void modify(int l, int r, T c){
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }

    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }

    T query(int l, int r){
        return query(r) - query(l - 1);
    }

    int find_first(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans + 1;
    }

    int find_last(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans;
    }

};
using BIT = Fenwick<int>;
```

#### 8.线段树

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int a[N];
struct SegmentTree {
    struct Node{
        int l, r;
        int s;
        int tag1, tag2;
    }tr[N * 4];
    void settag(int u, int t1, int t2){
        tr[u].s = tr[u].s * t2 + (tr[u].r - tr[u].l + 1) * t1;
        tr[u].tag1 = tr[u].tag1 * t2 + t1;
        tr[u].tag2 *= t2;
    }
    void pushup(int u){
        tr[u].s = tr[u << 1].s + tr[u << 1 | 1].s;
    }
    void pushdown(int u){
        settag(u << 1, tr[u].tag1, tr[u].tag2);
        settag(u << 1 | 1, tr[u].tag1, tr[u].tag2);
        tr[u].tag1 = 0;
        tr[u].tag2 = 1;
    }
    void build(int u, int l, int r){
        tr[u] = {l, r, 0, 0, 1};
        if(l == r){
            tr[u].s = a[l];
            tr[u].tag1 = 0;
            tr[u].tag2 = 1;
            return;
        } 
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int l, int r, int t1, int t2) {
        if(tr[u].l >= l && tr[u].r <= r){
            settag(u, t1, t2);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= l)modify(u << 1, l, r, t1, t2);
        if(mid < r)modify(u << 1 | 1, l, r, t1, t2);
        pushup(u);
    }
    int query(int u, int l, int r){
        if(tr[u].l >= l && tr[u].r <= r){
            return tr[u].s;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= r)return query(u << 1, l, r);
        else if(mid < l)return query(u << 1 | 1, l, r);
        else {
            return query(u << 1, l, r) + query(u << 1 | 1, l, r);
        }
    }
}tree;
```

#### 9.主席树

```c++
#include <bits/stdc++.h>
const int N = 1e5 + 10;
struct PST{
    int idx = 0;
    struct Node {
        int l, r;
        int cnt;
    }tr[N * 25];
    int build(int l, int r) {
        int p = ++ idx;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        tr[p].l = build(l, mid);
        tr[p].r = build(mid + 1, r);
        return p;
    }
    int insert(int q, int l, int r, int x) {
        int p = ++ idx;
        tr[p] = tr[q];
        tr[p].cnt++;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        if(mid >= x)tr[p].l = insert(tr[q].l, l, mid, x);
        else tr[p].r = insert(tr[q].r, mid + 1, r, x);
        return p;
    }
    int query(int p, int q, int l, int r, int k) {
        if(l == r) {
            return r;
        }
        int cnt = tr[tr[p].l].cnt - tr[tr[q].l].cnt;
        int mid = l + r >> 1;
        if(cnt >= k)return query(tr[p].l, tr[q].l, l, mid, k);
        else return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
    }
}pst;
```

#### 10.马拉车

```c++
    string s = "#";
    for (int i = 0; i < t.size(); i++) {
        s += t[i];
        s += '#';
    }
    int n = s.size();
    vector<int>d(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d[l + r - i], r - i + 1);
        while(i - k >= 0 && i + k < n && s[i - k] == s[i + k]) {
            k ++;
        }
        d[i] = k - 1;
        if(i + d[i] > r) {
            l = i - d[i];
            r = i + d[i];
        }
    }
```





### 三、搜索

#### 1.BFS

八数码问题为例，解决状态的转移

```c++
int bfs(string state)
{
    queue<string> q;
    unordered_map<string, int> d;

    q.push(state);
    d[state] = 0;

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    string end = "12345678x";
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t == end) return d[t];

        int distance = d[t];
        int k = t.find('x');
        int x = k / 3, y = k % 3;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);
                if (!d.count(t))
                {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[a * 3 + b], t[k]);
            }
        }
    }

    return -1;
}

int main()
{
    char s[2];

    string state;
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }

    cout << bfs(state) << endl;

    return 0;
}
```

#### 2.多源最短路（曼哈顿距离）

有多个起点会作为bfs的起始点

给一个矩阵，有0 1，求出所有的0到最近的1的 **曼哈顿距离** 的最小值

```c++
void bfs()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    memset(dist, -1, sizeof dist);

    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            if (g[i][j] == '1')
            {
                dist[i][j] = 0;
                q[ ++ tt] = {i, j};
            }

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 1 || a > n || b < 1 || b > m) continue;
            if (dist[a][b] != -1) continue;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }
}
```

#### 3.双端队列bfs(01bfs)

给一个地图，它由 / 和 $\\$ \ 组成，求从起点到终点至少要变化几个电线

```c++
const int N = 510, M = N * N;

int n, m;
char g[N][N];
int dist[N][N];
bool st[N][N];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0][0] = 0;
    deque<PII> q;
    q.push_back({0, 0});

    char cs[] = "\\/\\/";
    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};

    while (q.size())
    {
        PII t = q.front();
        q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a > n || b < 0 || b > m) continue;

            int ca = t.x + ix[i], cb = t.y + iy[i];
            int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);

            if (d < dist[a][b])
            {
                dist[a][b] = d;

                if (g[ca][cb] != cs[i]) q.push_back({a, b});
                else q.push_front({a, b});
            }
        }
    }

    return dist[n][m];
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        int t = bfs();

        if (t == 0x3f3f3f3f) puts("NO SOLUTION");
        else printf("%d\n", t);
    }

    return 0;
}
```

#### 4.DFS

给一个起始字母，和很多单词，单词之间必须满足一个的前缀和后缀重合部分长度大于1才能拼接，求最后的单词最大长度

```c++
void dfs(string dragon, int last)
{
    ans = max((int)dragon.size(), ans);

    used[last] ++ ;

    for (int i = 0; i < n; i ++ )
        if (g[last][i] && used[i] < 2)
            dfs(dragon + word[i].substr(g[last][i]), i);

    used[last] -- ;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> word[i];
    char start;
    cin >> start;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
        {
            string a = word[i], b = word[j];
            for (int k = 1; k < min(a.size(), b.size()); k ++ )
                if (a.substr(a.size() - k, k) == b.substr(0, k))
                {
                    g[i][j] = k;
                    break;
                }
        }

    for (int i = 0; i < n; i ++ )
        if (word[i][0] == start)
            dfs(word[i], i);

    cout << ans << endl;

    return 0;
}
```

#### 5.DFS之组合问题

##### 1.分成互质组（即不用枚举第几组，一定放到最后的一个组）

给一些数字分成最小的组，使得每一组组内互质

```c++
int n;
int p[N];
int group[N][N];
bool st[N];
int ans = N;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

bool check(int group[], int gc, int i)
{
    for (int j = 0; j < gc; j ++ )
        if (gcd(p[group[j]], p[i]) > 1)
            return false;
    return true;
}

void dfs(int g, int gc, int tc, int start)
{//g表示第几组，gc是组内的元素个数，tc是当前的元素下标，start是下一次从第几个元素遍历
    if (g >= ans) return;
    if (tc == n) ans = g;

    bool flag = true;
    for (int i = start; i < n; i ++ )
        if (!st[i] && check(group[g], gc, i))
        {
            st[i] = true;
            group[g][gc] = i;
            dfs(g, gc + 1, tc + 1, i + 1);
            st[i] = false;

            flag = false;
        }

    if (flag) dfs(g + 1, 0, tc, 0);
}
```

##### 2.小猫爬山

需要枚举第几组，类似于状压子集枚举

```c++
int n;
int p[N];
int group[N][N];
bool st[N];
int ans = N;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

bool check(int group[], int gc, int i)
{
    for (int j = 0; j < gc; j ++ )
        if (gcd(p[group[j]], p[i]) > 1)
            return false;
    return true;
}

void dfs(int g, int gc, int tc, int start)
{
    if (g >= ans) return;
    if (tc == n) ans = g;

    bool flag = true;
    for (int i = start; i < n; i ++ )
        if (!st[i] && check(group[g], gc, i))
        {
            st[i] = true;
            group[g][gc] = i;
            dfs(g, gc + 1, tc + 1, i + 1);
            st[i] = false;

            flag = false;
        }

    if (flag) dfs(g + 1, 0, tc, 0);
}
```

状压子集枚举方法

```c++
void solve(){
    int n, w;
    cin >> n >> w;
    vector<int> a(13);
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        x--;
        a[x]++;
    }
    n = 13;
    int s = bit(n);
    int l = s - 1;
    vector<int> f(s, n + 1);
    f[0] = 0;
    for (int i = 0; i < s; i++) {
        int x = i ^ l;
        for (int j = x; j; j = (j - 1) & x) {
            // cerr << j << "\n";
            int sum = 0;
            for (int k = 0; k < n; k++) {
                if(j >> k & 1) {
                    sum += a[k];
                }
            }
            if(sum <= w) {
                f[i | j] = min(f[i | j], f[i] + 1);
            }
        }
    }
    cout << f[l] << "\n";
}
```

#### 6.数独

```c++
#include<iostream>
#include <cstring>
#include<algorithm>
using namespace std;

const int N = 9, M = 1 << N;

int ones[M], map[M];
int row[N], col[N], cell[3][3];
char str[100];

void init()
{
    for (int i = 0; i < N; i ++ )
        row[i] = col[i] = (1 << N) - 1;

    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            cell[i][j] = (1 << N) - 1;
}

void draw(int x, int y, int t, bool is_set)
{
    if (is_set) str[x * N + y] = '1' + t;
    else str[x * N + y] = '.';

    int v = 1 << t;
    if (!is_set) v = -v;

    row[x] -= v;
    col[y] -= v;
    cell[x / 3][y / 3] -= v;
}

int lowbit(int x)
{
    return x & -x;
}

int get(int x, int y)
{
    return row[x] & col[y] & cell[x / 3][y / 3];
}

bool dfs(int cnt)
{
    if (!cnt) return true;

    int minv = 10;
    int x, y;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (str[i * N + j] == '.')
            {
                int state = get(i, j);
                if (ones[state] < minv)
                {
                    minv = ones[state];
                    x = i, y = j;
                }
            }

    int state = get(x, y);
    for (int i = state; i; i -= lowbit(i))
    {
        int t = map[lowbit(i)];
        draw(x, y, t, true);
        if (dfs(cnt - 1)) return true;
        draw(x, y, t, false);
    }

    return false;
}

int main()
{
    for (int i = 0; i < N; i ++ ) map[1 << i] = i;
    for (int i = 0; i < 1 << N; i ++ )
        for (int j = 0; j < N; j ++ )
            ones[i] += i >> j & 1;

    while (cin >> str, str[0] != 'e')
    {
        init();

        int cnt = 0;
        for (int i = 0, k = 0; i < N; i ++ )
            for (int j = 0; j < N; j ++, k ++ )
                if (str[k] != '.')
                {
                    int t = str[k] - '1';
                    draw(i, j, t, true);
                }
                else cnt ++ ;

        dfs(cnt);

        puts(str);
    }

    return 0;
}
```

#### 7.木棒(迭代加深DFS)

给一些截断的木棍，其中原来每个木棒的长度是相同的，求最短长度是多少

```c++
bool dfs(int u, int cur, int start)
{
    if (u * length == sum) return true;
    if (cur == length) return dfs(u + 1, 0, 0);

    for (int i = start; i < n; i ++ )
    {
        if (st[i] || cur + w[i] > length) continue;

        st[i] = true;
        if (dfs(u, cur + w[i], i + 1)) return true;
        st[i] = false;

        if (!cur || cur + w[i] == length) return false;

        int j = i;
        while (j < n && w[j] == w[i]) j ++ ;
        i = j - 1;
    }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        memset(st, 0, sizeof st);
        sum = 0;

        for (int i = 0; i < n; i ++ )
        {
            cin >> w[i];
            sum += w[i];
        }

        sort(w, w + n);
        reverse(w, w + n);

        length = 1;
        while (true)
        {
            if (sum % length == 0 && dfs(0, 0, 0))
            {
                cout << length << endl;
                break;
            }
            length ++ ;
        }
    }

    return 0;
}
```

#### 8.IDA*（主要是估价剪枝的思想）

给一个排列，每次可以选择其中连续的一段把它插入到别的地方，求最少步数使得这个排列变为 $1 2 3 ……$

小于5时算出具体答案，大于的时候写大于5即可

```c++
const int N = 15;

int n;
int q[N];
int w[5][N];

int f()
{
    int cnt = 0;
    for (int i = 0; i + 1 < n; i ++ )
        if (q[i + 1] != q[i] + 1)
            cnt ++ ;
    return (cnt + 2) / 3;
}

bool check()
{
    for (int i = 0; i + 1 < n; i ++ )
        if (q[i + 1] != q[i] + 1)
            return false;
    return true;
}

bool dfs(int depth, int max_depth)
{
    if (depth + f() > max_depth) return false;
    if (check()) return true;

    for (int len = 1; len <= n; len ++ )
        for (int l = 0; l + len - 1 < n; l ++ )
        {
            int r = l + len - 1;
            for (int k = r + 1; k < n; k ++ )
            {
                memcpy(w[depth], q, sizeof q);
                int x, y;
                for (x = r + 1, y = l; x <= k; x ++, y ++ ) q[y] = w[depth][x];
                for (x = l; x <= r; x ++, y ++ ) q[y] = w[depth][x];
                if (dfs(depth + 1, max_depth)) return true;
                memcpy(q, w[depth], sizeof q);
            }
        }

    return false;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n;
        for (int i = 0; i < n; i ++ ) cin >> q[i];

        int depth = 0;
        while (depth < 5 && !dfs(0, depth)) depth ++ ;
        if (depth >= 5) puts("5 or more");
        else cout << depth << endl;
    }

    return 0;
}
```

#### 9.迭代加深dfs

一个导弹系统可以防御单调递增或者单调递减的导弹，求最少几个导弹防御系统

##### 算法

##### (DFS,迭代加深,剪枝,贪心) $O(n2^n)$

为了能遍历所有情况，我们首先考虑搜索顺序是什么。

搜索顺序分为两个阶段：

*   从前往后枚举每颗导弹属于某个上升子序列，还是下降子序列；
*   如果属于上升子序列，则枚举属于哪个上升子序列（包括新开一个上升子序列）；如果属于下降子序列，可以类似处理。

因此可以仿照[AcWing 896. 最长上升子序列 II](https://www.acwing.com/problem/content/898/)，分别记录当前每个上升子序列的末尾数up\[\]，和下降子序列的末尾数down\[\]。这样在枚举时可以快速判断当前数是否可以接在某个序列的后面。

注意这里的记录方式和上一题稍有不同：

*   这里是记录每个子序列末尾的数；
*   上一题是记录每种长度的子序列的末尾最小值。

此时搜索空间仍然很大，因此该如何剪枝呢？

对于第二阶段的枚举，我们可以仿照上一题的贪心方式，对于上升子序列而言，我们将当前数接在最大的数后面，一定不会比接在其他数列后面更差。  
这是因为处理完当前数后，一定出现一个以当前数结尾的子序列，这是固定不变的，那么此时其他子序列的末尾数越小越好。

注意到按照这种贪心思路，up\[\]数组和down\[\]数组一定是单调的，因此在遍历时找到第一个满足的序列后就可以直接break了。

最后还需要考虑如何求最小值。因为DFS和BFS不同，第一次搜索到的节点，不一定是步数最短的节点，所以需要进行额外处理。  
一般有两种处理方式：

*   记录全局最小值，不断更新； 这种搜索顺序可以参考[@一瞬流年丶涅槃](https://www.acwing.com/user/myspace/index/3462/)同学的[题解](https://www.acwing.com/solution/acwing/content/4010/)；
*   迭代加深。一般平均答案深度较低时可以采用这种方式。后面的代码中采用的是这种方式。

##### 时间复杂度

每个数在第一搜索阶段有两种选择，在第二搜索阶段只有一种选择，但遍历up\[\]和down\[\]数组需要 $O(n)$ 的计算量，因此总时间复杂度是 $O(n2^n)$。

##### C++ 代码

```cpp
#include 
#include 
#include 

using namespace std;

const int N = 60;

int n;
int h[N];
int up[N], down[N];

bool dfs(int depth, int u, int su, int sd)
{
    // 如果上升序列个数 + 下降序列个数 > 总个数是上限，则回溯
    if (su + sd > depth) return false;
    if (u == n) return true;

    // 枚举放到上升子序列中的情况
    bool flag = false;
    for (int i = 1; i <= su; i ++ )
        if (up[i] < h[u])
        {
            int t = up[i];
            up[i] = h[u];
            if (dfs(depth, u + 1, su, sd)) return true;
            up[i] = t;
            flag = true;
            break;  // 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了
        }
    if (!flag)  // 如果不能放到任意一个序列后面，则单开一个新的序列
    {
        up[su + 1] = h[u];
        if (dfs(depth, u + 1, su + 1, sd)) return true;
    }

    // 枚举放到下降子序列中的情况
    flag = false;
    for (int i = 1; i <= sd; i ++ )
        if (down[i] > h[u])
        {
            int t = down[i];
            down[i] = h[u];
            if (dfs(depth, u + 1, su, sd)) return true;
            down[i] = t;
            flag = true;
            break;  // 注意由上述证明的贪心原理，只要找到第一个可以放的序列，就可以结束循环了
        }
    if (!flag)  // 如果不能放到任意一个序列后面，则单开一个新的序列
    {
        down[sd + 1] = h[u];
        if (dfs(depth, u + 1, su, sd + 1)) return true;
    }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        for (int i = 0; i < n; i ++ ) cin >> h[i];

        int depth = 0;
        while (!dfs(depth, 0, 0, 0)) depth ++ ;     // 迭代加深搜索

        cout << depth << endl;
    }

    return 0;
}
```

### 四、图论

#### 1.最短路模型

```c++
//点少
int dijkstra(int s){
	vector<int>dist(n + 1, inf);
	vector<int>st(n + 1);
	dist[s] = 0;
	for (int i = 0; i < n; i ++){
		int t = -1;
		for (int j = 1; j <= n; j ++){
			if(!st[j] && (t == -1 || dist[j] < dist[t]))t = j;
		}
		st[t] = true;
		for (int j = 1; j <= n; j ++)dist[j] = min(dist[j], dist[t] + a[t][j]);
	}
	if(dist[n] >= inf / 2)return -1;
	else return dist[n];
}

//边少
void dijkstra()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	priority_queue<PII, vector<PII>, greater<PII>> q;
	q.push({dist[1], 1});
	while(q.size())
	{
		int t = q.top().first, u = q.top().second;q.pop();
		if(st[u])continue;
		st[u] = true;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if(dist[j] > dist[u] + w[i])
			{
				dist[j] = dist[u] + w[i];
				q.push({dist[j], j});
			}
		}
	}
	if(dist[n] == 0x3f3f3f3f)puts("-1");
	else cout << dist[n] << "\n";
}
//最多经过k条边的最短路
struct Edge
{
    int a, b, c;
}edges[M];

int n, m, k;
int dist[N];
int last[N];

void bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0;
    for (int i = 0; i < k; i ++ )
    {
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++ )
        {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], last[e.a] + e.c);
        }
    }
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }

    bellman_ford();

    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else printf("%d\n", dist[n]);

    return 0;
}

//spfa求有负数的图
vector<PII>g[N];
void spfa(){
	vector<int>dist(n + 1, inf), st(n + 1);
	queue<int>q;
	q.push(1);
	dist[1] = 0;
	while(q.size()){
		int u = q.front();q.pop();
		st[u] = false;
		for (int i = 0; i < g[u].size(); i ++){
			int v = g[u][i][0];
			if(dist[v] > dist[u] + g[u][i][1]){
				dist[v] = dist[u] + g[u][i][1];
				if(!st[v])q.push(v);
				st[v] = true;
			}
		}
	}
	if(dist[n] >= inf / 2)cout << "impossible" << "\n";
	else cout << dist[n] << "\n";
}

//Floyd求最短路
void floyd()
{
    for (int k = 1; k <= n; k ++)
        for (int i = 1; i <= n; i ++)
            for (int j = 1; j <= n; j ++)
                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
}
```

#### 2.最小生成树

```c++
//prim的O(n2)算法
int prim()
{
    int res = 0;
    memset(dist, 0x3f, sizeof dist);
    for (int i = 0; i < n; i ++)
    {
        int t = -1;
        for (int j = 1; j <= n; j ++)
            if(!st[j] && (t == -1 || dist[t] > dist[j]))t = j;
        if(i && dist[t] == INF)return INF;
        st[t] = true;
        if(i)res += dist[t];
        for (int j = 1; j <= n; j ++) dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
//Kruskal的O(mlogm)算法
int n, m;
int p[N];

struct Edge
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }

    int t = kruskal();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
```

#### 3.二分图的判定与匈牙利算法求最大匹配

##### 1.判定方法染色法

```c++
const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (!color[i])
        {
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }

    if (flag) puts("Yes");
    else puts("No");

    return 0;
}
```

##### 2.最大匹配

```c++
const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n1; i ++ )
    {
        memset(st, false, sizeof st);
        if (find(i)) res ++ ;
    }

    printf("%d\n", res);

    return 0;
}
```

#### 4.最短路计数

求出最短路的条数

```c++
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    cnt[1] = 1;

    int hh = 0, tt = 0;
    q[0] = 1;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + 1)
            {
                dist[j] = dist[t] + 1;
                cnt[j] = cnt[t];
                q[ ++ tt] = j;
            }
            else if (dist[j] == dist[t] + 1)
            {
                cnt[j] = (cnt[j] + cnt[t]) % mod;
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bfs();

    for (int i = 1; i <= n; i ++ ) printf("%d\n", cnt[i]);

    return 0;
}
```

#### 5.floyd求最小环（至少包含三个点）

```wiki
设环的形式是：i<->k<->j , i<-->j （i,j,k不同） 
floyd是典型的插点算法，每次插入点k，为此，在点k被[插入前]可计算i-j-k这个环
即此时中间节点为：1~k-1，即我们已经算出了任意i<->j的最短道路，中间经过的节点可以为 (1,2,3,...,k-1)
我们只需枚举所有以k为环中最大节点的环即可。

pos[i][j]:i~j的最短路中经过的点是k(即由这个状态转移过来)，且这个k是此路径中编号最大的点(除i,j)//根据Floyd算法实质决定
这条道路存在以下两条性质
1.在i~j的最短道路中，一定没有环(显然)
2.设i,j之间的最短道路经过点k(不同于i,j)，则i~k , k~j之间必然没有交集

2证：
如果有交集,设交点为k'(k' < k,根据Floyd算法实质相关)，则存在道路：
i<->k'<->j , 由于[i<->k'] < [i<->k] , [j->k'] < [j->k] 
显然这条道路更小，和假设矛盾所以一定没有交集

对于pos[i][j]，如果pos[i][j] == 0 : 说明i~j的最短路没有经过其他节点

因此借用性质2来求解道路，注意书写顺序，确保最后输出顺序正确
每次把i <-> j 之间划分成 i<->k , k<->j
```

```c++
int g[N][N] , d[N][N] ;
int pos[N][N] ; //记录当前状态由哪个点转移过来
vector<int> path ;
int n , m ;

//确保顺序正确
void dfs(int i , int j )    //i->j之间的路，输出i到j之间不包括i和j的道路
{
    int k = pos[i][j] ;

    if( k == 0 )    return ;    //如果是0，说明i,j之间不经过除i，j之外的其他点

    dfs(i , k); //i->newk
    path.push_back(k);  //k
    dfs(k , j); //newk->j

}

void get_path(int i , int j , int k )
{
    path.clear() ;
    path.push_back(k);  //边界
    path.push_back(i);
    dfs(i , j) ;    //k->i->j->k
    path.push_back(j);
}

int main()
{
    cin >> n >> m ; 

    memset(g , 0x3f ,sizeof g) ;
    for(int i = 0 ; i <= n ; i++ )  g[i][i] = 0 ;

    int a , b , c ;
    for(int i = 0 ; i < m ; i++ )
    {
        cin >> a >> b >> c ;
        g[a][b] = g[b][a] = min(g[a][b] , c) ;
    }

    memcpy(d , g , sizeof d );  //原图
    long long res = INF ;

    for(int k = 1 ; k <= n ; k++ )
    {
        //至少包含三个点的环所经过的点的最大编号是k
        for(int i = 1 ; i < k ; i++ )  //至少包含三个点，i，j，k不重合
            for(int j = i + 1 ; j < k ; j ++ )
            if(res > (LL)g[i][j] + d[i][k] + d[k][j] )
            {
                res = g[i][j] + d[i][k] + d[k][j] ;
                get_path(i , j , k) ;
            }

        for(int i = 1 ; i <= n ; i++ )
            for(int j = 1 ; j <= n ; j++ )
                if(g[i][j] > g[i][k] + g[k][j])
                {
                    g[i][j] = g[i][k] + g[k][j] ;
                    pos[i][j] = k ; 
                }
    }

    if(res == INF)  
        cout << "No solution." << endl;
    else
    {
        for(auto x : path)
            cout << x << ' ' ;
        cout << endl;
    }

    return 0;
}
```

#### 6.类Floyd算法

求从起点到终点恰好经过 $N<=1000000$ 条边的最短路

##### 类Floyd算法+qmi(快速幂)

##### 时间复杂度 $O(logN*n^3)$ N指的是题中所说从起点S到终点E所经过的边数

`//需要在快速幂的框架下做logN次类floyd算法`

在研究此题前我们先对比一下类Floyd算法和Floyd算法的区别与联系

##### 普通Floyd

```cpp
for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
```

我们不难发现之所以Floyd可以得到所有点对间的最短距离是因为每次都是一条边一条边的的更新，图示如下  
![批注 2020-07-28 120823.png](https://cdn.acwing.com/media/article/image/2020/07/28/15856_24fba108d0-批注-2020-07-28-120823.png)

##### 类Floyd算法

```markdown
static int temp[N][N];
    memset(temp,0x3f,sizeof temp);
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                temp[i][j]=min(temp[i][j],a[i][k]+b[k][j]);
```

我们发现做一次类Floyd好像不用并不会去用该次的结果自我更新，只会用上一次的结果来更新一次，不像Floyd那样可以自己更新自己多次！图示如下  
![批注 2020-07-28 122253.png](https://cdn.acwing.com/media/article/image/2020/07/28/15856_048f9670d0-批注-2020-07-28-122253.png)

```cpp
const int N = 210;

int k, n, m, S, E;
int g[N][N];
int res[N][N];

void mul(int c[][N], int a[][N], int b[][N])
{
    static int temp[N][N];
    memset(temp, 0x3f, sizeof temp);
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                temp[i][j] = min(temp[i][j], a[i][k] + b[k][j]);
    memcpy(c, temp, sizeof temp);
}

void qmi()
{
    memset(res, 0x3f, sizeof res);
    for (int i = 1; i <= n; i ++ ) res[i][i] = 0;

    while (k)
    {
        if (k & 1) mul(res, res, g);    // res = res * g
        mul(g, g, g);   // g = g * g
        k >>= 1;
    }
}

int main()
{
    cin >> k >> m >> S >> E;

    memset(g, 0x3f, sizeof g);
    map<int, int> ids;
    if (!ids.count(S)) ids[S] = ++ n;
    if (!ids.count(E)) ids[E] = ++ n;
    S = ids[S], E = ids[E];

    while (m -- )
    {
        int a, b, c;
        cin >> c >> a >> b;
        if (!ids.count(a)) ids[a] = ++ n;
        if (!ids.count(b)) ids[b] = ++ n;
        a = ids[a], b = ids[b];

        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    qmi();

    cout << res[S][E] << endl;

    return 0;
}
```

#### 7.spfa求负环（01分数规划）

##### 题目大意

我们有 $n$ 个字符串，每个字符串都是由 $a∼z$ 的小写英文字母组成的。

如果字符串 $A$ 的结尾两个字符刚好与字符串 $B$ 的开头两个字符相匹配，那么我们称 $A$ 与 $B$ 能够相连（注意：$A$ 能与 $B$ 相连不代表 $B$ 能与 $A$ 相连）。

我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。

如下例：

```nginx
ababc
bckjaca
caahoynaab
```

第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 $5+7+10=22$（重复部分算两次），总共使用了 $3$ 个串，所以平均长度是 $\frac{22}{3}≈7.33$

##### 分析

###### 1.建图:

一个比较直观的建图方式是将每个单词作为一个节点,如果这两个单词能够相连,则在这两个单词之间连接一条有向边,此时最多有$10^5$个点,$10^{10}$条边,不能接受.  
考虑一个对偶的建图方式,将每一个单词看作一条边,其开头两个字符和结尾两个字符为它两边的点.  
这样建图的话,节点数就缩小到了$676$个($26*26$),边数为$10^{5}$条.

###### 2.$0/1$分数规划

我们所要求的答案为$\frac{\sum len}{s}$的最大值,其中$s$表示单词个数,$len$表示每个单词的长度.  
可以发现所求问题具有单调性,可以使用二分来求解.  
设左端点为$l$,右端点为$r$,中点为$mid$,则当$\frac{\sum len}{s} > mid$时, $\sum len-s \times mid>0$,则可以将图中的边权设成$len[i] - mid$($len[i]$表示当前单词的长度).  
在此基础上,原问题可以转化为求当前图中有无正环.

###### 3.优化

在用SPFA求正环的过程中,可以采取一种比较取巧的方法:当求最长路时,经过的点大于某一个数时,我们就可以武断地认为当前图中存在一个正环.

###### 代码

```cpp
#include 
#include 
#include 
#include 
using namespace std;

const int N = 700, M = 100010;

int n;
int h[N], e[M], w[M], ne[M], idx;
double dist[N];
int q[N], cnt[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

bool check(double mid) {
    memset(st, 0, sizeof(st));
    memset(cnt, 0, sizeof(cnt));
    int hh = 0, tt = 0;
    for (int i = 0; i < 676; i++) {
        q[tt++] = i;
        st[i] = true;
    }
    int count = 0;
    while (hh != tt) {
        int t = q[hh++];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
             if (dist[j] < dist[t] + w[i] - mid) {
                 dist[j] = dist[t] + w[i] - mid;
                 cnt[j] = cnt[t] + 1;
                 if (++count > 10000) return true;
                 if (cnt[j] >= N) return true;
                 if (!st[j]) {
                     q[tt++] = j;
                     if (tt == N) tt = 0;
                     st[j] = true;
                 }
             }
        }
    }
    return false;
}

int main() {
    char str[1010];
    while (scanf("%d", &n)) {
        if (n == 0) break;
        memset(h, -1, sizeof(h));
        idx = 0;
        for (int i = 0; i < n; i++) {
            scanf("%s", str);
            int len = strlen(str);
            if (len >= 2) {
                int left = (str[0] - 'a') * 26 + str[1] - 'a',
                    right = (str[len - 2] - 'a') * 26 + str[len - 1] - 'a';
                add(left, right, len);
            }
        }
        if (!check(0)) puts("No solution");
        else {
            double l = 0, r = 1000;
            while (r - l > 1e-4) {
                double mid = (l + r) / 2;
                if (check(mid)) l = mid;
                else r = mid;
            }
            printf("%lf\n", r);
        }
    }
    return 0;
}
```

#### 8.差分约束

 给定 $n$ 个区间 $[a_i,b_i]$ 和 $n$ 个整数 $c_i$。 你需要构造一个整数集合 $Z$，使得 $\forall i \in [1,n]$，$Z$ 中满足 $a_i \le x \le b_i$ 的 整数 $x$ 不少于 $c_i$ 个。 求这样的整数集合 $Z$ 最少包含多少个数。 

这里可以使用前缀和的思想求解，因为前缀和中S\[0\]=0，所有这里将$a_i,b_i$所在的区间范围加上一个1，区间范围变成了\[1, 50001\]，这样并不影响最终的结果。
    
*   S\[i\]表示：1~i中被选出数的个数。我们最终要求解的就是$S_{50001}$的最小值，因此需要使用最长路径。
    
*   对于S，S需要满足如下条件：
    

（1）$S_i \ge S_{i-1}, 1 \le i \le 50001$；

（2）$S_i - S_{i-1} \le 1 \iff S_{i-1} \ge S_i - 1$；

（3）区间\[a, b\]中至少有c个数$\iff S_b - S_{a - 1} \ge c \iff S_b \ge S_{a-1} + c$；

*   需要验证一下：从源点出发，是否一定可以走到所有的边。根据条件（1），从i-1可以走到i，因此从0可以走到1，从1可以走到2，......，因此存在这样的源点。

```perl
#include 
#include 

using namespace std;

const int N = 50010, M = 150010;

int n;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int q[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

void spfa() {

    memset(dist, -0x3f, sizeof dist);

    int hh = 0, tt = 0;
    q[tt++] = 0;
    st[0] = true;
    dist[0] = 0;

    while (hh != tt) {

        int t = q[hh++];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] < dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q[tt++] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
}

int main() {

    scanf("%d", &n);

    memset(h, -1, sizeof h);

    for (int i = 1; i <= 50001; i++) {
        add(i - 1, i, 0);
        add(i, i - 1, -1);
    }

    for (int i = 0; i < n; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        a++, b++;
        add(a - 1, b, c);
    }

    spfa();

    printf("%d\n", dist[50001]);

    return 0;
}
```

#### 9.强联通分量

```c++
//tarjan
#include <bits/stdc++.h>
using namespace std;
void solve(){
   int n, m;
   cin >> n >> m; 
   vector<vector<int>>g(n + 1);
   vector<int>dfn(n + 1), low(n + 1);
   vector<int>st(n + 1), sz(n + 1), id(n + 1), dout(n + 1);
   stack<int>stk;
   int time = 0, scc_cnt = 0;
   for (int i = 1; i <= m; i ++){
      int a, b;
      cin >> a >> b;
      g[a].push_back(b);
   }
   auto tarjan = [&](auto self, int u) ->void{
      dfn[u] = low[u] = ++ time;
      stk.push(u);
    //   st[u] = true;
      for (int i = 0; i < g[u].size(); i ++){
         int v = g[u][i]; 
         if(!dfn[v]){
            self(self, v);
            low[u] = min(low[u], low[v]);
         } else{
            low[u] = min(low[u], dfn[v]);
         }
      }

      if(dfn[u] == low[u]){
         ++ scc_cnt;
        int y;
        do {
            y = stk.top();stk.pop();
            st[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt] ++ ;
        } while (y != u);
      }
   };
   for (int i = 1; i <= n; i ++){
      if(!dfn[i])tarjan(tarjan, i);
   }
   for (int i = 1; i <= n; i ++){
      for (int j = 0; j < g[i].size(); j ++){
         int v = g[i][j];
         int a = id[i], b = id[v];
         if(a != b){
            dout[a] ++;
         }
      }
   }
   int zeros = 0, sum = 0;
   for (int i = 1; i <= scc_cnt; i ++){
      if(dout[i] == 0){
         zeros ++;
         sum += sz[i];
      }
   }
   cout << (zeros > 1 ? 0 : sum) << "\n";
}
int main(){
   ios::sync_with_stdio(false);
   cin.tie(0); cout.tie(0);
   
   int T = 1;
   while(T --)solve();
   return 0;
}
```

#### 10.双联通分量（求无向图中的桥）

```c++
const int N = 5010, M = 20010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if (dfn[u] < low[j])
                is_bridge[i] = is_bridge[i ^ 1] = true;
        }
        else if (i != (from ^ 1))
            low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ dcc_cnt;
        int y;
        do {
            y = stk[top -- ];
            id[y] = dcc_cnt;
        } while (y != u);
    }
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }

    tarjan(1, -1);

    for (int i = 0; i < idx; i ++ )
        if (is_bridge[i])
            d[id[e[i]]] ++ ;

    int cnt = 0;
    for (int i = 1; i <= dcc_cnt; i ++ )
        if (d[i] == 1)
            cnt ++ ;

    printf("%d\n", (cnt + 1) / 2);

    return 0;
}
```

#### 11.LCA

```c++
//倍增
void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}


//tarjan
const int N = 10010, M = N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int p[N];
int res[M];
int st[N];
vector<PII> query[N];   // first存查询的另外一个点，second存查询编号

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa) continue;
        dist[j] = dist[u] + w[i];
        dfs(j, u);
    }
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void tarjan(int u)
{
    st[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            tarjan(j);
            p[j] = u;
        }
    }

    for (auto item : query[u])
    {
        int y = item.first, id = item.second;
        if (st[y] == 2)
        {
            int anc = find(y);
            res[id] = dist[u] + dist[y] - dist[anc] * 2;
        }
    }

    st[u] = 2;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    for (int i = 1; i <= n; i ++ ) p[i] = i;

    dfs(1, -1);
    tarjan(1);

    for (int i = 0; i < m; i ++ ) printf("%d\n", res[i]);

    return 0;
}
```

### 五、动态规划

#### 1.多重背包问题

```c++
//二进制优化log
int main()
{
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt ++ ;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt ++ ;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}

//单调队列优化线性
const int N = 20010;
int f[N], g[N], q[N];
int main()
{
    int n, m;
    cin >> n >> m;
    int v, w, s;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        for (int r = 0; r < v; r ++ )
        {
            int hh = 0, tt = -1;
            for (int j = r; j <= m ; j += v)
            {
                while (hh <= tt && j - q[hh] > s * v)hh ++;
                while (hh <= tt && g[q[tt]] - (q[tt] - r) / v * w <= g[j] - (j - r) / v * w)tt--;
                q[++tt] = j;
                f[j] = g[q[hh]] + (j - q[hh]) / v * w;
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

#### 2.背包问题求方案数

```c++
int n, m;
int f[N], g[N];

int main()
{
    cin >> n >> m;

    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    g[0] = 1;

    for (int i = 0; i < n; i ++ )
    {
        int v, w;
        cin >> v >> w;
        for (int j = m; j >= v; j -- )
        {
            int maxv = max(f[j], f[j - v] + w);
            int s = 0;
            if (f[j] == maxv) s = g[j];
            if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod;
            f[j] = maxv, g[j] = s;
        }
    }

    int res = 0;
    for (int i = 1; i <= m; i ++ )
        if (f[i] > f[res])
            res = i;

    int sum = 0;
    for (int i = 0; i <= m; i ++ )
        if (f[i] == f[res])
            sum = (sum + g[i]) % mod;

    cout << sum << endl;

    return 0;
}
```

#### 3.背包问题求具体方案

```c++
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = n; i >= 1; i -- )
        for (int j = 0; j <= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }

    int j = m;
    for (int i = 1; i <= n; i ++ )
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])
        {
            cout << i << ' ';
            j -= v[i];
        }

    return 0;
}
```

#### 4.数位dp

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1e5 + 10;
int n, m, k;
int f[15][15], a[N], cnt;
int dfs(int u, int s, int num, int limit, int lead){
	if(!u){
		if(!num && lead)return 1;
		else return s;
	};
	if(!limit && !lead && f[u][s] != -1)return f[u][s];
	int up = limit ? a[u] : 9, sum = 0;
	for (int i = 0; i <= up; i ++){
		int t = s;
		if(i == num){
			if(!num)t += !lead;
			else t ++;
		}
		sum += dfs(u - 1, t, num, limit && (i == up), lead && (i == 0));
	}  
	return !limit && !lead ? f[u][s] = sum : sum;
}
int get(int x, int y){
	cnt = 0;
	memset(f, -1, sizeof f);
	while(x){
		a[++ cnt] = x % 10;
		x /= 10;
	}
	return dfs(cnt, 0, y, 1, 1);
}
void solve(){
	if(n > m)swap(n, m);
	for (int i = 0; i < 10; i ++){
		cout << get(m, i) - get(n - 1, i) << " \n"[i == 9];	
	}
}
int main(){
	ios :: sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(cin >> n >> m, n && m) solve();
	
	return 0;
}
```

#### 5.状压dp（方格问题）

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1e5 + 10;
int n, m, k;
bool st[1 << 12];
vector<int>state[1 << 12];
LL f[15][1 << 15];
void solve(){
	for (int i = 0; i < 1 << n; i ++){
		st[i] = false;
		int cnt = 0, flag = true;
		for (int j = 0; j < n; j ++){
			if(i >> j & 1){
				if(cnt % 2)flag = false;
				cnt = 0;
			}
			else cnt ++;
		}
		if(cnt % 2)flag = false;
		if(flag)st[i] = true;
	}
	for (int i = 0; i < 1 << n; i ++){
		state[i].clear();
		for (int j = 0; j < 1 << n; j ++){
			if((i & j) == 0 && st[i | j]){
				state[i].push_back(j);
			}
		}
	}
	memset(f, 0, sizeof f);
	f[0][0] = 1;
	for (int i = 1; i <= m; i ++){
		for (int j = 0; j < 1 << n; j ++){
			for (auto k : state[j]){
				f[i][j] += f[i - 1][k];
			}
		}
	}
	cout << f[m][0] << "\n";
}
int main(){
	ios :: sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(cin >> n >> m, n || m) solve();
	
	return 0;
}
```

#### 6.状压dp(最短汉密尔顿回路)

```c++
const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;

    for (int i = 0; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
                for (int k = 0; k < n; k ++ )
                    if (i >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);

    cout << f[(1 << n) - 1][n - 1];

    return 0;
}
```

#### 7.树的直径

```c++
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u, int father)
{
    int dist = 0; // 表示从当前点往下走的最大长度
    int d1 = 0, d2 = 0;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (j == father) continue;
        int d = dfs(j, u) + w[i];
        dist = max(dist, d);

        if (d >= d1) d2 = d1, d1 = d;
        else if (d > d2) d2 = d;
    }

    ans = max(ans, d1 + d2);

    return dist;
}

int main()
{
    cin >> n;

    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    dfs(1, -1);

    cout << ans << endl;

    return 0;
}
```

#### 8.树的中心

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 10010, M = 2 * N;
int e[M], ne[M], w[M], h[N], idx;
int d1[N], d2[N], up[N], p[N];
void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}
int dfs_d(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j == fa)continue;
        int t = dfs_d(j, u) + w[i];
        if(t > d1[u])d2[u] = d1[u], d1[u] = t, p[u] = j;
        else if(t > d2[u])d2[u] = t;
    }
    return d1[u];
}
void dfs_u(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j == fa)continue;
        if(p[u] == j)up[j] = max(up[u], d2[u]) + w[i];
        else up[j] = max(up[u], d1[u]) + w[i];
        dfs_u(j, u);
    }
}
void solve()
{
    memset(h, -1, sizeof h);
    int n;scanf("%d", &n);
    for (int i = 0; i < n - 1; i ++)
    {
        int a, b, c;scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }
    dfs_d(1, -1);
    dfs_u(1, -1);
    int res = 1e9;
    for (int i = 1; i <= n; i ++)res = min(res, max(d1[i], up[i]));
    cout << res << "\n";
}
int main()
{
    int T = 1;
    while(T --)solve();
    return 0;
}
```

#### 9.边覆盖问题

```c++
const int N = 1510;

int n;
int h[N], e[N], ne[N], idx;
int f[N][2];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][0] = 0, f[u][1] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        f[u][0] += f[j][1];
        f[u][1] += min(f[j][0], f[j][1]);
    }
}

int main()
{
    while (cin >> n)
    {
        memset(h, -1, sizeof h);
        idx = 0;

        memset(st, 0, sizeof st);
        for (int i = 0; i < n; i ++ )
        {
            int id, cnt;
            scanf("%d:(%d)", &id, &cnt);
            while (cnt -- )
            {
                int ver;
                cin >> ver;
                add(id, ver);
                st[ver] = true;
            }
        }

        int root = 0;
        while (st[root]) root ++ ;
        dfs(root);

        printf("%d\n", min(f[root][0], f[root][1]));
    }

    return 0;
}
```

#### 10.点覆盖问题

```c++
int n;
int h[N], w[N], e[N], ne[N], idx;
int f[N][3];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][2] = w[u];

    int sum = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        f[u][0] += min(f[j][1], f[j][2]);
        f[u][2] += min(min(f[j][0], f[j][1]), f[j][2]);
        sum += min(f[j][1], f[j][2]);
    }

    f[u][1] = 1e9;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        f[u][1] = min(f[u][1], sum - min(f[j][1], f[j][2]) + f[j][2]);
    }
}

int main()
{
    cin >> n;

    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int id, cost, cnt;
        cin >> id >> cost >> cnt;
        w[id] = cost;
        while (cnt -- )
        {
            int ver;
            cin >> ver;
            add(id, ver);
            st[ver] = true;
        }
    }

    int root = 1;
    while (st[root]) root ++ ;

    dfs(root);

    cout << min(f[root][1], f[root][2]) << endl;

    return 0;
}
```

#### 11.单调队列优化dp(最大子序和问题)

给一个长度为 $n$ 的数组，求出数组中不超过 $m$ 的最大连续子序列的值的和

```c++
int n, m;
int s[N];
int q[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]), s[i] += s[i - 1];

    int res = -INF;
    int hh = 0, tt = 0;

    for (int i = 1; i <= n; i ++ )
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf("%d\n", res);

    return 0;
}
```

#### 12.线性dp(方格取数)

给一个 $n \times n$ 的方格，可以从 $(0, 0)$ 到 $(n, m)$ 走两次，求最大的取数和是多少

```c++
const int N = 15;

int n;
int w[N][N];
int f[N * 2][N][N];

int main()
{
    scanf("%d", &n);

    int a, b, c;
    while (cin >> a >> b >> c, a || b || c) w[a][b] = c;

    for (int k = 2; k <= n + n; k ++ )
        for (int i1 = 1; i1 <= n; i1 ++ )
            for (int i2 = 1; i2 <= n; i2 ++ )
            {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n)
                {
                    int t = w[i1][j1];
                    if (i1 != i2) t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1 - 1][i2] + t);
                    x = max(x, f[k - 1][i1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1][i2] + t);
                }
            }

    printf("%d\n", f[n + n][n][n]);
    return 0;
}
```

#### 13.线性dp（最长上升子序列）

给出一些导弹发射高度，其中导弹防御系统可以防御单调不降的导弹，求最少多少个系统可以防御

**求最长单调下降子序列长度即可**

```c++
for (int i = 1; i <= n; ++ i)
    {
        int l = 0, r = cnt; //二分出插入的区间左端点
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= w[i]) r = mid;    //右边的性质满足q[k] >= w[i]
            else l = mid + 1;
        }
        if (q[r] < w[i]) r ++ ; //处理边界，当没有能够满足当前高度的系统时，再开一个
        cnt = max(cnt, r);
        q[r] = w[i];
    }
    cout << cnt << endl;

```

#### 14.最长公共上升子序列

### 算法

##### (DP,线性DP,前缀和) $O(n^2)$

这道题目是[AcWing 895. 最长上升子序列](https://www.acwing.com/problem/content/897/)和[AcWing 897. 最长公共子序列](https://www.acwing.com/problem/content/899/)的结合版，在状态表示和状态计算上都是融合了这两道题目的方法。

状态表示：

*   `f[i][j]`代表所有`a[1 ~ i]`和`b[1 ~ j]`中以`b[j]`结尾的公共上升子序列的集合；
*   `f[i][j]`的值等于该集合的子序列中长度的最大值；

状态计算（对应集合划分）：

首先依据公共子序列中是否包含`a[i]`，将`f[i][j]`所代表的集合划分成两个不重不漏的子集：

*   不包含`a[i]`的子集，最大值是`f[i - 1][j]`；
*   包含`a[i]`的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在`b[]`中是哪个数：
    *   子序列只包含`b[j]`一个数，长度是1；
    *   子序列的倒数第二个数是`b[1]`的集合，最大长度是`f[i - 1][1] + 1`；
    *   …
    *   子序列的倒数第二个数是`b[j - 1]`的集合，最大长度是`f[i - 1][j - 1] + 1`；

如果直接按上述思路实现，需要三重循环：

```cpp
for (int i = 1; i <= n; i ++ )
{
    for (int j = 1; j <= n; j ++ )
    {
        f[i][j] = f[i - 1][j];
        if (a[i] == b[j])
        {
            int maxv = 1;
            for (int k = 1; k < j; k ++ )
                if (a[i] > b[k])
                    maxv = max(maxv, f[i - 1][k] + 1);
            f[i][j] = max(f[i][j], maxv);
        }
    }
}
```

然后我们发现每次循环求得的`maxv`是满足`a[i] > b[k]`的`f[i - 1][k] + 1`的前缀最大值。  
因此可以直接将`maxv`提到第一层循环外面，减少重复计算，此时只剩下两重循环。

最终答案枚举子序列结尾取最大值即可。

```cpp
#include 
#include 
#include 

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);

    for (int i = 1; i <= n; i ++ )
    {
        int maxv = 1;
        for (int j = 1; j <= n; j ++ )
        {
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
            if (a[i] > b[j]) maxv = max(maxv, f[i - 1][j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[n][i]);
    printf("%d\n", res);

    return 0;
}
```

#### 15.有依赖的背包问题

有 $n$ 个物品，它们有依赖关系，如果选择一个物品必须选择它的父节点，求最大价值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 210;
int e[M], ne[M], h[N], idx;
int f[N][N], v[N], w[N];
int n, m;
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son = e[i];
        dfs(son);
        for (int j = m - v[u]; j >= 0; j --)
            for (int k = 0; k <= j; k ++)
                f[u][j] = max(f[u][j], f[son][k] + f[u][j - k]);
    }
    for (int i = m; i >= v[u]; i --)f[u][i] = f[u][i - v[u]] + w[u];
    for (int i = 0; i < v[u]; i ++)f[u][i] = 0;
}
void solve()
{
    memset(h, -1, sizeof h);
    int root = 0;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
    {
        scanf("%d%d", &v[i], &w[i]);
        int p;scanf("%d", &p);
        if(p == -1)root = i;
        else add(p, i);
    }
    dfs(root);
    cout << f[root][m];
}
int main()
{
    int T = 1;
    while(T --)solve();
    return 0;
}
```

#### 16.分组背包问题

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int s[N];
int v[N][N], w[N][N];
int f[N];
int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for(int j = 1; j <= s[i]; j++)
        {
            cin >> v[i][j] >> w[i][j];
        }
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = m; j >= 0; j--)
        {
            for(int k = 1; k <= s[i]; k ++)
            {
                if(j >= v[i][k])f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

#### 17.矩阵乘法优化dp

求斐波那契数列前 $n$ 项的和 $S_n$ $mod  m$ 的值 

首先推一下公式

$f _ n = f _ {n - 1} + f _ {n - 2}$  
$S _ n - S _ {n - 1} = f _ n$  
$= f _ {n - 1} + f _ {n - 2}$  
$= S _ {n - 1} - S _ {n - 3}$  
所以 $S _ n - S _ {n - 1} = S _ {n - 1} - S _ {n - 3}$  
$S _ n = 2 \times S _ {n - 1} - S _ {n - 3}$

那么有递推式了，怎么构造矩阵呢？

> 结论：对于数列 $\{a _ n\}$，若$a _ i = k _ 1 a _ {i - 1} + k _ 2 a _ {i - 2} + \cdots + k _ i a _ 0$，那么 $ \left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right] ^ n \left[\begin{matrix} a _ {i - 1} \\ a _ {i - 2} \\ \vdots \\ a _ 1 \\ a _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} a _ {n + i - 1} \\ a _ {n + i - 2} \\ \vdots \\ a _ {n + 1} \\ a _ n \\ \end{matrix}\right]$ 

证明：

因为 $ \left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right] \left[\begin{matrix} a _ {i - 1} \\ a _ {i - 2} \\ \vdots \\ a _ 1 \\ a _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} a _ i \\ a _ {i - 1} \\ \vdots \\ a _ 2 \\ a _ 1 \\ \end{matrix}\right]$ 

所以此结论对于 $n = 1$ 成立

假设此结论对于 $n = N$ 成立，那么有  
$\left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right] ^ N \left[\begin{matrix} a _ {i - 1} \\ a _ {i - 2} \\ \vdots \\ a _ 1 \\ a _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} a _ {N + i - 1} \\ a _ {N + i - 2} \\ \vdots \\ a _ {N + 1} \\ a _ N \\ \end{matrix}\right]$

两边同时左乘矩阵 $ \left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right]$ 

得 $ \left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right] ^ {N + 1} \left[\begin{matrix} a _ {i - 1} \\ a _ {i - 2} \\ \vdots \\ a _ 1 \\ a _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} k _ 1 & k _ 2 & \cdots & k _ {i - 1} & k _ i \\ 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ \end{matrix}\right] \left[\begin{matrix} a _ {N + i - 1} \\ a _ {N + i - 2} \\ \vdots \\ a _ {N + 1} \\ a _ N \\ \end{matrix}\right] = \left[\begin{matrix} k _ 1 \times a _ {N + i - 1} + k _ 2 \times a _ {N + i - 2} + \cdots + k _ i \times a _ N \\ a _ {N + i - 1} \\ \vdots \\ a _ {N + 2} \\ a _ {N + 1} \\ \end{matrix}\right] = \left[\begin{matrix} a _ {N + i} \\ a _ {N + i - 1} \\ \vdots \\ a _ {N + 2} \\ a _ {N + 1} \\ \end{matrix}\right]$ 

所以此结论对于 $n = N$ 也成立。

所以此结论对于任意的 $n \in N ^ +$ 都成立，证毕

由上述结论，可以构造出矩阵 $A = \left[\begin{matrix} 2 & 0 & -1 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \\ \end{matrix}\right],\ S = \left[\begin{matrix} S _ 2 \\ S _ 1 \\ S _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} f _ 0 + f _ 1 + f _ 2 \\ f _ 0 + f _ 1 \\ f _ 0 \\ \end{matrix}\right] = \left[\begin{matrix} 2 \\ 1 \\ 0 \\ \end{matrix}\right]$

找到矩阵之后，用矩阵[快速幂](https://www.acwing.com/blog/content/24/)求出 $A ^ n$，然后再乘上矩阵 $S$，即可求出 $S _ n$

**注：该题矩阵快速幂的时间复杂度虽然是 $\mathcal O(\log n)$，看似能跑的飞快，但实际上还有 $27$ 的常数，并不能跑的飞快，当然过这题毫无压力**

```cpp
#include 
#include 
#include 
#include 

using namespace std;

typedef long long ll;

const int N = 3;

int n, m;
ll A[N][N] =    // 上述矩阵 A
{
    {2, 0, -1},
    {1, 0, 0},
    {0, 1, 0}
};
ll S[N] = {2, 1, 0}; // 上述矩阵 S（转置）

void multi(ll A[], ll B[][N]) // 计算方阵 B 乘向量 A，并将结果储存在 A 中
{
    ll ans[N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            ans[i] += A[j] * B[i][j] % m;
    for (int i = 0; i < N; i ++ )
        A[i] = ans[i] % m;
}

void multi(ll A[][N], ll B[][N]) // 计算方阵 A * B，并将结果储存在 A 中
{
    ll ans[N][N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                ans[i][j] += A[i][k] * B[k][j] % m;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            A[i][j] = ans[i][j] % m;
}

int main()
{
    scanf("%d%d", &n, &m);

    while (n)        // 矩阵快速幂
    {
        if (n & 1) multi(S, A);
        multi(A, A);
        n >>= 1;
    }

    printf("%lld", (S[2] % m + m) % m);

    return 0;
}
```



### 六、数学

#### 1.exgcd+excrt(解决同余方程，同余方程组，ax+by=c(mod m))

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
//m表示模数，a表示取模得到的数字，使用excrt要求a必须非负
//最终的答案可以写作ans=a1+km1
bool merge(LL &m1, LL &a1, LL m2, LL a2) {
    LL u, v;
    LL g = exgcd(m1, m2, u, v);
    LL m = m1 / g * m2;
    if ((a2 - a1) % g != 0) {
        return false;
    }
    LL d = (a2 - a1) / g;
    LL x = (__int128(u) * m1 * d + a1) % m;
    if (x < 0) {
        x += m;
    }
    m1 = m, a1 = x;
    return true;
}
```

#### 2.阶乘分解

```c++
int primes[N], cnt;
bool st[N];

void init(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;
    init(n);

    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        int s = 0;
        for (int j = n; j; j /= p) s += j / p;
        printf("%d %d\n", p, s);
    }

    return 0;
}
```

#### 3.欧拉函数

可见的点

```c++
const int N = 1010;

int primes[N], cnt;
bool st[N];
int phi[N];

void init(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0)
            {
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }
}

int main()
{
    init(N - 1);

    int n, m;
    cin >> m;
    for (int T = 1; T <= m; T ++ )
    {
        cin >> n;
        int res = 1;
        for (int i = 1; i <= n; i ++ ) res += phi[i] * 2;
        cout << T << ' ' << n << ' ' << res << endl;
    }

    return 0;
}
```

#### 4.容斥原理（Deuv和鲜花）

 Devu 有 $N$ 个盒子，第 $i$ 个盒子中有 $A_i$ 枝花。 同一个盒子内的花颜色相同，不同盒子内的花颜色不同。 Devu 要从这些盒子中选出 $M$ 枝花组成一束，求共有多少种方案。 若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。 结果需对 $10^9+7$ 取模之后方可输出。 

#### 理想情况

理想每一组中可以取无限朵花，那么我们就需要达到$x_1+x_2+x_3+……+x_n=M$。  
此时$x_i>=0$，那么令$y_i=x_i+1$，则$y_1+y_2+y_3+……+y_n=M+N$。  
因为$y_i>=1$，所以可以用隔板法,在$M+N-1$个空隙中插入$N-1$个板,答案为$C_{M+N-1}^{N-1}$。

#### 实际

在实际中有$x_1<=A_1,x_2<=A_2,x_3<=A_3……x_n<=A_n$等条件，此时就需要同时满足这N个条件。  
那么正难则反，考虑求补集，也就是至少不满足其中一个条件的方案。就可以用总方案减去这些方案就可以得出答案。  
设不满足$i$的方案为$s_i$，  
那么答案就是$C_{M+N-1}^{N-1}-|s_1\bigcup s_2\bigcup s_3……\bigcup s_n|$。  
将其展开就是：  
$C_{M+N-1}^{N-1}-|s_1|-|s_2|-……|s_3|+|s_1\bigcap s_2|+……-|s_1\bigcap s_2\bigcap s_3|-……$。  
就是一个容斥原理的展开。  
考虑$s_i$怎么求。以$s_1$举例，假如要求$s_1$，就代表我们必须从第一组里取出至少$A_1+1$朵花，那么此时还剩$M-(A_1+1)$朵花。剩下的就是隔板，  
那么此时方案就是$C_{M+N-1-(A_1+1)}^{N-1}$。  
那么$|s_1\bigcap s_2|$同上，方案就是$C_{M+N-1-(A_1+1)-(A_2+1)}^{N-1}$。  

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 21, mod = 1e9 + 7;
typedef long long LL;
int n, m, down = 1;
LL a[N];
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
int C(LL a, LL b)
{
    if (a < b) return 0;
    int up = 1;
    for (LL i = a; i > a - b; i -- ) up = i % mod * up % mod;
    return (LL)up * down % mod; 
}
int main()
{
    LL n, m;
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    for (int j = 1; j <= n - 1; j ++ ) down = (LL)j * down % mod;
    down = qmi(down, mod - 2, mod);
    int res = 0;
    for (int i = 0; i < 1 << n; i ++ )
    {
        LL x = m + n - 1, y = n - 1;
        int sign = 1;
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
            {
                sign *= -1;
                x -= a[j] + 1;
            }
        res = (res + C(x, y) * sign) % mod;
    }
    cout << (res + mod) % mod << endl;
    return 0;
}
```

#### 5.类欧定理

```c++
//求解(a * i + b) / m下取整的和,其中i范围是[0, n - 1]
LL floor_sum(LL n, LL m, LL a, LL b) {
    if(n == 0) return 0;
    LL ans = 0;
    ans += (a / m) * n * (n - 1) / 2, a %= m;
    ans += (b / m) * n, b %= m;
    LL y_max = a * n + b;
    ans += floor_sum(y_max / m, a, m, y_max % m);
    return ans;
}
```

#### 6.组合数学

```c++
#include <bits/stdc++.h>
using namespace std;
 
using LL = long long;
template<class T>
constexpr T power(T a, LL b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt(LL x = 0) : x(norm(x % P)) {}
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr MInt operator-() const {
        return MInt(P - x);
    }
    constexpr MInt inv() const {
        // assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(const MInt &rhs) {
        x = LL(x) * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(const MInt &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(const MInt &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(const MInt &rhs) {
        return *this *= rhs.inv();
    }
    constexpr friend MInt operator*(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    constexpr friend MInt operator+(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    constexpr friend MInt operator-(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    constexpr friend MInt operator/(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    constexpr friend std::istream &operator>>(std::istream &is, MInt &a) {
        LL v;
        is >> v;
        a = MInt(v);
        return is;
    }
    constexpr friend std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    constexpr friend bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    constexpr friend bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
const int P = 998244353;
using Z = MInt<P>;

struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m < 0) return 0;
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m < 0) return 0;
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m < 0) return 0;
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
    Z perm(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(n - m);
    }
} comb;
```

#### 7.线性基

```c++
struct LinearBasis {
    LL a[63], b[63];
    //a数组代表第i位是最高位对应的线性基的取值
    //b数组是类似于矩阵化简后的线性基的取值
    int sz;//表示线性基的维度
    bool flag;//代表线性基中有没有0
    LinearBasis() {
        memset(a, 0, sizeof a);
        memset(b, 0, sizeof a);
        sz = 0;
        flag = 0; 
    }
    void insert(LL x) {
        for (int i = 62; ~i; i--) {
            if (x >> i & 1) {
                if (a[i]) x ^= a[i];
                else {
                    a[i] = x;
                    return;
                }
            }
        }
        flag = true;
    }
    void simplify() {
        for(int i = 0; i <= 62; i++) {
            for(int j = i - 1; ~j; j--) {
                if(a[i] & (1ll << j)) {
                    a[i] ^= a[j];
                }
            }
            if(a[i])b[sz++] = a[i];
        }
    }
    LL qmax() {//求异或最大值
        LL res = 0;
        for (int i = 62; i >= 0; i--) {
            res = max(res, res ^ a[i]);
        }
        return res;
    }
    LL qmin() {//求异或最小值
        for (int i = 0; i <= 62; i++) {
            if(a[i])return a[i];
        }
    }
    LL query(LL k) {//求异或第k小值
        k -= flag;
        if(!k) return 0;
        if(k >= (1ll << sz))return -1;
        LL res = 0;
        for (int i = 0; i < sz; i++) {
            if(k & (1ll << i)) {
                res ^= b[i];
            }
        }
        return res;
    }
    LL size() {
        return 1ll << sz;
    }
};
```

#### 8.大质数分解

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

int t;
LL max_factor, n;
LL gcd(LL a, LL b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

LL quick_pow(LL x, LL p, LL mod) {  // 快速幂
    LL ans = 1;
    while (p) {
      if (p & 1) ans = (__int128)ans * x % mod;
      x = (__int128)x * x % mod;
      p >>= 1;
    }
    return ans;
}

bool Miller_Rabin(LL p) {  // 判断素数
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (p == 3) return 1;
    LL d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
    for (LL k = 0; k < 10; ++k) {
      LL a = rand() % (p - 2) + 2;
      LL x = quick_pow(a, d, p);
      if (x == 1 || x == p - 1) continue;
      for (int i = 0; i < r - 1; ++i) {
        x = (__int128)x * x % p;
        if (x == p - 1) break;
      }
      if (x != p - 1) return 0;
    }
    return 1;
}

LL Pollard_Rho(LL x) {
    LL s = 0, t = 0;
    LL c = (LL)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    LL val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
      for (step = 1; step <= goal; ++step) {
        t = ((__int128)t * t + c) % x;
        val = (__int128)val * abs(t - s) % x;
        if ((step % 127) == 0) {
          LL d = gcd(val, x);
          if (d > 1) return d;
        }
      }
      LL d = gcd(val, x);
      if (d > 1) return d;
    }
}

void fac(LL x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {              // 如果x为质数
      max_factor = max(max_factor, x);  // 更新答案
      return;
    }
    LL p = x;
    while (p >= x) p = Pollard_Rho(x);  // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
    scanf("%d", &t);
    while (t--) {
      srand((unsigned)time(NULL));
      max_factor = 0;
      scanf("%lld", &n);
      fac(n);
      if (max_factor == n)  // 最大的质因数即自己
        printf("Prime\n");
      else
        printf("%lld\n", max_factor);
    }
    return 0;
}

```

#### 9.随机化

```c++
mt19937_64 rndGen(chrono::steady_clock::now().time_since_epoch().count());
#define rint(l,r) uniform_int_distribution<int>(l,r)(rndGen)
#define rll(l,r) uniform_int_distribution<ll>(l,r)(rndGen)
#define rreal(l,r) uniform_real_distribution<double>(l,r)(rndGen)

```

#### 10.__int128输入与输出

```c++
inline void scan(__int128 &x) {
    x = 0;
    int f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch=='-')f = -1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
inline void print(__int128 x) {
    if(x < 0) {
        putchar('-');
        x = -x;
    }
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
```



