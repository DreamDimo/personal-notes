

# 算法模板总结

## 一.基础算法

### 1.排序

#### a.快速排序（双指针）

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;
int a[N];
void quick_sort(int a[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (a[i] < x);
        do j -- ; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++)cin >> a[i];
    quick_sort(a, 1, n);
    for (int i = 1; i <= n; i ++)cout << a[i] << " ";
    cout << endl;
    return 0;
}
~~~

#### b.归并排序(逆序对)

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10;
int a[N];
void merge_sort(int a[N], int l, int r)
{
    if(l >= r)return;
    int tmp[N], cnt = 0;
    int mid = l + r >> 1;
    merge_sort(a, l, mid), merge_sort(a, mid + 1, r);
    int i = l, j = mid + 1;
    while (i <= mid && j <= r)
    {
        if(a[i] <= a[j])tmp[cnt ++] = a[i++];
        else tmp[cnt ++] = a[j ++];
    }
    while(i <= mid)tmp[cnt ++] = a[i ++];
    while(j <= r)tmp[cnt++] = a[j ++];
    for(int i = l, j = 0; i <= r; i++, j++)a[i] = tmp[j];
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++ )cin >> a[i];
    merge_sort(a, 1, n);
    for (int i = 1; i <= n; i ++ )cout << a[i] << " ";
    return 0;
}
~~~

#### c.堆排序——动态求取中位数

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N =  1e5 + 10;
int a[N];
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n, m;
        scanf("%d%d", &m, &n);
        printf("%d %d\n", m, (n + 1) / 2);

        priority_queue<int> down;
        priority_queue<int, vector<int>, greater<int>> up;

        int cnt = 0;
        for (int i = 1; i <= n; i ++ )
        {
            int x;
            scanf("%d", &x);

            if (down.empty() || x <= down.top()) down.push(x);
            else up.push(x);

            if (down.size() > up.size() + 1) up.push(down.top()), down.pop();
            if (up.size() > down.size()) down.push(up.top()), up.pop();

            if (i % 2)
            {
                printf("%d ", down.top());
                if ( ++ cnt % 10 == 0) puts("");
            }
        }

        if (cnt % 10) puts("");
    }
    return 0;
}
~~~

### 2.位运算

#### a.求二进制中1的个数

~~~c++
for(int i=a;i;i-=i&-i)res++;//lowbit算法
~~~

#### b.求一个二进制的子集

~~~c++
int get(int x)
{
	int state = x;
	for (int i = state; i; i = (i - 1) & state) {
		//i就是state的子集	
	}
}
~~~

### 3.离散化

~~~c++
//下面这个离散化算法要求保证离散化前后的相对位置不能变
#include<bits/stdc++.h>
using namespace std;
vector<int>alls;
int find(int x)
{//二分找离散化的位置
    int l=0,r=alls.size()-1;
    while(l<r)
    {
        int mid=l+r>>1;
        if(alls[mid]>=x)r=mid;
        else l=mid+1;
    }
    return l+1;
}
int main()
{
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());
}
~~~

### 4.ST表

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 2e5 + 10, M = 18;
int f[N][M];
int a[N];
int n;
int query(int l, int r)
{
    int len = r - l + 1;
    int k = log(len) / log(2);
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}
void init()
{
    for (int j = 0; j < M; j ++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
        {
            if(!j)f[i][j] = a[i];
            else f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
        }
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )cin >> a[i];
    init();
    int m;
    cin >> m;
    while (m -- )
    {
        int l, r;
        cin >> l >> r;
        cout << query(l, r) << endl;
    }
    return 0;
}
~~~

## 二.数据结构

### 1.单调队列

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N];
int q[N],hh,tt=-1;
int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ;

        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
  puts("");

    hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ;

        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
    return 0;
}
~~~

### 2.KMP

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
char t[N],s[N];
int ne[N];
int main()
{
    int n, m;
    cin>>n>>t+1;
    cin>>m>>s+1;
    for (int i = 2,j =0 ;i<=n;i++)
    {
        while(j&&t[i]!=t[j+1])j=ne[j];
        if(t[i]==t[j+1])j++;
        ne[i]=j;
    }
    for(int i=1,j=0;i<=m;i++)
    {
        while(j&&s[i]!=t[j+1])j=ne[j];
        if(s[i]==t[j+1])j++;
        if(j==n)
        {
            printf("%d ",i-n);
            j=ne[j];
        }
    }
    return 0;
}
~~~

### 3.Trie树(字典树)

~~~C++
char s[N];
int son[N][26], cnt[N];
int idx;
void insert(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++)
    {
        int n = str[i] - 'a';
        if(!son[p][n])son[p][n] = ++ idx;
        p = son[p][n];
    }
    cnt[p]++;
}
int query(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++)
    {
        int n = str[i] - 'a';
        if(!son[p][n])return 0;
        p = son[p][n];
    }
    return cnt[p];
}
~~~

### 4.带权并查集

~~~c++
int p[N],d[N],cnt;
int find(int x)
{
    if(p[x]!=x)
    {
        int t=find(p[x]);
        d[x]+=d[p[x]];
        p[x]=t;
    }
    return p[x];
}
~~~

### 5.模拟哈希表(散列表)

~~~c++
//1.开放寻址法
const int N = 2e5 + 3, inf = 0x3f3f3f3f;
int h[N];
int find(int x)
{
    int t = (x % N + N) % N;
    while(h[t] != inf && h[t] != x)
    {
        t ++;
        if(t == N) t = 0;
    }
    return t;
}
//2.链式法则
const int N=1e5+10;
int h[N],e[N],ne[N],idx;
void insert(int x)
{
    int t=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[t];
    h[t]=idx++;
}
bool find(int x)
{
    int t=(x%N+N)%N;
    for(int i=h[t];i!=-1;i=ne[i])
    {
        if(e[i]==x)return true;
    }
    return false;
}
~~~

### 6.树状数组(求逆序对，动态求取前缀和)

~~~c++
int lowbit(int x)
{
    return x & (- x);
}
int ask(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i))res += tr[i];
    return res;
}
void add(int x, int k)
{
    for (int i = x; i <= n; i += lowbit(i))tr[i] += k;
}
~~~

### 7.线段树

~~~c++
typedef long long LL;
LL w[N];
struct Node
{
    int l, r;
    LL sum, add;
}tr[N * 4];
void pushup(int u)
{
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}
void pushdown(int u)
{
    Node& root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
    if(root.add)
    {
        left.sum += (LL)(left.r - left.l + 1) * root.add, left.add += root.add;
        right.sum += (LL)(right.r - right.l + 1) * root.add, right.add += root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], 0};
    else
    {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int v)
{
    if(tr[u].l >= l && tr[u].r <= r)tr[u].sum += (LL)(tr[u].r - tr[u].l + 1) * v, tr[u].add += v;
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= l)modify(u << 1, l, r, v);
        if(mid < r)modify(u << 1 | 1, l, r, v);
        pushup(u);
    }
}
LL query(int u, int l, int r)
{
    if(tr[u].l >= l && tr[u].r <= r)return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    LL s = 0;
    if(l <= mid)s += query(u << 1, l, r);
    if(mid < r)s += query(u << 1 | 1, l, r);
    return s;
}
~~~

### 8.AC自动机

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 10010 * 55, M = 1e6 + 10;
int tr[N][26], cnt[N], ne[N], idx;
char s[M];
void insert()
{//这里就是trie树的插入操作
    int u = 0;
    for(int i = 0; s[i]; i ++)
    {
        int k = s[i] - 'a';
        if(!tr[u][k])  tr[u][k] = ++ idx;
        u = tr[u][k];
    }
    cnt[u] ++;
}
int q[N];
void bfs()
{
    int hh = 0, tt = -1;
    for(int i = 0; i < 26; i ++)
    //将所有树根结点入队
        if(tr[0][i])  q[++ tt] = tr[0][i];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i < 26; i ++ )
        {
            int p = tr[t][i];
            //下面分情况讨论，如果没有这个儿子直接将它指向
            //有这个儿子的结点或者根节点
            if (!p) tr[t][i] = tr[ne[t]][i];
            //相反如果存在这个儿子的话，更新ne数组
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
            }
        }
    }
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t --)
    {
        memset(tr, 0, sizeof tr);
        memset(cnt, 0, sizeof cnt);
        memset(ne, 0, sizeof ne);
        idx = 0;
        int n;
        scanf("%d", &n);
        for(int i = 0; i < n; i ++)
        {
            scanf("%s", s); 
            insert();
        }
        bfs();
        scanf("%s", s);
        int res = 0;
        for (int i = 0, j = 0; s[i]; i ++ )
        {
            int t = s[i] - 'a';
            j = tr[j][t];//这里可以一步到位
            int p = j;
            while (p)
            {
                res += cnt[p];
                cnt[p] = 0;
                p = ne[p];
            }
        }
        printf("%d\n", res);
    }
    return 0;
}
~~~

## 三.图论与搜索

### 1.最短路模板：dijkstra、bellman_ford、spfa、floyd

~~~c++
//朴素版dijkstra
void dijkstra()  // 求1号点到n号点的最短路距离
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < n; i ++)
    {
        int t = -1;
        for (int j = 1; j <= n; j++)
        {
            if(!st[j] && (t == - 1 || dist[t] > dist[j]))t = j;
        }
        st[t] = true;
        for (int j = 1; j <= n; j ++)
        {
            if(dist[t] + g[t][j] < dist[j])dist[j] = dist[t] + g[t][j];
        }
    }
    if(dist[n] == 0x3f3f3f3f)puts("-1");
    else printf("%d\n", dist[n]);
}

//堆优化版dijkstra
void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}
int dijkstra()  // 求1号点到n号点的最短路距离
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>>q;
    q.push({dist[1], 1});
    while(q.size())
    {
        int a = q.top().first, b = q.top().second;
        q.pop();
        if(b == n)return dist[n];
        if(st[b])continue;
        st[b] = true;
        for (int i = h[b]; ~i ;i = ne[i])
        {
            int j = e[i];
            if(a + w[i] < dist[j])
            {
                dist[j] = a + w[i];
                q.push({dist[j], j});
            }
        }
    }
    return -1;
}

//bellman_ford
for (int i = 0; i < m; i ++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        e[i] = {a, b, c};
    }
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < k; i ++)
    {
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j < m; j ++)
        {
            int a = e[j].a, b = e[j].b, c = e[j].c;
            if(backup[a] + c < dist[b])dist[b] = backup[a] + c;
        }
    }

//spfa
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    while(q.size())
    {
        int u = q.front();q.pop();
        st[u] = false;
        for (int i = h[u]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[u] + w[i])
            {
                dist[j] = dist[u] + w[i];
                //spfa求负环
                //cnt[j] = cnt[t] + 1
                //if (cnt[j] >= n)return false;
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n];
}

//4.Floyd(多源汇最短路，时间复杂度O(n^3))
void floyd()
{
    for (int k = 1; k <= n; k ++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j ++)
                f[i][j] = f[i][k] + f[k][j];
}
~~~

### 2.最小生成树

~~~c++
//1.prim算法
int prim()
{
    int res = 0;
    memset(dist, 0x3f, sizeof dist);
    for (int i = 0; i < n; i ++)
    {
        int t = -1;
        for (int j = 1; j <= n; j ++)
            if(!st[j] && (t == -1 || dist[t] > dist[j]))t = j;
        if(i && dist[t] == INF)return INF;
        st[t] = true;
        if(i)res += dist[t];
        for (int j = 1; j <= n; j ++) dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}

//2.kustal算法
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = 2e5 + 10;
int n, m;
int p[M];
struct Edge
{
    int u, v, w;
    bool operator<(const Edge & e)const
    {
        return w < e.w;
    }
}a[M];
int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i ++)p[i] = i;
    for (int i = 1; i <= m; i ++)
    {
        int u, v, w;scanf("%d%d%d", &u, &v, &w);
        a[i] = {u, v, w};
    }
    int res = 0, cnt = 0;
    sort(a + 1, a + 1 + m);
    for (int i = 1; i <= m; i ++)
    {
        int u = a[i].u, v = a[i].v, w = a[i].w;
        int pa = find(u), pb = find(v);
        if(pa != pb)
        {
            p[pb] = pa;
            cnt ++;
            res += w;
        }
    }
    if(cnt < n - 1)puts("impossible");
    else printf("%d\n", res);
    return 0;
}
~~~

### 3.差分约束（找到不等式关系，利用spfa求负环的方法）

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010, M = 21010;
int e[M], ne[M], w[M], h[N], idx;
int n, ml, md;
int dist[N], q[N], cnt[N];
bool st[N];
void add(int a, int b, int c)  // 添加一条边a->b，边权为c
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
bool spfa(int size)
{
    int hh = 0, tt = 0;
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i <= size; i ++ )
    {
        q[tt ++ ] = i;
        dist[i] = 0;
        st[i] = true;
    }
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d%d%d", &n, &ml, &md);
    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++)add(i + 1, i, 0);
    while(ml--)
    {
        int a, b, l;scanf("%d%d%d", &a, &b, &l);
        if(a > b)swap(a, b);
        add(a, b, l);
    }
    while(md--)
    {
        int a, b, l;scanf("%d%d%d", &a, &b, &l);
        if(a > b)swap(a, b);
        add(b, a, -l);
    }
    if(spfa(n))puts("-1");
    else
    {
        spfa(1);
        if(dist[n] == 0x3f3f3f3f)puts("-2");
        else printf("%d\n", dist[n]);
    }
    return 0;
}
~~~

### 4.最近公共祖先

~~~c++
//1.LCA算法
void bfs(int root)
{//求每一个点的深度和祖宗结点
    queue<int>q;
    memset(d, 0x3f, sizeof d);
    d[0] = 0, d[root] = 1;
    q.push(root);
    while(q.size())
    {
        int t = q.front();q.pop();
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (d[j] > d[t] + 1)
            {
                d[j] = d[t] + 1;
                q.push(j);
                fa[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}
int lca(int a, int b)
{
    if(d[a] < d[b])swap(a, b);
    for (int i = 15; i >= 0; i --)
        if(d[fa[a][i]] >= d[b])a = fa[a][i];
    if(a == b)return b;
    for (int i = 15; i >= 0; i --)
        if(fa[a][i] != fa[b][i])
        {//因为设立了哨兵结点，所以结点如果跳出的话那么不会进入if，他们都是0
            a = fa[a][i];
            b = fa[b][i];
        }
    return fa[a][0];
}

//2.tarjan离线做法
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
const int N = 1e4 + 10, M = 2 * N;
int e[M], ne[M], w[M], h[N], idx, res[M];
int n, m;
int d[N], p[N], st[N];
vector<PII>query[N];
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
int find(int x)
{
    if(p[x] != x)return p[x] = find(p[x]);
    return p[x];
}
void dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j == fa)continue;
        d[j] = d[u] + w[i];
        dfs(j, u);
    }
}
void tarjan(int u)
{
    st[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(!st[j])
        {
            tarjan(j);
            int pa = find(j), pb = find(u);
            p[pa] = pb;
        }
    }
    for (auto item : query[u])
    {
        int y = item.first, id = item.second;
        if (st[y] == 2)
        {
            int anc = find(y);
            res[id] = d[u] + d[y] - d[anc] * 2;
        }
    }
    st[u] = 2;
}
int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)p[i] = i;
    for (int i = 0; i < n - 1; i ++)
    {
        int x, y, k;scanf("%d%d%d", &x, &y, &k);
        add(x, y, k), add(y, x, k);
    }
    for (int i = 1; i <= m; i ++)
    {
        int x, y;scanf("%d%d", &x, &y);
        query[x].push_back({y, i});
        query[y].push_back({x, i});
    }
    dfs(1, -1);
    tarjan(1);
    for (int i = 1; i <= m; i ++)printf("%d\n", res[i]);
    return 0;
}
~~~

### 5.拓扑序

~~~c++
bool bfs()
{
	for (int i = 1; i <= n; i++)
	{
		if (!d[i])q[++tt] = i;
	}
	while (hh <= tt)
	{
		int t = q[hh++];
		for (int i = h[t]; i != -1; i = ne[i])
		{
			int j = e[i];
			d[j]--;
			if (!d[j])
			{
				q[++tt] = j;
			}
		}
	}
	return tt == n - 1;
}
~~~

### 6.二分图

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m;
int e[N],ne[N],h[N],idx;
int col[N];
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
bool dfs(int u,int x)
{
    col[u]=x;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!col[j])
        {
            if(!dfs(j,3-x)) return false;
        }
        else if(col[j]==x)return false;
    }
    return true;
}
int main()
{
    memset(h,-1,sizeof h);
    cin>>n>>m;
    while(m--)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    bool res=true;
    for(int i=1;i<=n;i++)
    {
        if(!col[i])
        {
            if(!dfs(i,1))res=false;
        }
    }
    if(!res)puts("No");
    else puts("Yes");
    return 0;
}


//匈牙利算法求二分图的最大匹配
bool find(int a)
{
	for (int i = h[a]; i!= -1; i = ne[i])
	{
		int j = e[i];
		if (!st[j])
		{
		    st[j]=true;
			if (!match[j] || find(match[j]))
			{
				match[j] = a;
				return true;
			}
		}
	}
	return false;
}
~~~

### 7.迭代加深与dfs分组问题

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N = 70;
int a[N];
bool st[N];
int n;
int len, sum;
bool dfs(int u, int cur, int start)
{//表示第u组，目前这一组的长度为cur，组合问题要求下标单调，所以要有start表示本轮开始循环位置
    if (u * len == sum) return true;//如果总共的长度已经符合那么返回true
    if (cur == len) return dfs(u + 1, 0, 0);//一个木棒已经完成，注意要return，否则会不断重复下面的话造成死循环
    for (int i = start; i < n; i ++ )//从start开始枚举
    {
        if (st[i] || cur + a[i] > len) continue;//可行性剪枝，把不符合条件的去掉
        //搜索
        st[i] = true;
        if (dfs(u, cur + a[i], i + 1)) return true;//如果找到这根木棍满足的位置，下面不在执行
        st[i] = false;
        //如果这根木棒放在第一个或者最后一个都不满足，那么这个方案就一定不满足
        if (!cur || cur + a[i] == len) return false;
        //下面是如果这个木棒不满足条件，那么后面和他等长的一定都不满足
        int j = i;
        while (j < n && a[j] == a[i]) j ++ ;
        i = j - 1;
    }
    return false;
}
int main()
{
    while(cin>>n,n)
    {
        sum = 0;//sum记录的是所有木棍的总长度
        memset(st, 0, sizeof st);//要把使用状态清空
        for(int i = 0; i < n; i++)
        {
            cin>>a[i];
            sum+=a[i];
        }
        //下面是将木棍从大到小排序，是优化顺序剪枝
        sort(a, a + n);
        reverse(a, a + n);
        len = 1;
        //下面是枚举len，从小到大枚举，必须是sum的约数才可以，是可行性剪枝
        while(true)
        {
            if (sum % len == 0 && dfs(0, 0, 0))
            {
                cout << len << endl;
                break;
            }
            len ++ ;
        }
    }
    return 0;
}
~~~

### 8.双向bfs

~~~c++
#include<bits/stdc++.h>
using namespace std;
string sa, sb;
const int N = 6;
int n;
string a[N], b[N];
int extend(queue<string>&q, unordered_map<string, int>&da, unordered_map<string, int>&db, string a[], string b[])
{
    int d = da[q.front()];
    while(q.size() && da[q.front()] == d)
    {
        string t = q.front();
        q.pop();
        for(int i = 0; i < t.size(); i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(t.substr(i, a[j].size()) == a[j])
                {
                    string r = t.substr(0, i) + b[j] + t.substr(i + a[j].size());
                    if(db.count(r))return da[t] + db[r] + 1;
                    if(da.count(r))continue;
                    q.push(r);
                    da[r] = da[t] + 1;
                }
            }
        }
    }
    return 11;
}
int bfs()
{
    queue<string>q1,q2;
    unordered_map<string, int>da, db;
    q1.push(sa);
    q2.push(sb);
    da[sa] = 0, db[sb] = 0;
    if(sa == sb) return 0;
    while (q1.size() && q2.size())
    {
        int t;
        if(q1.size() < q2.size())t = extend(q1, da, db, a, b);
        else t = extend(q2, db, da, b, a);
        if (t <= 10)return t;
    }
    return 11;
}
int main()
{
    cin >> sa >> sb;
    while(cin >> a[n] >> b[n]) n++;
    int t = bfs();
    if (t > 10)puts("NO ANSWER!");
    else cout << t << endl;
    return 0;
}
~~~

### 9.双向dfs

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N = 50,  M = 1 << 25;
typedef long long LL;
int w[N];
LL weight[M];
int n, m, cnt, k;
LL ans;
void dfs1(int u, int s)
{
    if (u == k)
    {
        weight[cnt++] = s;
        return ; 
    }
    dfs1(u + 1, s);
    if ((LL)s + w[u] <= m) dfs1(u + 1, s + w[u]);
}
void dfs2(int u, int s)
{
    if(u == n)
    {
        int l = 0, r = cnt - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if(weight[mid] <= m - s)l=mid;
            else r = mid - 1;
        }
        ans = max(ans, (LL)s + weight[r]);
        return;
    }
    dfs2(u + 1, s);
    if((LL)s + w[u] <= m) dfs2(u + 1, s + w[u]);
}
int main()
{
    cin >> m >> n;
    for (int i = 0; i < n; i++)cin >> w[i];
    sort(w, w + n);
    reverse(w, w + n);
    k = n / 2 ;
    dfs1(0, 0);
    sort(weight, weight + cnt);
    cnt = unique(weight, weight + cnt) - weight;
    dfs2(k, 0);
    cout << ans << endl;
    return 0;
}

~~~

### 10.IDA*

~~~C++
#include <bits/stdc++.h>
using namespace std;
const int N = 17;
int q[N];
int w[5][N];
int n;
int f()
{
    int res = 0;
    for(int i = 0; i < n - 1; i ++)
    {
        if(q[i + 1] != q[i] + 1)res ++;
    }
    return (res + 2) / 3;
}
bool dfs(int d, int max_d)
{
    if(f() + d > max_d)return false;
    if(!f())return true;
    for (int len = 1; len <= n; len++)
    {
        for (int l = 0; l + len - 1 < n; l ++)
        {
            int r = l + len - 1;
            for (int k = r + 1; k < n; k ++)
            {
                memcpy(w[d], q, sizeof q);
                int y = l;
                for (int x = r + 1; x <= k; x++, y++)q[y] = w[d][x];
                for (int x = l; x <= r; x++, y++)q[y] = w[d][x];
                if(dfs(d + 1, max_d))return true;
                memcpy(q, w[d], sizeof q);
            }
        }
    }
    return false;
}
int main()
{
    int t;
    cin >> t;
    while (t --)
    {
        cin >> n;
        for(int i = 0; i < n; i++)cin >> q[i];
        int depth = 0;
        while(depth < 5 && !dfs(0, depth))depth++;
        if(depth >= 5)puts("5 or more");
        else cout << depth << endl;
    }
    return 0;
}
~~~

### 11.A*

~~~c++
#include<bits/stdc++.h>
using namespace std;
#define x first
#define y second
typedef pair<int, int> PII;
typedef pair<int, PII>PIII;
const int N = 1010, M = 200010;
int h[N], rh[N], e[M], ne[M], w[M], idx;
int n, m, S, T, K;
int d[N], cnt[N];
bool st[N];

void dijkstra()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, T});

    memset(d, 0x3f, sizeof d);
    d[T] = 0;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = rh[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (d[j] > d[ver] + w[i])
            {
                d[j] = d[ver] + w[i];
                heap.push({d[j], j});
            }
        }
    }
}
int bfs()
{
    priority_queue<PIII, vector<PIII>, greater<PIII>>heap;
    heap.push({d[S], {0, S}});
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
        int ver = t.y.y, distance = t.y.x;
        cnt[ver] ++ ;
        if (cnt[T] == K) return distance;
        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (cnt[j] < K)
                heap.push({distance + w[i] + d[j], {distance + w[i], j}});
        }
    }

    return -1;
}
void add(int h[N], int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);
    while (m --)
    {
        int a, b ,c;
        cin >> a >> b >> c;
        add(h, a, b, c);
        add(rh, b, a, c);
    }
    cin >> S >> T >> K;
    if(S == T)K++;
    dijkstra();
    cout << bfs() << endl;
    return 0;
}
~~~

### 12.强联通分量(tarjan缩点)

~~~c++
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            Size[scc_cnt] ++ ;
        } while (y != u);
    }
}
~~~



## 四.数论

### 1.线性筛质数

~~~c++
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if(!st[i])
        {
           primes[cnt ++] = i;
        }
        for (int j = 0; i * primes[j] <= n; j ++)
        {
            st[i * primes[j]] = true;
            if(i % primes[j] == 0)break;
        }
    }
    cout << cnt << endl;
}
~~~

### 2.欧拉函数

~~~c++
//欧拉函数是指1~n中与n互质的数字的个数
void get_euler(int a)
{
    LL res = a;
    for (int i = 2; i <= a / i; i ++)
    {
        if(a % i == 0)
        {
            res = (LL)res * (i - 1) / i;
            while(a % i == 0)a /= i;
        }
    }
    if(a > 1)res = (LL)res * (a - 1) / a;
    cout << res << endl;
}
~~~

### 3.快速幂与龟速乘

~~~c++
//快速幂求逆元的方法:若整数 b，m 互质，并且对于任意的整数 a，如果满足 b|a，则存在一个整数 x，使得 a / b ≡ a*x(mod m)，则称 x 为 b 的模 m 乘法逆元，记为 b−1(mod m)。b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，b^m−2 即为 b 的乘法逆元。
typedef long long LL;
LL qmi(int a, int b, int p)
{
    LL res = 1 % p;
    while(b)
    {
        if(b & 1)res = res * (LL)a % p;
        b >>= 1;
        a = (LL)a * a % p;
    }
    return res;
}

//龟速乘
LL padd(LL a, LL b, LL p)
{
    LL res = 0;
    while(b)
    {
        if(b & 1) res = (res + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return res;
}
~~~

### 4.扩展欧几里得算法(求解ax + by = gcd(a, b)、线性同余方程)

~~~c++
int exgcd(int a, int b, int& x, int& y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    int t = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return t;
}
~~~

### 5.组合计数(注意数学隔板法的应用)

~~~c++
//1.Lucas定理
LL a, b, p;
LL qmi(LL a, LL b, int p)
{
    LL res = 1;
    while(b)
    {
        if(b & 1) res = (res * a) % p;
        b >>= 1;
        a = a * a % p;
    }
    return res;
}
LL C(LL a, LL b)
{
    if(b > a)return 0;
    LL res = 1;
    for (LL i = a, j = 1; j <= b; j ++, i--)
    {
        res = res * i % p;
        res = res * qmi(j, p - 2, p) % p;
    }
    return res;
}
LL lucas(LL a, LL b)
{
    if(a < p && b < p)return C(a, b);
    return C(a % p, b % p) * lucas(a / p, b / p) % p;
}

//2.高精度求组合数
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 5010;
int primes[N], cnt;
int t[N];
bool st[N];
vector<int>res;
void get_primes(int n)  // 线性筛质数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
int get(int a, int p)
{
    int res = 0;
    for (int i = a; i >= 1; i /= p)res += i / p;
    return res;
}
vector<int> mul(vector<int>a, int b)
{
    vector<int>c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++)
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}
int main()
{
    int a, b;
    cin >> a >> b;
    get_primes(a);
    for (int i = 0; i < cnt; i ++)
    {
        int p = primes[i];
        t[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    res.push_back(1);
    for (int i = 0; i < cnt; i++)
    {
        for (int j = 0; j < t[primes[i]]; j ++)
        {
            res = mul(res, primes[i]);
        }
    }
    for (int i = res.size(); i; i--)cout << res[i];
  	cout << endl;
    return 0;
}

//3.卡特兰数：01序列中所有位置0的个数不能小于1的个数：C[n * 2][n] - C[n * 2][n - 1]
~~~

### 6.矩阵乘法

~~~c++
void mul(int c[], int a[], int b[][N])
{
    int temp[N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m;
    memcpy(c, temp, sizeof temp);
}
void mul(int c[][N], int a[][N], int b[][N])
{
    int temp[N][N] = {0};
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            for (int k = 0; k < N; k ++ )
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m;
    memcpy(c, temp, sizeof temp);
}
~~~

## 五.动态规划

### 1.二进制优化多重背包

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N = 20010, M = 2010;
int v[N], w[N], cnt;
int f[M];
int main()
{
    int n, m;
    cin >> n >> m;
    int a, b, s;
    for (int i = 1; i <= n; i ++)
    {
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            v[++ cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if(s)v[++ cnt] = s * a, w[cnt] = s * b;
    }
    for(int i = 1; i <= cnt; i ++)
    {
        for(int j = m; j >= v[i]; j --)
        {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[m] << endl;
    return 0;
}
~~~

### 2.单调队列优化多重背包	

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 20010;
int f[N], g[N], q[N];
int main()
{
    int n, m;
    cin >> n >> m;
    int v, w, s;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        for (int r = 0; r < v; r ++ )
        {
            int hh = 0, tt = -1;
            for (int j = r; j <= m ; j += v)
            {
                while (hh <= tt && j - q[hh] > s * v)hh ++;
                while (hh <= tt && g[q[tt]] - (q[tt] - r) / v * w <= g[j] - (j - r) / v * w)tt--;
                q[++tt] = j;
                f[j] = g[q[hh]] + (j - q[hh]) / v * w;
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
~~~

### 3.有依赖背包问题

~~~c++
//1.树形依赖
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 110;
int f[N][N];
int n, m;
int e[N], ne[N], h[N], idx;
int v[N], w[N];
void add(int a, int b)  // 添加一条边a->b
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int son = e[i];
        dfs (son);
        for(int j = m - v[u]; j >= 0; j -- )
            for (int k = 0; k <= j; k ++ )
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }
    for (int i = m; i >= v[u]; i--)f[u][i] = f[u][i - v[u]] + w[u];
    for (int i = 0; i < v[u]; i ++)f[u][i] = 0;
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    int root = 0;
    for (int i = 1; i <= n; i++)
    {
        int p;
        cin >> v[i] >> w[i] >> p;
        if(p == -1)root = i;
        else add(p, i);
    }
    dfs(root);
    cout << f[root][m] << endl;
    return 0;
}

//2.当附件个数较少的时候利用状态压缩
#include<bits/stdc++.h>
using namespace std;
const int N = 32010, M = 62;
int f[N];
typedef pair<int,int>PII;
PII master[M];
vector<PII>severent[M];
int main()
{
    int m,n;
    cin>>m>>n;
    for(int i=1;i<=n;i++)
    {
        int v,w,p;
        cin>>v>>w>>p;
        if(!p)master[i]={v,v*w};//如果p为0，说明是主件
        else//否则为附件
            severent[p].push_back({v,v*w});
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=0;j--)
        {
            for(int u=0;u<1<<severent[i].size();u++)
            {
                int v=master[i].first,w=master[i].second;
                for(int t=0;t<severent[i].size();t++)
                {
                    if(u>>t&1)
                    {
                        v+=severent[i][t].first;
                        w+=severent[i][t].second;
                    }
                }
                if(j>=v)f[j]=max(f[j],f[j-v]+w);
            }
        }
    }
    cout<<f[m]<<endl;
    return 0;
}
~~~

### 4.状压dp——格子问题

~~~c++
//玉米田问题
#include<iostream>
using namespace std;
#include<vector>
const int N = 13, M = 1 << N,mod=1e8;
typedef long long LL;
int a[N][N];
LL f[N][M];
vector<int>state[N];
int main()
{
	int m, n;
	cin >> m >> n;
	for (int i = 0; i < m; i++)
		for (int j = 0; j < n; j++)
			cin >> a[i][j];
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < 1 << m; j++)
		{
			int cnt = 0;
			bool is_valid = true;
			for (int k = 0; k < m; k++)
			{
				if ((j >> k) & 1)
				{//如果在这一片土地种植，那么要判断土地是否肥沃
					if (a[k][i])//如果肥沃
					{
						cnt++;//看看有没有可能两片土地相邻
						if (!(cnt % 2))is_valid = false;
					}
					else is_valid = false;//在不育的土地种植一定错误
				}
				else cnt = 0;//这片土地不种植
			}
			if (is_valid)state[i].push_back(j);//将这一列状态符合的存入到这一列对应的数组中
		}
	}
	state[n].push_back(0);
	for (auto k : state[0])
	{
		f[0][k] = 1;
	}
	for (int i = 1; i <= n; i++)
	{
		for (auto k : state[i])
		{
			for (auto j : state[i - 1])
			{
				if((k&j)==0)//相邻的两列必须保证没有相邻的玉米
					f[i][k] += f[i - 1][j];
			}
		}
	}
	cout << f[n][0]%mod << endl;
	return 0;
}
~~~

### 5.状压dp——遍历点问题

~~~c++
//汉密尔顿最短路问题
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 21;
int a[N][N];
int f[1 << N][N];
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> a[i][j];
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    for (int i = 0; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ )
            if(i >> j & 1)
                for (int k = 0; k < n; k ++ )
                    if(i >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + a[k][j]);
    cout << f[(1 << n) - 1][n - 1] << endl;
    return 0;
}
~~~

### 6.区间dp（注意数据范围）

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 310;
int a[N], f[N][N], s[N];
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    memset(f, 0x3f, sizeof f);
    for (int i = 1; i <= n; i ++ )f[i][i] = 0;
    for (int len = 2; len <= n; len ++)
        for (int i = 1; i + len - 1 <= n; i ++)
        {
            int l = i, r = i + len - 1;
            for (int k = l; k < r; k ++)
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
        }
    int res = 0x3f3f3f3f;
    for (int i = 1; i <= n; i ++)res = min(res, f[i][i + n - 1]);
    cout << res << endl;
    return 0;
}
~~~

### 7.数位统计dp——记忆化搜索实现

~~~c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 10;
int t[N], tmp;
int dp[N][N];
int dfs(int pos, int sum, int num, int lead, int limit)
{
    if(!pos)
    {
        if(!num && lead)return 1;
        else return sum;
    }
    if(!limit && !lead && dp[pos][sum] != -1)return dp[pos][sum];
    int up = limit ? t[pos] : 9;
    int res = 0;
    for (int i = 0; i <= up; i ++ )
    {
        int t;
        if(i == num)
        {
            if(!num)t = sum + (lead == 0);
            else t = sum + 1;
        }
        else t = sum;
        res += dfs(pos - 1, t, num, lead && i == 0, limit && i == up);
    }
    return limit ? res :(lead ? res : dp[pos][sum] = res);
}
int cal(int x, int i)
{
    tmp = 0;
    memset(dp, -1, sizeof dp);
    while(x) t[++tmp] = x % 10, x /= 10;
    return dfs(tmp, 0, i, 1, 1);
}
int main()
{
    int a, b;
    while(cin >> a >> b, a || b)
    {
        if(a > b)swap(a, b);
        for (int i = 0; i <= 9; i ++)
            cout << cal(b, i) - cal(a - 1, i) << " ";
        cout << endl;
    }
    return 0;
}
~~~

### 8.斜率优化dp

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
typedef long long LL;
LL f[N];
LL t[N],c[N];
int q[N];
int main()
{
    int n,s;
    cin>>n>>s;
    for(int i=1;i<=n;i++)
    {
        cin>>t[i]>>c[i];
        t[i]+=t[i-1];
        c[i]+=c[i-1];
    }
    int hh=0,tt=0;
    for(int i=1;i<=n;i++)
    {
        int l=hh,r=tt;
        while(l<r)
        {
            int mid=l+r>>1;
            if(f[q[mid+1]]-f[q[mid]]>(s+t[i])*(c[q[mid+1]]-c[q[mid]]))r=mid;
            else l=mid+1;
        }
        int j=q[r];
        f[i]=f[j]+(c[i]-c[j])*t[i]+(c[n]-c[j])*s;
        while(hh<tt&&(double)(f[i]-f[q[tt-1]])*(c[q[tt]]-c[q[tt-1]])<=(double)(f[q[tt]]-f[q[tt-1]])*(c[i]-c[q[tt-1]]))tt--;
        q[++tt]=i;
    }
    cout<<f[n]<<endl;
    return 0;
}
~~~

## 六.常用技巧

### 1.快读

~~~c++
inline int read()
{
    char c = getchar();
    int f = 1; int ans = 0;
    while (c > '9' || c < '0')
    {
        if (c == '-')f = -f; c = getchar();
    }
    while (c <= '9' && c >= '0')
    {
        ans = ans * 10 + c - '0'; c = getchar();
    }
    return ans * f;
}
~~~



