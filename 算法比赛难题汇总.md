# 算法比赛补题汇总

## 一、基础算法

### 1.根号分治优化

**题目链接：** https://codeforces.com/contest/1806/problem/E

**题目描述：** 由 $n$ 个点构成的树中，每个点有一个权值，下面有 $m$ 组询问，每组询问给出两个点的编号，这两个点保证在同一层，每一次要输出 $ans$，计算方法是 $ans += a[x] * a[y], x = p[x], y = p[y], 当x!= 0,y != 0$ 。

**思路分析：** 我们可以知道对于这样一棵树，我们可以利用记忆化的方式进行暴力求和，即对于每个点对如果它被经过一次那么我们就可以计算从他们到根节点的值就可以用map记录下来，之后直接用即可，但是这样会超时，我们需要利用到根号分治，考虑对于一层中结点个数少于 $sqrt(n)$ 的我们可以利用上述map方法记录，那么对这一层来说最多有 $n$ 个数对，然后总的方案数就最多是 $nsqrt(n)$ 个，接着如果这一层结点数量大于 $sqrt(n)$，那么我们就可以直接暴力求解即可，因为这一层到他们的LCA距离一定是小于 $sqrt(n)$ 的。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
const int N = 2e5 + 10, M = 500;
int n, m, a[N];
int p[N];
LL f[N][M + 10];
vector<int>g[N];
int d[N], s[N], id[N];
void dfs(int u, int fa) 
{
    d[u] = d[fa] + 1;
    id[u] = ++ s[d[u]];
    for (int v : g[u])dfs(v, u);
}
LL dp(int x, int y) 	
{
    if (x == 0)return 0;
    if (s[d[x]] < M && f[x][id[y]]) return f[x][id[y]];
    LL res = 1ll * a[x] * a[y] + dp(p[x], p[y]);
    if (s[d[x]] < M) f[x][id[y]] = res;
    return res;
}
void solve() 
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)cin >> a[i];
    for (int i = 2; i <= n; i ++){
    	cin >> p[i];
    	g[p[i]].push_back(i);
	}
    dfs(1, 0);
    while(m --){
    	int x, y;
    	cin >> x >> y;
    	if(x > y)swap(x, y);
    	cout << dp(x, y) << "\n";
	} 
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(T --)solve();
	
	return 0;
}
```

### 2.模拟

**题目链接：** https://codeforces.com/contest/1811/problem/D

**题目描述：** 给一个数字 $n$， 求长为 $F[n + 1]$，宽为$F[n]$ 的一个矩形是否可以按照下面的方法分割为多个正方形。（注意 $F$ 为斐波那契数列），给定 $x$ 和 $y$，表示涂色格子的下标。

1.有一个 $1 \times 1$ 的小方格被涂色，要求它必须单独分割出来。

2.最多只有一对正方形的边长相同，且所有正方形边长必须是斐波那契数列中一项。

**思路分析：** 按照斐波那契数列的构造方法构造正方形即可，难点在于代码书写上面，基本的思路就是每次把最大的一个正方形放到长方形的宽上，放在左边右边都可以，然后更新长方形的边形成。如果这个过程中涂色的格子一定会被覆盖那么无法分割。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
LL f[50];
void init(){
	f[0] = f[1] = 1;
	for (int i = 2; i <= 45; i ++){
		f[i] = f[i - 1] + f[i - 2];
	}
}
void solve(){
	LL x, y;cin >> n >> x >> y; 
	LL l = 1, r = f[n + 1];
    LL u = 1, d = f[n];
    bool flag = 1;
    for(int i = n; i >= 2; i--){
        if (r - l + 1 > d - u + 1){
            if (y > l + f[i] - 1){
                l += f[i];
            }
            else if (y < r - f[i] + 1){
                r -= f[i];
            }
            else{
                flag = 0;
                break;
            }
        }
        else{
            if (x > u + f[i] - 1){
                u += f[i];
            }
            else if (x < d - f[i] + 1){
                d -= f[i];
            }
            else{
                flag = 0;
                break;
            }
        }
    }
    cout << (flag ? "YES" : "NO") << '\n';
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	init();
	
	int T = 1;
	cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 3.逆向思维+区间问题

**题目链接：** https://ac.nowcoder.com/acm/contest/23106/G

**题目描述：** 给一个长度为 $n$ 的数组，找到一个值 $b$，使得这个数组中的所有元素偏离 $b$ 的值组成的新数组，极小值点最小，极小值点定义为 对于 $2 <= i <= n- 1$, 有 $b[i] < min(b[i- 1], b[i+1])$。

**思路分析：** 本题正向思考的思路就是找到 $b$ 使得极值点个数最小，但是最小较难处理，因为让它不是极值点有些困难，我们采用逆向思考，我们找到每个点，如果想要变成极小值点，那我们需要的 $b$ 的范围是多少，通过这个思路我们用一个差分思想，记录每个 $b$ 被覆盖的次数，求最小次数即可。注意$map$也为有序容器。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1010;
int n, m;
int a[N];
void solve(){
	cin >> n;
	for (int i = 1; i <= n; i ++){
		cin >> a[i];
	}
	int mi = 0, mx = 2e9;
	map<int, int>mp;
	mp[mi] = mp[mx] = 0;
	for (int i = 2; i < n; i ++){
		int l = 0, r = mx;
		int x = min(a[i - 1], a[i + 1]);
		if (a[i] < x){
        	r = min(r, (a[i] + x - 1) / 2);
        } 
		else if (a[i] > x){
            l = max(l, (a[i] + x + 2) / 2);
        } 
		else{
            r = l - 1;
        }
        
        if(l <= r){
        	mp[l] ++, mp[r + 1]--;
		}
	}
	int ans = n, cur = 0;
    for (auto [x, y] : mp) {
        cur += y;
        if (x <= 2e9)ans = min(ans, cur);
    }
    cout << ans << "\n";
} 
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 4.启发式合并

**题目链接：** https://codeforces.com/contest/1810/problem/E

**题目描述：** 给一棵$n$个结点的树，每个结点上有一个权值，表示必须到达$a[i]$个结点后才能够进入这个结点，求是否可以从某个点开始遍历整棵树。

**思路分析：** 使用启发式合并算法，首先我们证明每个结点最多被遍历$log(n)$次。

证明：设$S[i]$表示从$i$出发能到达的所有结点，设$E[S[i]]$表示$S[i]$这个集合中的点与不在集合中的点之间有一条边，即$v$ 属于$E(S)$,仅当$v$不属于$S$,开始的时候，有$u ∈ S(u)$,那我们找到$E(u)$中最小的一个权值对应的点，如果$a[v]<=|S(u)|$,那么我们把$v$加入到集合中去，并且更新$E(S(u))$,我们目标是使得某一个$u$的$|S(u)| == n$.

下面给出一个定理：如果$v∈ S(u)$，那么一定有$S(v)<S(u)$，这个比较好理解，因为如果$v$被加入到$u$所在的集合中，那么一定有$v$能到达的点$u$都可到达。

所以我们只要搜索所有没有被加入到集合中，且值为0的点。因为如果一个点已经属于某个集合，那么一定有上面的式子成立，那么也一定会有$|S(v)| < n$。

下面我们证明时间复杂度为$O(nlogn)$

假设我们已经搜完了$u$，且$v∈S(u)$，那么当我们从$u'$开始搜索的时候，就会有$|S(u')|>2|S(u)|$。那么一个点最多不会被访问超过$log(n)$次，因为它所属的集合每次都将扩大2倍。

下面证明$|S(u')|>2|S(u)|$：首先由于$u'$不属于$S(u)$，那么就一定有如果$u'$能够到达$S(u)$中某个点，它一定能到达其中的所有点，因为在访问$v$之前，一定有$|S(u')|>|S(u)|$，否则他们之间的某个桥梁无法通过，那么他们也无法到达，访问完$S(u)$后，所有点被加入到了$u'$，所以就有$|S(u')|>2|S(u)|$。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int mod2 = 500000004, MOD2 = 499122177;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
int a[N], st[N];
vector<int>g[N];
bool bfs(int u){
	set<PII>s;
	s.insert({a[u], u});
	int sum = 0, mx = 0;
	while(s.size()){
		auto t = (*s.begin());
		st[t.y] = u;
		if(t.x > mx)return sum == n;
		s.erase(s.begin());
		sum ++; mx ++;
		for(auto v : g[t.y]){
			if(st[v] < u)s.insert({a[v], v});
		}
	}
	return sum == n;
} 
void solve(){
	cin >> n >> m;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		st[i] = 0;
		g[i].clear();
	}
	for(int i = 1; i <= m; i ++){
		int u, v;cin >> u >> v;
		g[u].push_back(v);g[v].push_back(u);
	}
	for(int i = 1; i <= n; i ++){
		if(!a[i] && !st[i]){
			if(bfs(i)){
				cout << "YES" << "\n";
				return;
			}
		}
	}
	cout << "NO" << "\n";
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 5.类根号分治

**题目链接：** https://codeforces.com/contest/1822/problem/G2

**题目描述：** 给一个长度为$n$的数组，数组中所有元素$a[i]<=10^9$，找到一个三元组$(i, j, k)$，使得存在一个正整数$b$，使得$a[i] * b = a[j], a[j] * b = a[k]$，求这样的三元组的数量。其中$n<=2\times10^5$

**思路分析：** 我们用$map$存储每个元素的出现次数，然后枚举，如果某个元素$val>=10^6$，那么就有$b<=10^3$，那么我们直击枚举$b$即可，如果$val<=1e6$，那么我们可以利用$sqrt(n)$的复杂度枚举它的所有因子，因为$b$一定也是它的因子，根据这两个暴力算法，可以将时间复杂度优化为$O(n\times k^\frac{1}{3})$，其中$k=10^6$。

**技巧提醒：** 注意使用$map$的时候，先判断$ma.count(x)$，可以降低时间复杂度。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int mod2 = 500000004, MOD2 = 499122177;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
const int K = 1e6, M = 1e9;
void solve(){
    cin >> n;
    vector<int>a(n + 1);
    map<int, int>ma;
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
        ma[a[i]] ++;
    }
    LL ans = 0;
    for (int i = 1; i <= n; i ++) {
        ans += 1ll * (ma[a[i]] - 1) * (ma[a[i]] - 2);
    }
    auto check = [&](int x, int y){
        if(ma.count(x) && ma.count(x * y) && ma.count(x / y))return true;
        return false;
    };
    for (auto el : ma) {
        int num = el.x;
        if (num > K) {
            for (int b = 2; b * num <= M; b ++) {
                if (num % b == 0 && check(num, b)) {
                    ans += 1ll * ma[num / b]* ma[num * b] * ma[num];
                }
            }
        } 
        else {
            for (int b = 2; b * b <= num; b ++) {
                if (num % b == 0) {
                    if (1ll * num * b <= M && check(num, b)) {
                        ans += 1ll * ma[num / b] * ma[num * b] * ma[num];
                    }
                    if (b * b != num) {
                        if (1ll * num * num / b <= M && check(num, num / b)) {
                            ans += 1ll * ma[b] * ma[num / b * num] * ma[num];
                        }
                    }
                }
            }
            if (num > 1 && 1ll * num * num <= M && check(num, num)) {
                ans += 1ll * ma[1] * ma[num * num] * ma[num];
            }
        }
    }
    cout << ans << "\n"; 
}
int main(){
   ios::sync_with_stdio(false);
   cin.tie(0), cout.tie(0);
   cout << fixed << setprecision(10);
   //init();
   
   int T = 1;
   cin >> T;
   while(T --) solve();
   
   return 0;
}
```

### 6.位运算的独立性

**题目链接：** https://codeforces.com/contest/1614/problem/C

**题目描述：** 给定一个数组，求这个数组所有的子序列的异或值之和。

**思路分析：** 对于位运算每一位都具有独立性，所以我们可以分别看每一位(不用担心选择某几位对于其他的影响，我们目前只要考虑这一位即可)。所以我们把所有数字按位或起来，然后如果这个数据的某一位为1，那么答案就要加上$2^{i}*2^{n-1}$，即这一位的位权*这个数组的长度的一半。

证明：假设有这一位有$x$个数字为1，那么就有$n-x$个为0，所以这一位的有贡献的情况下的总方案数就是选择奇数个1，然后任意选$y$个0即可。

```c++
void solve(){
    cin >> n >> m;
    int sum = 0;
    while(m --){
        int l, r, x;
        cin >> l >> r >> x;
        sum |= x;
    }
    LL ans = 0;
    for (int i = 0; i < 31; i ++){
        if(sum >> i & 1){
            ans = (ans + 1ll * qmi(2, n - 1, mod) * qmi(2, i, mod) % mod) % mod;
        }
    }
    cout << ans << "\n";
}
```

### 7.反悔型贪心

**题目链接：** https://codeforces.com/contest/1837/problem/F

**题目描述：** 有$n$个作业，每个作业都有一个完成需要的时间$a[i]$，有两个人选择其中$k$个作业做，但必须按照顺序，即按照顺序选出$k$个作业，一个人从第一个开始做，另一个人从最后一个开始做，必须按顺序做，求最少多长时间可以完成这些作业。

**思路分析：** 首先最小时间可以用二分，即二分需要多少时间，不过选择哪$k$个作业需要思考，我们可以利用反悔型贪心的思路，按照顺序所有的作业都选择，利用大根堆维护时间，之后如果当前的时限大于二分的值，那么就把堆顶的元素删除，然后记录一下此时的最大作业数量，然后从前往后预处理一遍，然后从后往前再做同样的操作，如果最后能够完成的作业个数大于等于$k$，即满足题意。

```c++
void solve(){
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1);
    LL sum = 0;
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
        sum += a[i];
    }
    auto check = [&](LL mid){
        LL sum = 0;
        priority_queue<int> q;
        vector<int> cnt(n + 1);
        for(int i = 1; i <= n; i ++){
            q.push(a[i]);
            sum += a[i];
            while(sum > mid){
                sum -= q.top();
                q.pop();
            }
            cnt[i] = q.size();
        }
        sum = 0;
        priority_queue<int> p;
        for(int i = n; i >= 1; i--){
            p.push(a[i]);
            sum += a[i];
            while(sum > mid){
                sum -= p.top();
                p.pop();
            }
            if (p.size() + cnt[i - 1] >= k) return true;
        }
        return false;
    };
    LL l = 0, r = sum;
    while(l < r){
        LL mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << r << '\n';
}
```

### 8.锦标赛类型题

**题目链接：** https://codeforces.com/contest/1837/problem/E

**题目描述：** 有$k$轮比赛，$2^k$个人参加，编号小的一定能击败编号大的，求分组的方案数(有一些位置已经固定)，使得每个人的名次和他的编号相同，即第一名是第一个人，第二名是第二个人，第三名是第三、四个人……

**思路分析：** 锦标赛类型的题目在每一轮实际构成了一个完全二叉树，因此我们可以通过递归来解决，我们需要记录的数据主要有第$k$轮有$x$个位置是没有被占用的，那么这一轮就有$x!$中不同的排列方法，其次我们还需要知道这一组中有几个空位，如果空位个数为2的话，还需要方案数**\*2** ,最后我们还需要判断是否合法。

**代码分析：** 首先因为按照名次排列，所以一定有$[2^{k-1},2^k)$这个区间的人是在不同的分组，所以我们每次先用$[ls, rs)$表示这些人不能在这一轮的同一个分组中，所以$cnt$就是记录同一个分组中这个区间内的数字出现的次数，$remain$就是目前是-1的还没有被分配的数量，这里面只有在第一轮可能分配会用到。

```c++
void solve(){
    int k;cin >> k;
    int n = 1 << k;
    vector<int>a(n);
    for (int i = 0; i < n; i ++){
        cin >> a[i];
        if(a[i] != -1)a[i] --;
    }

    vector<Z>fac(n + 1);
    fac[0] = 1;
    for (int i = 1; i <= n ;i ++)fac[i] = fac[i - 1] * i;
    
    Z res = 1;
    vector<int>sum(k + 1);
    
    auto dfs = [&](auto& self, int l, int r, int t) -> int{
        if(t == 0)return a[l] == -1;
        int x = k - t;
        int ls = 1 << x, rs = 1 << (x + 1);
        int mid = l + r >> 1;
        int remain = self(self, l, mid, t - 1) + self(self, mid, r, t - 1);

        int cnt = 0;
        for (int i = l; i < r; i ++){
            if(a[i] >= ls && a[i] < rs){
                cnt ++;
            }
        }

        if(cnt > 1)res = 0;
        else if(cnt == 0){
            if(remain == 0)res = 0;
            else{
                if(remain == 2)res *= 2;
                sum[t] ++;
                remain --;
            }
        }
        return remain;
    };

    dfs(dfs, 0, n, k);
    for (int i = 0; i <= k; i ++)res *= fac[sum[i]];
    cout << res << "\n";
}
```

### 9.位运算乘法

**题目链接：** https://ac.nowcoder.com/acm/contest/57359/I

**题目描述：** 给一个数组，求$\sum_{1 \leq l_1\leq r_1<l_2 \leq r_2 < l_3 \leq r_3 \leq n}XOR(l_1, r_1) \times XOR(l_2, r_2) \times XOR(l_3, r_3)$。

**思路分析： ** ![1691113126645](C:/images/1691113126645-1691113129987.png)

```c++
void solve(){
    int n; 
    cin >> n;
    vector<int>a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    vector<int>s(n + 1);
    for (int i = 1; i <= n; i++) {
        s[i] = s[i - 1] ^ a[i];
    }
    vector<Z>f(n + 1, 1);
    for (int t = 0; t < 3; t++) {
        vector<Z>g(n + 1);
        vector<Z>v(2);
        for (int j = 0; j < 30; j++) {
            v = { f[0],0 };
            for (int i = 1; i <= n; i++) {
                int p = s[i] >> j & 1;
                g[i] += v[p ^ 1] * (1 << j);
                v[p] += f[i];
            }
        }
        for (int i = 1; i <= n; i++)g[i] += g[i - 1];
        for (int i = 0; i <= n; i++)f[i] = g[i];
    }
    cout << f[n] << "\n";
}
```

### 10.二阶差分

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7340

**题目描述：** 给一个$n \times m$方格，每个格子$(i, j)$的收益为覆盖这个格子的全部正方形的边长之和乘这个格子的价值，求所有格子的收益之和。

**思路分析：** 首先是处理以这个格子为右下角的格子能够构成的最大边长，这里是一个经典的$dp$问题，$f[i][j] = min(f[i - 1][j], f[i - 1][j-1], f[i - 1][j-1])+1$。那么本次这个格子就会被覆盖$\sum_{i=1}^{f[i][j]}i$次，那么我们考虑如何维护这些信息，考虑差分。下面是原矩阵

![1691374991394](C:/images/1691374991394-1691374993498.png)

下面是一阶差分

![1691375022993](C:/images/1691375022993-1691375027328.png)

下面是二阶差分

![1691375054562](C:/images/1691375054562-1691375056679.png)

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> p[i][j];
        }
    }
    for (int i = 0; i <= n + 2; i++) {
        for(int j = 0; j <= m + 2; j++) {
            f[i][j] = 0;
            d1[i][j] = d2[i][j] = d3[i][j] = d4[i][j] = s[i][j] = Z(0);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if(a[i][j]) {
                f[i][j] = min({f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]}) + 1;
                int len = f[i][j];
                d1[i - len + 1][j - len + 1] += len;
                d1[i - len + 2][j - len + 2] -= len + 1;
                d1[i + 2][j + 2] += 1;
                d2[i - len + 1][j + 1] -= len;
                d2[i - len + 2][j + 1] += len + 1;
                d2[i + 2][j + 1] -= 1;
                d3[i + 1][j - len + 1] -= len;
                d3[i + 1][j - len + 2] += len + 1;
                d3[i + 1][j + 2] -= 1;
                d4[i + 1][j + 1] += (len + 1) * len / 2;
            }
        }
    }
    for (int _ = 1; _ <= 2; _++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                d1[i][j] += d1[i - 1][j - 1];
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                d2[i][j] += d2[i - 1][j];
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                d3[i][j] += d3[i][j - 1];
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            Z now = d1[i][j] + d2[i][j] + d3[i][j] + d4[i][j];
            s[i][j] = s[i][j - 1] + s[i - 1][j]- s[i - 1][j - 1] + now;
        }
    }
    Z res = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            res += s[i][j] * p[i][j];
        }
    }
    cout << res << "\n";
}
```

### 11.根号分治+容斥原理

**题目链接：** https://ac.nowcoder.com/acm/contest/57361/I

**题目描述：** 给$n \leq 400$个字符串，他们的长度之和小于400，其中每个字符串是由0,1，？构成的，将问号替换成0或者1，求一共可以构成多少种不同的字符串。

**思路分析：** 考虑当字符串长度小于20的时候可以直接暴力$dfs$，因此我们想到根号分治，如果字符串长度大于20，那么这样的字符串个数是不会超过20个的，因此我们考虑根据数量维护，考虑容斥原理即可。

```c++
void solve(){
    int n;
    cin >> n;
    vector<string>a, b;
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        if(s.size() <= 20)b.push_back(s);
        else a.push_back(s);
    }
    set<string>st;
    Z ans = 0;
    auto dfs = [&](auto &self, int p, string s, string t) -> void {
        assert(p <= (int)s.size());
        if(p == (int)s.size()) {
            st.insert(t);
            return;
        }
        if(s[p] == '?') {
            self(self, p + 1, s, t + '0');
            self(self, p + 1, s, t + '1');
        } else {
            self(self, p + 1, s, t + s[p]);
        }
    } ;
    for (int i = 0; i < b.size(); i++) {
        string t = "";
        dfs(dfs, 0, b[i], t);
    }
    ans += st.size();
    n = a.size();
    for (int i = 1; i < (1 << n); i++) {
        vector<string>v;
        set<int>st;
        int x = 0;
        for (int j = 0; j < n; j++) {
            if(i >> j & 1) {
                v.push_back(a[j]);
                st.insert(a[j].size());
                x++;
            }
        }
        if(st.size() > 1)continue;
        bool flag = true;
        Z num = 1;
        for (int k = 0; k < v[0].size(); k++) {
            int one = 0, zero = 0;
            for (int j = 0; j < v.size(); j++) {
                if(v[j][k] == '1') {
                    one++;
                } else if(v[j][k] == '0') {
                    zero++;
                }
            }
            if(one && zero)flag = false;
            else if(!one && !zero) {
                num *= 2;
            }
        }
        if(!flag)num = 0;
        ans += (x % 2 ? 1 : -1) * num;
        v.clear();
    }
    cout << ans << "\n";
}
```

### 12.随机化算法

**题目链接：** https://codeforces.com/contest/1773/problem/A

**题目描述：** 给一个排列 $a$，要求构造一个排列 $p$，使得$p[i] \neq i$ 并且 $p[i] \neq a[i]$。

**思路分析：** 每个位置最多只有两个元素是不能被选择的，所以冲突的概率非常小，可以使用随机化。

```c++
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1), pos(n + 1);
    for(int i = 1; i <= n; i++) {
		cin >> a[i];
        pos[a[i]] = i;
    }
    vector<int>p(n + 1), q(n +1 );
    mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());
    for (int i = 1; i <= n; i++) q[i] = i;
    int x = 100;
    while(x--) {
        bool flag = true;
        shuffle(q.begin() + 1, q.end(), rng);
        for (int i = 1; i <= n; i++) {
            if(q[i] == i || q[i] == pos[i]) {
                flag = false;
                break;
            }
        }
        if(flag){
            for (int i = 1; i <= n; i++) {
                p[q[i]] = pos[i];
            }
            cout << "Possible" << "\n";
            for(int i = 1; i <= n; i++)cout << p[i] <<" \n"[i == n];
            for(int i = 1; i <= n; i++)cout << q[i] <<" \n"[i == n];
            return;
        }
    }
    cout<<"Impossible\n";
}
```

### 13.逆序对性质

**题目链接：** https://atcoder.jp/contests/abc296/tasks/abc296_f

**题目描述：** 给两个数组，所有元素都是在 $1 - n$ 这个范围内，可以执行下面的操作无数次，求是否能把两个数组变成完全相等。

**思路分析：** 首先两个数组一起变化会比较复杂，我们考虑固定一个数组，让另一个数组变化，我们发现实际上就等价于 $b_i, b_j, b_k$ 变成 $b_k, b_i, b_j$。我们进一步思考发现每一次变化并不会改变这个数组的奇偶性，所以如果是两个排列的话必须要保证奇偶性相同，那么就可以完成全部的变化。如果有重复元素，那么一定是可以的，因为我们可以把重复元素当做两个下标，不断的和别的位置变化，能够覆盖所有位置。

```c++
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1), b(n + 1);
    int ra = 0, rb = 0;
    BIT bit1(n + 1), bit2(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        ra += bit1.query(a[i]);
        bit1.modify(a[i], 1);
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
        rb += bit2.query(b[i]);
        bit2.modify(b[i], 1);
    }
    sort(a.begin() + 1, a.end());
    sort(b.begin() + 1, b.end());
    for (int i = 1; i <= n; i++) {
        if(a[i] != b[i]) {
            cout << "No" << "\n";
            return;
        }
    }
    for (int i = 1; i <= n ;i++) {
        if(a[i] == a[i - 1]) {
            cout << "Yes" << "\n";
            return;
        }
    }
    cout << (ra % 2 == rb % 2 ? "Yes" : "No") << "\n";
}
```

### 14.值域型置换环

**题目链接：** https://atcoder.jp/contests/abc302/tasks/abc302_g

**题目描述：** 给一个长度为 $n$ 的数组，每个元素是1,2,3,4中的一个，每次可以选择两个下标把对应的元素交换，求把数组操作成有序需要的最少操作次数。

**思路分析：** 由于一个数字可以存在多个位置合法，所以我们需要从值域上考虑置换环，环的大小本题只有2 3 4三种，所以我们可以直接暴力，因为根据置换环的知识，对于一个含有 $n$ 个元素的置换环，最少需要 $n - 1$ 次操作能断开环，所以我们从环长为2开始，依次遍历3 4的情况。

```c++
void solve(){
    int n; 
    cin >> n; 
    vector<int> a(n + 1), b;
	for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
	b = a;
	sort(b.begin() + 1, b.end());
	vector<vector<int>> cir(5, vector<int>(5));
	int ans = 0;
	for(int i = 1; i <= n; i++) {
		cir[a[i]][b[i]]++;
    }
	for(int i = 1; i <= 4; i++) {
		for(int j = 1; j <= 4; j++) {
			if(cir[i][j] && cir[j][i] && i != j) {
				int t = min(cir[i][j], cir[j][i]);
				ans += t;
				cir[i][j] -= t; cir[j][i] -= t;
			}
		}
	}
	for(int i = 1; i <= 4; i++) {
		for(int j = 1; j <= 4; j++) {
			for(int z = 1; z <= 4; z ++) {
				if(i == j || j == z || z == i)continue;
				if(cir[i][j] && cir[j][z] && cir[z][i]) {
					int t = min({cir[i][j], cir[j][z], cir[z][i]});
					ans += 2 * t;
					cir[i][j] -= t; cir[j][z] -= t; cir[z][i] -= t;
				}
			}
		}
	}
	for(int i = 1; i <= 4; i++) {
		for(int j = 1; j <= 4; j++) {
			for(int z = 1; z <= 4; z ++) {
				for(int k = 1; k <= 4; k++) {
					if(i == j || j == z || z == k || k == i)continue;
					if(cir[i][j] && cir[j][z] && cir[z][k] && cir[k][i]) {
						int t = min({cir[i][j], cir[j][z], cir[z][k], cir[k][i]});
						ans += 3 * t;
					cir[i][j] -= t; cir[j][z] -= t; cir[z][k] -= t; cir[k][i] -= t;
					}
				}
			}
		}
	}
	cout << ans << "\n";
}
```





## 二、数据结构

### 1.set的使用

**题目链接：** https://codeforces.com/contest/1802/problem/D

**题目描述：** 有n组数字，每组有两个数字，现在需要每组选择一个数字，若选择第一个放入集合A中，若选择第二个数字放入集合B中，问A和B中的最大值最小相差多少

**思路分析：** 排序，按照第一个物品的价值升序，然后枚举对于第 $i$ 个物品，如果它是A集合的最大值，那么就要保证它下面所有的数字都被选择，它上面的数字可选可不选，所以我们可以维护一个后缀最大值，之后枚举的过程用set维护上面的所有值，然后二分找出大于等于当前值的第一个值，以及小于等于当前值的第一个值，这两个值如果大于后缀最大值，那么可以作为集合B的最大值，可以直接利用set内部维护的平衡树来维护一个有序序列，从而找到距离某个数字最近的一个数字。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<LL, 2>PII; 
const int N = 5e5 + 10;
int n, m;
LL a[N];
void solve()
{
	cin >> n;
	vector<PII>v;
	for (int i = 1; i <= n; i ++)
	{
		int x, y;cin >> x >> y;
		v.push_back({x, y});
	}
	sort(v.begin(), v.end());
	a[n] = 0;
	for (int i = n - 1; i >= 0; i --)a[i] = max(a[i + 1], v[i][1]);
	a[n] = -1e18;
	LL minv = 1e9;
	set<LL>s;
	s.insert(1e18), s.insert(-1e18);
	for (int i = 0; i < n; i ++)
	{
		minv = min(minv, 1ll* abs(v[i][0] - a[i + 1]));
		int x = *s.lower_bound(v[i][0]);
		int y = *--s.lower_bound(v[i][0]);
		if(x >= a[i + 1])minv = min(minv, abs(x - v[i][0]));
		if(y >= a[i + 1])minv = min(minv, abs(y - v[i][0]));
		s.insert(v[i][1]);
	}
	cout << minv << "\n";
} 
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0);
    
    int T = 1;
    cin >> T;
    while(T --)solve();
    
    return 0;
}
```

### 2.线段树上二分

**题目链接：** https://atcoder.jp/contests/abc292/tasks/abc292_h

**题目描述：** 有 $n$ 个数字，和 $q$ 次询问，每次询问给出 $p$ 和 $v$，表示将 $a[p] =v$，计算第一个平均值大于等于 $m$的位置。注意询问后修改的数字持久变化。

**思路分析：** 我们可以先将 $a[i]-m$，我们最后要求的就是第一个前缀和大于等于0的位置，所以我们思考具体做法可以用线段树进行维护，线段树维护一个区间和和一个前缀最大值，其中关键就在于pushup函数，区间和比较好实现，前缀最大值 $tr[u].maxv = max(tr[u<<1].maxv, tr[u<< 1].s+tr[u <<1].maxv)$。之后利用线段树二分实现即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<LL, 2> PII;
const int N = 5e5 + 10;
int n, m, a[N];
struct Node
{
	int l, r;
	LL s, maxv;
}tr[N * 4];
void pushup(int u)
{
	tr[u].s = tr[u << 1].s + tr[u << 1 | 1].s; 
	tr[u].maxv = max(tr[u << 1].maxv, tr[u << 1].s + tr[u << 1 | 1].maxv);
}
void build(int u, int l, int r)
{
	if(l == r)tr[u] = {l, r, a[l], a[l]};
	else{
		int mid = l + r >> 1;
		tr[u] = {l, r};
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
}
void modify(int u, int p, int v)
{
	if(tr[u].l == p && tr[u].r == p)tr[u].s = tr[u].maxv = v;
	else{
		int mid = tr[u].l + tr[u].r >> 1;
		if(mid >= p)modify(u << 1, p, v);
		else modify(u << 1 | 1, p, v);
		pushup(u);
	}
}
PII query(int u, LL pre)
{
	if(tr[u].l == tr[u].r)return {tr[u].l, pre + tr[u].maxv};
	if(pre + tr[u << 1].maxv >= 0)return query(u << 1, pre);
	else return query(u << 1 | 1, pre + tr[u << 1].s);
}
void solve()
{
	cin >> n >> m;
	int q; cin >> q;
	for (int i = 1; i <= n; i ++){
		cin >> a[i];
		a[i] -= m;
	}
	build(1, 1, n);
	while(q --){
		int c, v;cin >> c >> v;
		modify(1, c, v - m);
		PII p = query(1, 0);
		cout << fixed << setprecision(12) << 1.0 * p[1] / p[0] + m << "\n"; 
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(T --)solve();
	
	return 0;
}
```

### 3.算法中链表的使用

**题目链接：** https://www.dotcpp.com/oj/problem3155.html（第十四届蓝桥杯省赛B组H题）

**题目描述：** 给定一个长度为 $n$ 的整数数列，每次选择一个最小的整数，如果有多个最小的整数，则选择最前面的那个数字，然后把它删去，并给他两边加上这个整数，求操作 $k$ 次后的数值。

**思路分析：** 我们考虑利用堆+双向链表模拟即可。

```c++
void solve(){
	cin >> n >> m;
	priority_queue<PII, vector<PII>, greater<PII>>q;
	for (int i = 1; i <= n; i ++){
		cin >> a[i];
		q.push({a[i], i});
	} 
	r[0] = 1, l[n + 1] = n;
	for (int i = 1; i <= n; i ++)r[i] = i + 1, l[i] = i - 1;
	while(m --){
		auto x = q.top();q.pop();
		int v = x[0], p = x[1];
		if(a[p] != v){
			m ++;
			q.push({a[p], p});
			continue;
		}
		a[r[p]] += v, a[l[p]] += v;
		r[l[p]] = r[p], l[r[p]] = l[p];
	}
	int head = r[0];
    while (head != n + 1) {
        cout << a[head]<< " ";
        head = r[head];
    }
}
```

### 4.线段树维护矩阵乘法

**题目链接：**https://ac.nowcoder.com/acm/contest/23480/E

**题目描述：** 开始时有三个人，能力均为1，现在给一个长度为 $n$ 的字符串，和 $m$ 组询问，每次询问有两种类型，其中$1, x, y$表示将字符串的第 $x$ 个位置修改成 $y, 0 <= y <= 3$ ，还有 $2, x, y$，表示询问从 $x$ 到 $y$ 这个区间中经过操作每个人的能力值，其中一次操作是，第$s[i]$个人吸收剩下两个人各一半的能力值，剩下两个人能力变为原来的一半。

**思路分析：** 外面发现每次操作等价于一个矩阵乘法，一共有三种矩阵乘法，用线段树维护每个区间的矩阵乘即可，本题为线段树维护矩阵乘的模板题。

![1684675478088](C:/images/1684675478088-1684675481383-1684675785560.png)

``` c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
const LL inv2 = 499122177;
int n, m;
string s;
LL c[3][3][3] = {
	{1, 0, 0, inv2, inv2, 0, inv2, 0, inv2},
    {inv2, inv2, 0, 0, 1, 0, 0, inv2, inv2},
    {inv2, 0, inv2, 0, inv2, inv2, 0, 0, 1}   
};
void mul(LL a[][3], LL b[][3], LL c[][3])
{
    LL d[3][3];
    memset(d, 0, sizeof d);
    for(int i = 0; i < 3; i ++){
        for(int j = 0; j < 3; j ++){
            for(int k = 0; k < 3; k ++){
            	d[i][j] = (b[i][k] * c[k][j] % MOD + d[i][j]) % MOD;
			}
        }
    }
    for(int i = 0; i < 3; i ++)
    	for(int j = 0; j < 3; j ++)
    		a[i][j] = d[i][j];
}
struct Node{
	int l, r;
	LL a[3][3];
}tr[N * 4];
void pushup(int u){
	mul(tr[u].a, tr[u << 1].a, tr[u << 1 | 1].a);
}
void build(int u, int l, int r){
	if(l == r){
		tr[u] = {l, r};
		for(int i = 0; i < 3; i ++){
            for(int j = 0; j < 3; j ++)
            	tr[u].a[i][j] = c[s[l] - '1'][i][j];
        }
		return;
	}
	tr[u] = {l, r};
	int mid = l + r >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}
void modify(int u, int p, int v){
	if(tr[u].l == p && tr[u].r == p){
		for(int i = 0; i < 3; i ++){
            for(int j = 0; j < 3; j ++)
            	tr[u].a[i][j] = c[v - 1][i][j];
        }
		return;
	}
	int mid = tr[u].l + tr[u].r >> 1;
	if(p <= mid)modify(u << 1, p, v);
	else modify(u << 1 | 1, p, v);
	pushup(u);
}
Node query(int u, int l, int r){
	if(tr[u].l >= l && tr[u].r <= r)return tr[u];
	int mid = tr[u].l + tr[u].r >> 1;
	Node res = {};
	for(int i = 0; i < 3; i ++)res.a[i][i]=1;
	if(l <= mid)mul(res.a, res.a, query(u << 1, l, r).a);
	if(r > mid)mul(res.a, res.a, query(u << 1 | 1, l, r).a);
	return res;
}
void solve(){
	cin >> n >> m;
	cin >> s;s = " " + s;
	build(1, 1, n);
	while(m --){
		int op, x, y;cin >> op >> x >> y;
		if(op == 1){
			modify(1, x, y);
		} 
		else{
			Node res = query(1, x, y);
            for(int i = 0; i < 3; i ++){
                LL ans = 0;
                for(int j = 0; j < 3; j ++)
                	ans = (ans + res.a[j][i]) % MOD;
                cout << ans << " \n"[i == 2];
            }
		}
	}
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 5.set和priority_queue中采用结构体自定义排序

```c++
//set维护
struct Node{
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz > t.sz;
        return id < t.id;
    }
};
set<Node>s[N];
//大根堆
struct Node{//按照sz递减，id递增
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz > t.sz;
        return id < t.id;
    }
};
priority_queue<Node>q;
//小根堆
struct Node{//按照sz递增，id递减
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz < t.sz;
        return id > t.id;
    }
};
priority_queue<Node>q;
```

### 6.单调栈的使用

**题目链接：** https://atcoder.jp/contests/abc299/tasks/abc299_g

**题目描述：** 给一个长度为$n$的数组，其中每个数字的范围都是$1-m$且都出现至少一次，求其中组成的元素个数为$m$的字典序最小的排列。

**题目描述：** 我们可以考虑利用栈来维护，我们尽量让小的出现在前面，所以可以考虑如果栈的顶部元素比当前元素大，且后面还有这个元素的话就可以把这个栈顶元素出栈，让当前的元素入栈。

```c++
void solve(){
    cin >> n >> m;
    vector<int>a(n + 1);
	vector<int>cnt(m + 1);
	for (int i = 1; i <= n; i ++){
		cin >> a[i];
		cnt[a[i]] ++;
	}
	vector<int>st(m + 1);
	stack<int> s;
	for (int i = 1; i <= n; i ++) {
		cnt[a[i]]--;
		if (st[a[i]]) continue;
		while (!s.empty() && a[i] < s.top() && cnt[s.top()] > 0){
			st[s.top()] = 0;
			s.pop();
		}
		s.push(a[i]);
		st[a[i]] = 1;
	}
	vector<int>ans;
	while(!s.empty()){
		ans.push_back(s.top());
		s.pop();
	}
	for (int i = m - 1; i >= 0; i --) {
		cout << ans[i] << " \n"[i == 0];
	}
}
```

### 7.单调栈维护区间最大最小值

**题目链接：** https://codeforces.com/contest/1828/problem/D1

**题目描述：** 给一个长度为$n$的数组，求这个数组的所有子数组的代价之和。这里代价定义为，把一个数组排序成有序数组需要的最小时间，其中对于一个数组排序的时间为$r - l$。如$1 5 4 3 2$需要的时间为$3$。

**数据范围：** $n <= 5e3$

**思路分析：** 首先我们可以暴力枚举左右端点，我们需要确定的就是当右端点移动时，$[i,j]$这个子数组的代价是多少，首先一个子数组可以划分为多个部分，每个部分只需要进行内部排序后就有序了，对于$[i,j]$这个区间假设被分成了$k$个部分，那么这个子数组的代价就是$j-i-(num-1)$这一步可以通过画图理解。下面我们继续思考如何确定这个数组被分成了几个部分，我们考虑新加入的右端点$j$对于这个划分的贡献，首先，如果$j$大于上一次最后一个区间的最大值，那么$j$可以单独成为一个区间，如果$j$是小于上一次最后一个区间的最大值，那么我们思考如何进行维护，首先这个合并都是先和最后一个加入的区间进行合并的，这个我们就可以考虑栈这个数据结构，我们利用栈来维护目前划分的区间的最大值和最小值，然后对于一个右端点的加入，它要么单独成为一个区间，要么和前面的区间合并，直到某个区间的最大值小于当前的右端点值。这样我们就可以得到答案了。

**总结：** 如果一个题目要求维护最后一次加入集合的数据和当前数据的关系，通常考虑利用单调栈。

```c++
void solve(){
    cin >> n;
    vector<int>a(n + 1);
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
    }
    LL ans = 0;
    for (int i = 1; i <= n; i ++){
        stack<PII>stk;
        stk.push({a[i], a[i]});
        for (int j = i + 1; j <= n; j ++){
            PII p = {a[j], a[j]};
            while(stk.size() && stk.top().second > a[j]){
                p.y = max(p.y, stk.top().y);
                p.x = min(p.x, stk.top().x);
                stk.pop();
            }
            stk.push({p.x, p.y});
            ans += j - i + 1 - stk.size();
        }
    }
    cout << ans << "\n";
}
```

**进阶题目：** https://codeforces.com/contest/1828/problem/D2($范围变大n<=3e5$)

**思路分析：** 根据简单版本的分析我们可以得出以下结论,如果存在$a_{l∼k},a_{k+1∼r}$满足$mina_{k+1∼r}>maxa_{l∼k}$就能让答案减一,所以我们可以用总操作次数减去满足以上条件的三元组$l, k, r$的个数.

计数的方式是枚举iii,然后计算出有多少$a_i=mina_{k+1∼r}$的三元组数，需要满足的条件是

1. $a_i$必须是这个区间内的最小值,因为我们要找到iii之前和之后第一个小于$a_i$元素的位置,记为$x, y$,这个操作可以用单调栈实现。
2. 必须满足前一个区间的最大值小于$a_i$,因此我们找到$x$之前第一个大于$a_i$的位置$k$,只要$l$不在$k$左侧,那么这个条件就可以满足,对于这个操作我们可以给数字排序后逆序遍历,用`set`维护数的位置。

所以对于$i$,满足条件的三元组个数就是$(x−k)(y−i)$,总复杂度为$O(nlogn)$.

**注意：** 如何利用$set$来维护大于某个值的位置的方法：对于数组进行排序，并记录下标，按顺序加入数组(类似于树状数组的维护)

```c++
void solve(){
    cin >> n;
    vector<int>a(n + 2), id(n + 1);
    LL ans = 0;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        ans += 1LL * i * (i - 1) / 2;
        id[i] = i;
    }
    sort(id.begin() + 1, id.end(), [&](int x, int y){
        return a[x] < a[y];
    });
    stack<int>stk;
    vector<int>l(n + 1), r(n + 1);
    stk.push(0);
    for(int i = 1; i <= n; i ++){
        while(stk.size() && a[stk.top()] > a[i])stk.pop();
        l[i] = stk.top();
        stk.push(i);
    }
    while(stk.size())stk.pop();
    stk.push(n + 1);
    for(int i = n; i >= 1; i --){
        while(stk.size() && a[stk.top()] > a[i])stk.pop();
        r[i] = stk.top();
        stk.push(i);
    }
    set<int> s;
    s.insert(0);
    for(int i = n; i >= 1; i--){
        int pos = id[i];
        int x = l[pos], y = r[pos];
        int k = x == 0 ? 0 : *prev(s.lower_bound(x));
        ans -= 1LL * (x - k) * (y - pos);
        s.insert(pos);
    }
    cout << ans << '\n';
}
```

### 8.线段树维护左右端点等情况

**题目链接：** https://codeforces.com/gym/104363/problem/B

**题目描述：** 给一个长度为$n$的字符串(只包含0或者1)和$m$次操作，操作分为两种类型：

1.将$L$到$R$这个区间内所有数字翻转，即$0->1,1->0$。

2.求出将$L$到$R$这个区间内所有数字删除需要的操作中次数，一次操作可以选择多个连续的01串(即这个子串中必须0和1交替出现，可以只有一个)将他们删除，求最小的操作次数。

**思路分析：** 将一个01串删除为经典题型，我们通过枚举样例发现实质上一个字符串可以分为多个极长的字符串，极长是指无法继续扩展的01串，那么对于每一个01串，如果这个串左右两边是形如00和11这样的结构，那么删除这个字符串后会使段数-1，那么操作次数也就会-1，那么根据这个思路我们可以维护每个区间的段数ans，00的个数a，11的个数b，然后一个区间的值就是$ans - min(a,b)$。代码中$lc$表示最左边的字符是谁，$rc$表示最右边的字符，注意如果去掉修改操作这个题目的01串也是一个经典题目需要理解其原因。

```c++
int n, m;
string s;
struct Node {
    int l, r;
    int ans;
    int lc, rc;
    int a, b;
    int tag;
} tr[N << 2];
void pushup(Node& u, const Node& l, const Node& r) {
    u.l = l.l, u.r = r.r;
    u.lc = l.lc, u.rc = r.rc;
    u.ans = l.ans + r.ans;
    u.a = l.a + r.a;
    u.b = l.b + r.b;
    if (l.rc == 0 && r.lc == 0) u.a++;
    else if (l.rc == 1 && r.lc == 1) u.b++;
    else u.ans--;
}
void pushup(int u) {
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}
void settag(int u) {
    tr[u].lc ^= 1, tr[u].rc ^= 1;
    swap(tr[u].a, tr[u].b);
    tr[u].tag ^= 1;
}
void pushdown(int u) {
    if (tr[u].tag) {
        settag(u << 1);
        settag(u << 1 | 1);
        tr[u].tag = 0;
    }
}
void build(int u, int l, int r) {
    tr[u] = {l, r};
    if (l == r) {
        tr[u].ans = 1;
        tr[u].lc = tr[u].rc = s[l] - '0';
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
    pushup(u);
}
void modify(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        settag(u);
        return;   
    }
    int mid = tr[u].l + tr[u].r >> 1;
    pushdown(u);
    if (l <= mid) modify(u << 1, l, r);
    if (r > mid) modify(u << 1 | 1, l, r);
    pushup(u);
}
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    int mid = tr[u].l + tr[u].r >> 1;
    pushdown(u);
    if (r <= mid) return query(u << 1, l, r);
    if (l > mid) return query(u << 1 | 1, l, r);
    Node res;
    pushup(res, query(u << 1, l, r), query(u << 1 | 1, l, r));
    return res;
}
void solve(){
    int n, m;cin >> n >> m;
    cin >> s;
    s = " " + s;
    build(1, 1, n);
    while(m --){
        char op[2];
        int l, r;
        cin >> op >> l >> r;
        if(*op == 'M'){
            modify(1, l, r);
        }
        else{
            Node res = query(1, l, r);
            cout << res.ans - min(res.a, res.b) << "\n";
        }
    }
}
```

### 9.树状数组维护前缀和

**题目链接：** https://codeforces.com/contest/1616/problem/E

**题目描述：** 给两个长度为$n$的字符串$s$和$t$，每次操作你可以使得两个相邻的字母交换位置，求最少进行多少次操作，可以使得$s$的字典序小于$t$。

**思路分析：** 我们考虑从前到后暴力枚举每个位置，每个位置在操作之后的变化就两种：

1.找到一个$j$,$j>=i$，使得$s[j] < t[i]$，此时可以直接更新答案，$ans = now + j到i的长度$

2.找到$j$，使得$s[j] == t[i]$，此时更新$now$，即此时$s[1-i]=t[1-i]$，需要的代价。

维护的方法：我们发现我们将一个$s[j]=t[i]$ 移动到前面的位置的时候，相当于他后面所有元素的位置向前移动，即所有位置到目标位置的距离都会$-1$，根据这个思路我们可以利用树状数组维护一个位置到达目标位置(即$i$)需要的代价即可，找到最靠近$i$的$j$的方法是利用队列存储每个字母出现的位置即可。

```c++
void solve(){
    cin >> n;
    string s, t;
    cin >> s >> t;
    queue<int>q[26];
    for (int i = 1; i <= n; i ++)tr[i] = 0;
    for (int i = 1; i <= n; i ++){
        add(i, 1);
    }
    for (int i = 0; i < n; i ++){
        q[s[i] - 'a'].push(i + 1);
    }
    LL ans = 1e18, now = 0;
    for (int i = 0; i < n; i ++){
        int x = t[i] - 'a';
        for (int j = x - 1; j >= 0; j --){
            if(!q[j].size())continue;
            ans = min(ans, now + ask(q[j].front() - 1));
        }
        if(q[x].size() == 0)break;
        now += ask(q[x].front() - 1);
        add(q[x].front(), -1);
        q[x].pop();
    }
    cout << (ans == 1e18 ? -1 : ans) << "\n";
}
```

### 10.单链表式并查集

**题目链接：** https://www.acwing.com/problem/content/1244/

**题目描述：** 给一个长度为$n$的数组，想要构造一个数组使得每个数字都不相同，其中构造的方法如下：如果这个数字在之前出现过就+1直到前面没有这个数字为止。

**思路分析：** 利用并查集的思路，适用于给$m$个都在$[1, n]$上的线段，统计数字的出现顺序，利用并查集的思想可以只访问每个数字一次。在调用$find$函数的时候，这个点会自动指向第一个没有出现的点。

**时间复杂度：** $O(n+ m)$ 

```c++
for (int i = 1; i <= m; i ++){
        int l, r;
        cin >> l >> r;
        for (int i = dsu.find(l); i <= r; i = dsu.find(i)){
            id[i] = ++tot;
            dsu.p[i] = i + 1;
        }
}
```

### 11.线段树多个标记以及两棵线段树的转移

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7284

**题目描述：** 给定一个长度为$n$的序列$a$，下面有$m$种操作，操作类型如下：本题保证$x_j<=x_{j+1}$。

$1,l,r,x_j$,是指对于$[l, r]$内每一个数字，让$a[i]=|a[i]-x|$；$2,l,r$是求$[l,r]$这个区间的所有数字之和。

**思路分析：** 首先我们观察绝对值，分类讨论，当$a[i]>x$时我们$a[i]=a[i]-x$；当$a[i]<x$时$a[i]=x-a[i]$,由于题目保证$x$是递增的，那么就有当$a[i]$开始小于$x$的时候他一定一直就小于$x$了，根据这个性质我们可以发现每个位置只会从一颗线段树转移到另一颗线段树一次，所以这里面是可以暴力转移的。接下来我们考虑如何维护两个线段树，首先对于第一个$a[i]>x$的线段树，我们要维护他们的和，懒标记的和对于第一种情况只要记录$x$的和即可，同时我们还需要记录当前线段树的最小值和当前线段树的点的个数(满足$a[i] > x$)，这里主要是判断当前这个区间是否有需要转移的点，第二棵线段树的懒标记主要是有当前的和的符号以及当前操作的$x$的和，注意当$a[i]<x$之后，每次变化都会改变符号，如$x_1-a[i]$,$a[i]-x_1+x_2$所以要维护符号。

```c++
struct SegmentTree {
    struct Node{
        int l, r;
        int s1, s2;//s1是a[i]>=x的a[i]的和，s2是a[i]<x的a[i]的和
        int minv, cnt;//a[i]的最小值，a[i]>x的个数
        int tag1;//操作1下面的x的和
        int tag2, tag3;//操作2下面s2的符号以及操作数x的和(xi-xj+xk)
    }tr[N * 4];

    void settag1(int u, int x){//第一种情况的标记
        tr[u].tag1 += x;
        tr[u].s1 -= tr[u].cnt * x;
        tr[u].minv -= x;
    }
    void settag2(int u, int x, int y){//第二种情况的标记
        tr[u].tag2 *= x;
        tr[u].tag3 = y + tr[u].tag3 * x;
        tr[u].s2 = (tr[u].r - tr[u].l + 1 - tr[u].cnt) * y + tr[u].s2 * x; 
    }
    
    void pushup(int u){
        tr[u].s1 = tr[u << 1].s1 + tr[u << 1 | 1].s1;
        tr[u].s2 = tr[u << 1].s2 + tr[u << 1 | 1].s2;
        tr[u].minv = min(tr[u << 1].minv, tr[u << 1 | 1].minv);
        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
    }
    void pushdown(int u) {
        settag1(u << 1, tr[u].tag1);
        settag1(u << 1 | 1, tr[u].tag1);
        
        settag2(u << 1, tr[u].tag2, tr[u].tag3);
        settag2(u << 1 | 1, tr[u].tag2, tr[u].tag3);

        tr[u].tag1 = tr[u].tag3 = 0;
        tr[u].tag2 = 1;
        return;
    }

    void build(int u, int l, int r){
        if(l == r){
            tr[u] = {l, r, a[l], 0, a[l], 1, 0, 1, 0};
            return;
        }
        int mid = l + r >> 1;
        tr[u] = {l, r};
        tr[u].tag2 = 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int l, int r, int x){
        if(tr[u].l >= l && tr[u].r <= r){
            if(tr[u].cnt) {
                if (tr[u].l == tr[u].r) {
                    //转移这个点
                    if (tr[u].minv < x) {
                        tr[u].s2 = x - tr[u].s1;
                        tr[u].s1 = tr[u].cnt = 0;
                        tr[u].minv = inf;
                    } else {
                        tr[u].s1 = tr[u].minv = tr[u].s1 - x;
                    }
                } else {
                    if (tr[u].minv >= x) {
                        settag1(u, x);
                        settag2(u, -1, x);
                    } else {//最小值<x说明进入s2中暴力找到这个点即可,每个点只会转移一次
                        pushdown(u);
                        int mid = tr[u].l + tr[u].r >> 1;
                        if (l <= mid)modify(u << 1, l, r, x);
                        if (r > mid)modify(u << 1 | 1, l, r, x);
                        pushup(u);
                    }
                }
            } else {
                settag2(u, -1, x);
            }
            return;
        }
        int mid = tr[u].l + tr[u].r >> 1;
        pushdown(u);
        if(mid >= l)modify(u << 1, l, r, x);
        if(mid < r)modify(u << 1 | 1, l, r, x);
        pushup(u);
    }
    int query(int u, int l, int r){
        if(tr[u].l >= l && tr[u].r <= r){
            return tr[u].s1 + tr[u].s2;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= r)return query(u << 1, l, r);
        else if(mid < l)return query(u << 1 | 1, l, r);
        else return query(u << 1, l, r) + query(u << 1 | 1, l, r);
    }
}tree;
```

### 12.二维数点问题

**题目链接：** https://www.luogu.com.cn/problem/P2163

**题目描述：** 给一个长度为$n$的数组，多组询问求出下标在$[i, j]$范围内，值域在$[l, r]$范围内的点的数目。

**思路分析：** 将所有点对$(i, a[i])$看作点，把每次询问看做正方形，将所有询问和所有点按照事件的顺序填入，其中四维依次是纵坐标，类型（是点还是正方形的边界，正方形的边界分为1 2两种，1表示下边界需要减去此时的点的数目，2表示上边界需要加上点的数目，可以理解为二维前缀和的求法，注意对于具有相同$y$坐标的点要满足先插入在查询，即点的优先级最高），横坐标和对应的询问编号。处理完后我们把所有点的横坐标离散化后存入数组，然后把点和两个平行与$x$轴的直线（即长方形的上下边界）存入事件，然后事件按照$y$坐标排序，将横坐标存入树状数组然后查询即可。



![1690941518774](C:/images/1690941518774-1690941522342.png)

```c++
void solve()
{
	int n, q;
    cin >> n >> q;
	vector<int>vx, ans(q + 1);
	vector<array<int, 4>>event;
	for (int i = 1; i <= n; i ++)
	{
		int x, y;
        cin >> x >> y;
		vx.push_back(x);
		event.push_back({y, 0, x, 0});
	}
	for (int i = 1; i <= q; i ++)
	{
		int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
		event.push_back({y2, 2, x2, i});
		event.push_back({y2, 1, x1 - 1, i});
		event.push_back({y1 - 1, 1, x2, i});
		event.push_back({y1 - 1, 2, x1 - 1, i});
	}
	sort(event.begin(), event.end());
	sort(vx.begin(), vx.end());
	vx.erase(unique(vx.begin(), vx.end()), vx.end());
	int m = vx.size() + 1;
	BIT bit(m);
	for (auto evt: event)
	{
		int x = evt[2], type = evt[1], idx = evt[3];
		int t = lower_bound(vx.begin(), vx.end(), x) - vx.begin() + 1;
		if(type == 0)bit.modify(t, 1);
		else 
		{
			t = upper_bound(vx.begin(), vx.end(), x) - vx.begin();
			int tmp = bit.query(t);
			if(type == 2)ans[idx] += tmp;
			else ans[idx] -= tmp;
		}
	}
	for (int i = 1; i <= q; i ++)cout << ans[i] << "\n";
}
```

### 13.树状数组+扫描线问题

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7337

**题目描述：** 给一个长度为$n$的数组，和$q$次询问，求出有多少个$i$和$j$满足，$L<=i<=j<=R$，且$a[i]+a[j]$是完全平方数。

**思路分析：** 首先预处理出来所有的点前面的位置和它的和满足是完全平方数的下标，然后把每个询问对应的右端点存储左端点和编号，之后通过树状数组，每次遍历到一个点的时候，先把预处理的满足题意的下标加入树状数组，之后在查询把这个点当做右端点时的答案即可。（本题若用二维数点思路会被卡常）

注意下面的图中，解释了本题正确性的原因，我们是遍历到右端点的时候才同时处理左端点的，所以不用担心前面两种情况的出现。

![1691063129464](C:/images/1691063129464-1691063131940.png)

```c++
void solve(){
    int n;
    cin >> n;
    vector<int>a(n + 1), p(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> p[i];
        a[p[i]] = i;
    }
    vector<int>st(n + 1);
    vector<vector<int>>pre(n + 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < v.size(); j++) {
            int x = v[j];   
            if(x >= p[i] && x - p[i] <= n && st[x - p[i]]) {
                pre[i].emplace_back(a[x - p[i]]);
            }
        }
        st[p[i]] = true;
    }
    int m;
    cin >> m;
    vector<vector<Node>>seg(n + 1);
    for (int i = 1; i <= m; i++) {
        int L, R;
        cin >> L >> R;
        seg[R].push_back({L, i});
    }
    BIT bit(n + 1);
    vector<int>ans(m + 1);
    for (int i = 1; i <= n; i++) {
        for (auto x : pre[i]) {
            bit.modify(x, 1);
        }
        for (auto t : seg[i]) {
            int L = t.L, idx = t.idx;
            ans[idx] = bit.query(L, i);
        }
    }
    for (int i = 1; i <= m; i++) {
        cout << ans[i] << "\n";
    }
}
```

### 14.莫队+树状数组

**题目链接：** https://ac.nowcoder.com/acm/contest/57359#question

**题目描述：** 给一个长度为$n$的数组，求满足$1 <= i < j < k <= n$且$a[i] = a[k] > a[j]$的数量。

**思路分析：** 首先通过树状数组查询一个下标$k$前面有多少$j$满足$a[j]<a[k]$，然后通过莫队离线处理答案。其中从$[L, R]$扩展到$[L, R+1]$的变化可以写成$\sum_{i=1}^{cnt[a[R + 1]}b[R + 1]-b[i]$，其中$b$代表了这个位置前面比它数字小的位置个数，那么我们可以化简上式子为$sum[b[a[R + 1]] - cnt[a[R + 1]] \times b[a[R+1]]$。别的同理可以推导出来。

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1), b(n + 1);
    BIT bit(n);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = bit.query(a[i] - 1);
        bit.modify(a[i], 1);
    }
    vector<array<int, 3>>query;
    int K = sqrt(n);
    for (int i = 1; i <= m; i++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r, i});
    }
    sort(query.begin(), query.end(), [&](array<int, 3>A, array<int, 3>B){
        int c = A[0] / K;
        if(c != B[0] / K) return c < B[0] / K;
        return(c % 2 ? A[1] > B[1] : A[1] < B[1]);
    });
    vector<int>ans(m + 1), sum(n + 1), cnt(n + 1);
    int l = 1, r = 0, res = 0;
    auto addR = [&](int x){
        res += cnt[a[x]] * b[x] - sum[a[x]];
        cnt[a[x]]++, sum[a[x]] += b[x];
    };
    auto addL = [&](int x){
        res += sum[a[x]] - cnt[a[x]] * b[x];
        cnt[a[x]]++, sum[a[x]] += b[x];
    };
    auto delR = [&](int x){
        cnt[a[x]]--, sum[a[x]] -= b[x];
        res -= cnt[a[x]] * b[x] - sum[a[x]];
    };
    auto delL = [&](int x){
        cnt[a[x]]--, sum[a[x]] -= b[x];
        res -= sum[a[x]] - cnt[a[x]] * b[x];
    };
    for (auto evt : query){
        while(r < evt[1])r++, addR(r);
        while(l > evt[0])l--, addL(l);
        while(r > evt[1])delR(r), r--;
        while(l < evt[0])delL(l), l++;
        ans[evt[2]] = res;
    }
    for (int i = 1; i <= m; i++) {
        cout << ans[i] << "\n";
    }
}
```

### 15.懒惰删除+树状数组

**题目链接：** https://codeforces.com/contest/1858/problem/E2

**题目描述：** 给定 $n$ 组询问，每个询问为下面的某个操作：

$1.$$+ x$表示想数组中增加一个数字 $x \leq 1000000$。

$2.$$- k$表示删除数组中最后 $k$ 个元素。

$3.$$!$表示撤回上次操作。

$4.$ 询问数组中一共有多少个数值不同的数组。

**思路分析：** 首先我们发现这些操作的瓶颈主要是删除元素，它的复杂度比较高，我们考虑如何删除这些元素。

分两种思路：第一种是离线思路，我们可以考虑利用倍增优化，把整个操作看成一棵树即可。

```c++
void solve(){
    int q;
    cin >> q;
    int tot = 0, cur = 0, num = 0;
    vector<int> ops;
    ops.push_back(cur);
    vector<vector<int>> fa(1e6 + 1, vector<int>(22));
    vector<vector<int>> g(1e6 + 1);
    vector<vector<int>> query(1e6 + 1);
    vector<int> a(1e6 + 1);
    for (int _ = 1; _ <= q; _++) {
        string op;
        int x;
        cin >> op;
        if(op == "+") {
            cin >> x;
            a[++ tot] = x;
            fa[tot][0] = cur;
            for (int i = 1; i <= 20; i++) {
                fa[tot][i] = fa[fa[tot][i - 1]][i - 1];
            }
            g[cur].push_back(tot);
            cur = tot;
            ops.push_back(tot);
        } else if(op == "-") {
            cin >> x;
            for (int i = 20; i >= 0; i--) {
                if(x >> i & 1) {
                    cur = fa[cur][i];
                }
            }
            ops.push_back(cur);
        } else if(op == "!") {
            ops.pop_back();
            cur = ops.back();
        } else {
            query[cur].push_back(++ num);
        }
    }
    vector<int> cnt(1e6 + 2);
    int sum = 0;
    vector<int> ans(1e5 + 1);
    auto dfs = [&](auto &self, int u) -> void{
        if (u){
            if (++cnt[a[u]] == 1){
                sum ++;
            }
        }
        for(auto x : query[u]) ans[x] = sum;
        for(auto j : g[u]) self(self, j);
        if (u){
            if (--cnt[a[u]] == 0){
                sum --;
            }
        }
    };
    dfs(dfs, 0);
    for (int i = 1; i <= num; i++) {
        cout << ans[i] << "\n";
    }
}
```

如果题目强制要求在线，那么就必须用第二种思路：我们使用懒惰删除的思想，即每次删除只是把指针（操作数组的索引）移动到应该的位置而不真正的删除，我们用树状数组维护每个下标是否有贡献，只有当这个点再次被访问到的时候，即必须删除的时候我们再把它删除，这样可以把删除操作复杂度分摊为 $O(1)$。

```c++
void solve(){
    int n;
    cin >> n;
    vector<PII> ops;
    vector<int> a(n, 0);
    vector<set<int>> s(1000001);
    int sz = 0;
    BIT bit(n);
    while(n--) {
        char op;
        cin >> op;
        if(op == '+') {
            int v = a[++sz];
            if(v) {
                if(s[v].size()) {
                    bit.modify(*s[v].begin(), -1);
                    s[v].erase(sz);
                }
                if(s[v].size()) {
                    bit.modify(*s[v].begin(), 1);
                }
            }
            ops.emplace_back(v, 1);
            cin >> a[sz];
            v = a[sz];
            if(s[v].size()) {
                bit.modify(*s[v].begin(), -1);
            }
            s[v].insert(sz);
            if(s[v].size()) {
                bit.modify(*s[v].begin(), 1);
            }
        } else if(op == '-') {
            int k;
            cin >> k;
            sz -= k;
            ops.emplace_back(k, 0);
        } else if(op == '!') {
            auto t = ops.back();
            ops.pop_back();
            if(t.y == 0) {
                sz += t.x;
            } else {
                int v = a[sz];
                if(s[v].size()) {
                    bit.modify(*s[v].begin(), -1);
                    s[v].erase(sz);
                }
                if(s[v].size()) {
                    bit.modify(*s[v].begin(), 1);
                }
                a[sz] = t.x;
                v = t.x;
                if(v) {
                    if(s[v].size()) {
                        bit.modify(*s[v].begin(), -1);
                    }
                    s[v].insert(sz);
                    if(s[v].size()) {
                        bit.modify(*s[v].begin(), 1);
                    }
                }
                sz--;
            }
        } else {
            cout << bit.query(sz) << endl;
        }
    }
}
```

### 16.可撤销并查集

**题目链接：** https://atcoder.jp/contests/abc302/tasks/abc302_h

**题目描述：** 给一棵有 $n$个结点的树，每个点上面有两个数字，分别求出从1号点出发，到达其他所有点的最短路径上面能够收集到的最大的不同数字的数量，注意每个点只能选取其中一个数字。

**思路分析：** 首先对于一个点的两个可以取的数值建立一条边，一条边表示可以选择两个中的一个，所以我们可以知道如果最后某个连通块是一个树的话，那么就是树中结点个数-1，而如果不是一个树是一个图的话就一定是所有的点都可以选择，利用这个思路，我们只要利用可撤销并查集维护即可，可撤销并查集不能用压缩路径优化，应该使用启发式合并优化。

```c++
void solve(){
    int n;
    cin >> n;
    vector<vector<int>> g(n + 1);
    vector<PII> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y;
    }
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    int cur = 0;
    vector<int> res(n + 1);
    vector<int> p(n + 1), sz(n + 1, 1), st(n + 1);
    iota(p.begin(), p.end(), 0);
    auto find = [&](int x) {
        while(x != p[x]) {
            x = p[x];
        }
        return p[x];
    };
    auto dfs = [&](auto &self, int u, int fa) -> void {
        int pu = find(a[u].x), pv = find(a[u].y);
        if(sz[pu] > sz[pv]) {
            swap(pu, pv);
        }
        int f = pu, x = sz[pu], y = st[pu], z = st[pv];
        if (pu == pv) {
            cur -= sz[pu] + (st[pu] - 1);
            st[pu] = 1;
            cur += sz[pu] + (st[pu] - 1);
        } else {
            cur -= sz[pu] + (st[pu] - 1);
            cur -= sz[pv] + (st[pv] - 1);
            p[pu] = pv;
            sz[pv] += sz[pu];
            st[pv] |= st[pu];
            cur += sz[pv] + (st[pv] - 1);
        }
        res[u] = cur;
        for (auto v : g[u]) {
            if (v == fa) continue;
            self(self, v, u);
        }
        if (pu == pv) {
            cur -= sz[pu] + (st[pu] - 1);
            st[pu] = y;
            cur += sz[pu] + (st[pu] - 1);
        } else {
            cur -= sz[pv] + (st[pv] - 1);
            st[pu] = y;
            st[pv] = z;
            sz[pv] -= x;
            sz[pu] = x;
            p[pu] = f;
            cur += sz[pu] + (st[pu] - 1);
            cur += sz[pv] + (st[pv] - 1);
        }
    };
    dfs(dfs, 1, -1);
    for (int i = 2; i <= n; i++) {
        cout << res[i] << " \n"[i == n];
    }
}
```





## 三、动态规划

### 1.单调队列优化dp

**题目链接：** https://www.acwing.com/problem/content/301/

**题目描述：**有一个长度为n的序列A，把这个序列分成若干段，在满足所有段的总和不超过M的基础上，让每段所有数字的最大值的和最小，求最小值。

**思路分析：** 首先考虑 ***dp*** ， $f[i]$ 表示前 $i$ 段区间分成若干段情况下的最小值，朴素法考虑 $f[i] = min(f[j] + max(a[j + 1 ~ i]))$ , 其中 $j < i$, 下面考虑如何优化，首先我们利用双指针，找到一段合法的区间，$[j, i]$ 内选一个点使得其最小，那么这个点的性质有一下特征:
$$
a[k] > max(a[k + 1] - a[i])
$$
下面给出证明：我们发现对于 $[j, i]$ 区间最大值，那么这时候一定是选 $j-1$ 是最优的，因为假设我们选择了 $j$, 由于本题都是正数，那么一定有 $f[j] >= f[j - 1]$, 又因为 $max(j, i) = max(j - 1, i)$， 所以我们发现在 $[j, k]$ 这个区间中最前面的点一定是最优的(其中k为最大值所在的位置)，如果有多个最大值，我们只需要去最后一个，因为这样不会使结果变差，也有利于我们维护单调队列。对于最大值和次大值之间，次大值和第三大值之间的点我们同样分析, 我们可以发现对于每个区间，我们都选择最前面的点一定是最优的。如下面的图中，维护一个单调递减序列后，把这个区间分成了四部分，其中对于 $a_{m2}$ 来说，如果它作为和 $i$ 一起的区间的最大值的话，一定选 $f[k_{1}]$ 最优。但是这里队头不一定是最优的，还需要维护一个multiset来判断区间内的最小值，单调队列维护一个递减的序列，注意当队列中只有一个元素的时候，不能进行删除操作，只有一个元素表示这元素为最大值，那么后面 $f[i] = f[j -1] + a[q[hh]]$ 即可，如果两个以上元素，才需要考虑次大值等情况。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
const int N = 1e5 + 10;
int n, m;
int a[N], q[N];
LL f[N];
multiset<LL> S;
void remove(LL x)
{
    auto it = S.find(x);
    S.erase(it);
}
void solve()
{
	LL m;scanf("%d%lld", &n, &m);
	for (int i = 1; i <= n; i ++)
	{
		scanf("%d", &a[i]);
		if(a[i] > m)
		{
			puts("-1");
			return;
		}
	}
	LL sum = 0;
	int hh = 0, tt = -1;
	for (int i = 1, j = 1; i <= n; i ++)
    {
        sum += a[i];
        while (sum > m)
        {
            sum -= a[j ++];
            if (hh <= tt && q[hh] < j)
            {
                if (hh < tt) remove(f[q[hh]] + a[q[hh + 1]]);
                hh ++;
            }
        }
        while (hh <= tt && a[q[tt]] <= a[i])
        {
            if (hh < tt) remove(f[q[tt - 1]] + a[q[tt]]);
            tt -- ;
        }
        q[ ++ tt] = i;
        if (hh < tt) S.insert(f[q[tt - 1]] + a[q[tt]]);
        f[i] = f[j - 1] + a[q[hh]];
        if (S.size()) f[i] = min(f[i], *S.begin());
    }
    cout << f[n] << "\n";
}
int main()
{
	int T = 1;
	//scanf("%d", &T);
	while(T --)solve();
	return 0;
}
```

### 2.计数类dp

**题目来源：** https://codeforces.com/contest/1670/problem/F

**题目描述：** 你需要构造一个长度为 $n$ 的数组，要求数组中元素的总和在 $[l, r]$这个范围，且所有元素的异或和恰好为 $z$. 求有多少中构造方案。其中 $n <= 1000$.

**思路分析：** 我们可以利用数位统计dp的思路，计算总和小于等于 $x$, 且满足条件的构造方案数量，算完之后只需要 $s[r] -  s[l - 1]$ 即可。所以我们现在目标就是构造一个数组所有元素总和小于等于$x$，异或的条件很好满足，只要保证每一位是奇数个1还是偶数个1即可。我们将 $n$ 个数字同时构造，考虑 $f[i][j]$ 为 已经填充了所有数字的前 $i$ 位，当前这个位置还有 $j$ 个1可以用，为什么要这样考虑呢？我们发现对于一个 $x$，我们可以写出它的二进制编码，例如 $1101$, 如果第一个位置没有用，那么第二个位置就可以放 $2 + 1 = 3$ 个1，也就是n个数可以选择3个数字放1，那么这样我们就可以明确了 $f[i][j]$ 就表示前 $i$ 位已经放好，且第 $i$ 个位置还可以放 $j$ 个1，那么第 $i-1$ 这个位置就可以放 $2 \times j$ 个1，所以我们就可以得到递推方程。
$$
f[i][min(dif - k, n)] = \sum_{k=0}^{min(dif, n)}f[i+1][j] \times C[n][k],其中dif=2*j+x[i]
$$
因为每一个位置最多只能有 $n$ 个 1，所以如果当前 $dif >= 2 *n$ 了，那么这个位置和下一个位置一定可以放 $n$ 个1，且下面所有位置都可以放 $n$ 个1，所以最大只要到 $n$ 即可。

```c++
int count(LL x)
{
	memset(f, 0, sizeof f);
	f[61][0] = 1;
	LL ans = 0;
	for (int i = 60; i >= 0; i --)
	{
		for (int j = 0; j <= n; j ++)
		{
			int dif = 2 * j + (x >> i & 1);
			for (int k = (z >> i & 1); k <= min(n, dif); k += 2)
			{
				f[i][min(dif - k, n)] += 1ll * f[i + 1][j] * C[n][k] % mod;
				f[i][min(dif - k, n)] %= mod;
			}
		}
	}
	for (int i = 0; i <= n; i ++)ans = (ans + f[0][i]) % mod;
	return ans;
}
```

### 3.树状数组优化dp

**题目来源：** https://codeforces.com/contest/1802/problem/E

**题目描述：** 有 $n$ 个数组，每个数组中有 $k$ 个数字，现在需要对这 $n$ 个数组进行排序，且一个数组中的k个数字必须连续的放在一起，如果后面一个数字比前面所有数字都大那么他是有效的，求有效数字最多有多少个。注意这里一个数组中所有元素都必须选择，也就是如果一个数字在第 $i$ 位，那么他一定要大于前 $i$ 位才是成立的。

**思路分析：** 首先我们可以把一个组中先求出从头开始的单调上升序列，把他们保存在一个数组中，接着对于所有数组的最后一个元素进行排序，因为我们知道如果一个数组的最后一个元素比另一个数组的最后一个元素大的话就会导致另一个数组没法选择，这显然不优，所以我们按照结尾元素进行排序。对于排序后，我们要枚举一下每个数字应该放在第几段之后，假设第 $i$ 段接在了第 $j$ 段后面，那么他们中间的段就可以认为不用，我们就需要求出数字$j$ 前面的最大值，这里可以利用树状数组维护。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII; 
const int N = 2e5 + 10;
int n, m;
int tr[N];
int lowbit(int x){return x & -x;}
void add(int x, int v)
{
	for (int i = x; i < N; i += lowbit(i))tr[i] = max(tr[i], v);
}
int ask(int x)
{
	int res = 0;
	for (int i = x; i; i -= lowbit(i))res = max(res, tr[i]);
	return res;
}
void clear(int x)
{
	for (int i = x; i < N; i += lowbit(i))tr[i] = 0;
}
void solve()
{
	cin >> n;
	vector<vector<int>>v(n + 1);
	vector<int>f(n + 1);
	for (int i = 1; i <= n; i ++)
	{
		int k;cin >> k;
		while(k --)
		{
			int x; cin >> x;
			if(!v[i].size() || v[i].back() < x)v[i].push_back(x);
		}
	}
	sort(v.begin() + 1, v.end(), [&](vector<int>&a, vector<int>&b){
		return a.back() < b.back();
	});
	int ans = 0;
	for (int i = 1; i <= n; i ++)
	{
		int cnt = 0;
		for (int j = v[i].size() - 1; j >= 0; j --)
		{
			cnt ++;
			f[i] = max(f[i], ask(v[i][j] - 1) + cnt);
		}
		add(v[i].back(), f[i]);
		ans = max(ans, f[i]);
	}
	for (int i = 1; i <= n; i ++)clear(v[i].back());
	cout << ans << "\n";
} 
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    int T = 1;
    cin >> T;
    while(T --)solve();
    
    return 0;
}
```

### 4.余数dp

**题目链接：** https://codeforces.com/gym/103443/problem/D

**题目描述：** 构造一个长度$n <= 16$的数字，每个位置上是 $1-9$ 中一个题目会给出具体的可以选择的$n$个数字，现在把这些数字组合在一起对 $m$ 取余，问最大余数对应的数字是多少。

**思路分析：** 设 $f[i][j]$表示当前二进制状态是 $i$ 的情况下，余数为 $j$ 时的最大值，其中可以考虑状态更新，因为余数有多个性质：(a % m + b) % m = (a + b) % m, 所以我们就可以利用dp来解决，表示选取$n$个中的几个构成的数字的余数的最大值。一般余数问题可以采用这个方法。

```c++
const int N = 1e5 + 10, M = 210;
int n, m, a[N];
LL f[N][M];
void solve()
{
	cin >> n >> m;
	for (int i = 0; i < n; i ++)cin >> a[i];
	memset(f, -1, sizeof f);
	f[0][0] = 0;
	for (int i = 0; i < (1 << n); i ++){
		for (int j = 0; j < n; j ++){
			if((i >> j & 1) == 0){
				for (int k = 0; k < m; k ++){
					if(f[i][k] == -1)continue;
					f[i | (1 << j)][(k * 10 + a[j]) % m] = max(f[i | (1 << j)][(k * 10 + a[j]) % m], f[i][k] * 10 + a[j]);
				}
			}
		}
	}
	int x = (1 << n) - 1;
	for (int i = m - 1; i >= 0; i --){
		if(f[x][i] > 0){
			cout << f[x][i] << "\n";
			break;
		}
	}
}
```

### 5.差值dp

**题目链接：** https://codeforces.com/gym/103446/problem/I

**题目描述：** 有 $n$ 张卡片，每个卡片上面有一个数值 $a[i]$，可以选择其中 $k$ 张并将其翻倍，要从把 $n$ 张卡恰好分成两堆，使得两堆中各自和相等，求和最大是多少。

**思路分析：** 设 $f[i][j][k]$ 表示枚举到第 $i$ 张卡片，目前两堆差值为 $j$，已经将 $k$ 张卡片翻倍的情况下的最大值，注意差值可能为负数，所以我们设置一个偏移量base即可，但是dp枚举的时候还是正常枚举负数的差值，只是放入数组中加上base即可。

```c++
void solve() 
{
    int n, m;scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)scanf("%d%d", &v[i], &t[i]);
    memset(f, -0x3f, sizeof f);
    int base = 1400;
    f[0][base][0] = 0;
    for (int i = 1; i <= n; i ++)
    {
        for (int j = -base; j <= base; j ++)
        {
            for (int k = 0; k <= m; k ++)
            {
                if (j - t[i] + base >= 0)f[i][j + base][k] = max(f[i - 1][j + base][k], f[i - 1][j - t[i] + base][k] + v[i]);
                if (j + t[i] + base < M)f[i][j + base][k] = max(f[i][j + base][k], f[i - 1][j + t[i] + base][k] + v[i]);
                if(k >= 1 && j - 2 * t[i] + base >= 0)f[i][j + base][k] = max(f[i][j + base][k], f[i - 1][j - 2 * t[i] + base][k - 1] + v[i]);
                if(k >= 1 && j + 2 * t[i] + base < M)f[i][j + base][k] = max(f[i][j + base][k], f[i - 1][j + 2 * t[i] + base][k - 1] + v[i]);
            }
        }
    }
    LL ans = 0;
    for (int i = 0; i <= m; i ++)ans = max(ans, f[n][base][i]);
    cout << ans << "\n";
}
```

### 6.划分为两个子序列dp

**题目链接：** https://codeforces.com/contest/1799/problem/D1

**题目描述：** 有 $n$ 个任务，每个任务是 $k$ 个类型之一，有两个机器可以执行这几个任务，但是两个机器只能有一个机器执行，且后一个任务一定要等到前一个任务执行结束后执行，且如果一个机器连续执行两个相同的任务那么第二个只需要 $h[i]$，如果执行的不是相同的任务那么需要 $c[i]$。问执行完所有任务的最短时间。

**思路分析：** $f[i][j]$表示执行到第 $i$ 个任务，另一个机器在 $j$ 这个编号最后一次执行任务的最短时间，因为其中一台机器一定是 $i$ 这个位置执行，所以可以省去一维状态。

```c++
void solve()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)cin >> a[i];
	for (int i = 1; i <= m; i ++)cin >> c[i];
	for (int i = 1; i <= m; i ++)cin >> h[i];
	for (int i = 1; i <= n; i ++){
		for (int j = 1; j <= n; j ++)f[i][j] = 1e18;
	}
	f[1][0] = c[a[1]];
	for (int i = 1; i <= n; i ++){
		for (int j = 0; j < i - 1; j ++){
			f[i][j] = f[i - 1][j] + (a[i] == a[i - 1] ? h[a[i]] : c[a[i]]);
		}
		for (int j = 0; j < i - 1; j ++){
			f[i][i - 1] = min(f[i][i - 1], f[i - 1][j] + (a[i] == a[j] ? h[a[i]] : c[a[i]]));
		}
	} 
	LL ans = 1e18;
	for (int i = 0; i <= n; i ++)ans = min(ans, f[n][i]);
	cout << ans << "\n";
}
```

### 7.逆向思维dp

**题目链接：** https://codeforces.com/contest/1808/problem/E1

**题目描述：** 给三个整数 $n$, $k$, $m$， 分别表示数字的位数，基数和要取模的数字，计算一共个长度为 $n$ 的数字在 $k$进制下面满足 $(sum - x)\mod k == x$, 即是否存在某一位它的数字是剩余数字的和对 $k$ 取模后的值。

**思路分析：**首先我们可以确定如果某个数字满足 $2 * x \mod k == sum \mod k$ ，那么就有他可以满足条件，但是对于一个数字可能存在多个位置满足这个条件，那么我们如果dp的话就会造成重复计算，所以我们逆向思考这道题目，我们枚举 $s$，对于所有数字可以满足上面条件的加入 $ban$ 中，然后再用dp，$f[i][j]$表示枚举到第 $i$ 个位置，当前总和为 $j$ 的方案数。总的方案数就是没有限制情况对于每个 $s$ 计算即可再减去不合法的方案。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1e5 + 10;
int n, m, k;
int get(int s, int ban){
	vector<vector<LL>>f(n + 1, vector<LL>(k + 1, 0));
	f[0][0] = 1;
	for (int i = 1; i <= n; i ++){
		for (int j = 0; j < k; j ++){
			for (int x = 0; x < k; x ++){
				if(ban >> x & 1)continue;
				f[i][(j + x) % k] = (f[i][(j + x) % k] + f[i - 1][j]) % m;
			}
		}	
	}
	return f[n][s];
}
void solve(){
	cin >> n >> k >> m;
	LL ans = 0;
	for (int i = 0; i < k; i ++){
		int ban = 0;
		for (int j = 0; j < k; j ++){
			if(2 * j % k == i)ban |= 1 << j;
		}
		ans = (ans + get(i, 0) - get(i, ban) + m) % m;
	} 
	cout << ans << "\n";
}
int main(){
	ios :: sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
	
	return 0;
}
```

### 8.思维dp

**题目描述：** https://codeforces.com/contest/1798/problem/E

**题目描述：** 如果一个数组的第一个元素等于这个数组的长度-1，那么这个数组就是一个好数组。现在有一个数组，第一个元素是后面要分成的组数，且每一组都要是好数组，那么这个数组是一个多重集，问对于 $i = 1:n$，$f[i, i + 1, ……， n]$ 要修改多少个数字才能称为一个多重集。

**思路分析：**不难发现最多会修改两次，即将 $i$ 修改成 1, 将 $i + 1$ 修改成 后面的数组长度，下面考虑0或者1的情况，我们倒叙枚举，用 $f[i][0]$ 表示枚举到第 $i$ 个数字，不进行修改能形成的组数，$f[i][1]$ 表示从 $i到n$ 修改一次能形成的最多组数，因为如果 $a[i - 1] <= f[i][1]$，那么修改一次一定能达到要求。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1e5 + 10;
int n, m, k;
void solve(){
	cin >> n;
	vector<int>a(n + 1);
	vector<vector<int>>f(n + 2, vector<int>(2, -1));
	f[n + 1][0] = f[n + 1][1] = 0;
	for (int i = 1; i <= n; i ++)cin >> a[i];
	int mx = 0;
	for (int i = n; i >= 1; i --){
		if (i + a[i] + 1 > n + 1)f[i][1] = mx + 1;
        else{
            if (f[i + a[i] + 1][0] != -1){
                f[i][0] = f[i + a[i] + 1][0] + 1;
            }
            f[i][1] = max(mx + 1, f[i + a[i] + 1][1] + 1);
        }
        if (f[i][0] != -1) mx = max(mx, f[i][0]);
	}
	for (int i = 1; i < n; i ++){
		if(f[i + 1][0] == a[i])cout << 0 << " ";
		else if(f[i + 1][0] != -1 || f[i + 1][1] >= a[i]){
			cout << 1 << " ";
		}
		else cout << 2 << " ";
	}
	cout << "\n";
}
int main(){
	ios :: sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	cin >> T;
	while(T --) solve();
	
	return 0;
}
```

### 9.倍增优化dp解决区间询问问题

**题目链接：** https://ac.nowcoder.com/acm/contest/23106/B

**题目描述：** 一个比赛有三种状态赢、输、平，有一个特殊规则，如果目前分数是3的整数倍，那么下一句如果输的话不扣分，给 $q$ 个询问，对于每个询问给出一段区间和初始分，求最终分。

**思路分析：** 对于区间询问的问题，可以考虑线段树或者ST表，本题我们设 $f[k][i][j]$表示从 $i$ 开始，长度为 $2^j$ 的区间，当前总分是 $k$ 之后的总分，利用倍增即可处理答案。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
int a[N], f[3][N][25];
void solve(){
	cin >> n >> m;
	string s;cin >> s;
	s = " " + s;
	auto mod3 = [&](int x){
		return (x % 3 + 3) % 3;
	};
	for (int j = 0; j <= 20; j ++){
        for (int i = 1; i + (1 << j) - 1 <= n; i ++){
            if(!j){
                if(s[i] == 'W'){
                    f[0][i][j] = f[1][i][j] = f[2][i][j] = 1;
                }
                if(s[i] == 'L'){
                    f[1][i][j] = f[2][i][j] = -1;
                    f[0][i][j] = 0;
                }
                if(s[i] == 'D'){
                    f[0][i][j] = f[1][i][j] = f[2][i][j] = 0;
                }
            }
            else{
                int p1 = i, p2 = i + (1 << (j - 1));
                f[0][p1][j] = f[0][p1][j - 1] + f[mod3(0 + f[0][p1][j - 1])][p2][j - 1];
                f[1][p1][j] = f[1][p1][j - 1] + f[mod3(1 + f[1][p1][j - 1])][p2][j - 1];
                f[2][p1][j] = f[2][p1][j - 1] + f[mod3(2 + f[2][p1][j - 1])][p2][j - 1];
            }
        }
    }
    while(m --){
		int l, r, ans;cin >> l >> r >> ans;
        for (int j = 20; j >= 0; j --){
        	if(l + (1 << j) - 1 <= r){
        		ans += f[ans % 3][l][j];
        		l += (1 << j);
			}
		}
        cout << ans << "\n";
	}
} 
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 10.单调不减有范围要求dp

**题目链接：** https://ac.nowcoder.com/acm/contest/23477/M

**题目描述：** 有一个长度为 $n$ 的数组，选择某个数字必须保证下面两个条件：

1.这个数字必须不小于之前的数字。 2.上一个被选的数字的下标必须是在$[i - b[i], i - 1]$之间，当然如果第一个被选择没有这个要求。 求一共有多少种不同的选法。

**思路分析：** 本题有两个要求，一个是要保证单调不减，对上一个数字还有要求，所以实际上就是一个区间查询问题，那么我们需要考虑如果保证这个数字一定大于等于之前的数字，我们可以考虑按照数字排序，然后用树状数组维护每个下标的值进行计算即可。

```c++
int a[N],b[N], f[N], tr[N];
int lowbit(int x){return x & -x;}
void add(int x, int v){
	for (int i = x; i <= n; i += lowbit(i))tr[i] = (tr[i] + v) % mod;
}
int ask(int x){
	int sum = 0;
	for (int i = x; i; i -= lowbit(i)){
		sum = (sum + tr[i]) % mod;
	}
	return sum;
}
void solve(){
    scanf("%d %d",&n, &m);
	srand(m);
	vector<PII>v(n + 1); 
	for(int i = 1; i <= n; i ++){
		a[i] = read(0), b[i] = read(i);
		v[i] = {a[i], i};
	}
	sort(v.begin() + 1, v.end());
	LL ans = 0;
	for (int i = 1; i <= n; i ++){
		LL sum = (ask(v[i].y - 1) - ask(v[i].y - b[v[i].y] - 1) + 1 + mod) % mod;
		add(v[i].y, sum);
	}
	cout << ask(n) << "\n";
}
```

### 11.换存储值背包

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7140

**题目描述：**给一个大小为 $m$ 的背包和 $n$ 个物品，每个物品有价值和体积，求是否能恰好放满，如果可以，求出物品价格的异或最大值。

**思路分析：** 涉及位运算的背包问题，很容易想到利用bitset来解决，但是如果我们按照传统思想，把体积作为维度，价值作为所求的话，bitset很难处理因为bitset不支持和整数异或操作，但是我们换一种思想，把价值作为维度，那么我们要求的是这个价值对应哪些体积可以到达，按照这个思想利用bitset就可以解决此问题。

```c++
bitset<N>f[N], g[N];
void solve(){
	cin >> n >> m;
	for(int j = 0; j < 1024; j ++){
		f[j].reset();
	}
	f[0][0] = 1;
	for(int i = 1; i <= n; i++){
		int x, y;cin >> x >> y;
		for(int j = 0;j < 1024; j ++){
			g[j] = f[j];
			g[j] <<= x;
		}
		for(int j = 0; j < 1024; j ++){
			f[j] |= g[j ^ y];
		}
	}
	for (int j = 1024; j >= 0; j --){
		if(f[j][m]){
			cout << j << "\n";
			return; 
		}
	}
	cout << -1 << "\n";
}
```

### 12.最小化极差dp

**题目链接：** https://www.acwing.com/problem/content/3426/

**题目描述：** 有 $n$ 种糖果和 $m$ 个小朋友，现在要把这些糖果全部分完，且每个小朋友至少有一个糖果，且每种糖果最多可以分两个，至少分一个，问小朋友分到的糖果重量最大值和最小值的差值是多少？

**数据范围：** $n <= 100, m <= 50, w[i] <= 100$

**思路分析：** 我们发现本题有两个状态，最大值和最小值，如果同时写入状态方程会增加空间复杂度，所以我们考虑把一个变量作为枚举变量，根据这个思路我们枚举最小值，设 $f[i][j][k]$ 表示枚举到第 $i$ 个小朋友，且这个小朋友分到的最后一个糖果编号是 $j$，且第 $i + 1$个小朋友分到的第一个糖果的编号不能大于 $k$，这里是为了保证糖果最多被分给两个人，那么考虑转移：

1.$f[i][j][k] = f[i - 1][j][k - 1]$，这里表示如果后面一个小朋友可以分到最前面的糖果为 $k - 1$，那么他一定也可以分到第 $k$ 个。

2.$f[i][j][k] = min(f[i - 1][k][p] + s[j] - s[p])$，其中 $0 <= p <= k$ 且要保证 $s[j] - s[p] >= mn$， 即大于枚举的最小值，通过这两个点我们可以发现 $f[i][j][k]$ 一定是单调不增的，因为后面转移的值一定会小于等于第1点转移而来，所以我们发现它随着 $k$ 的增大是单调不增的。这个也不难理解，因为我们并不要求所有糖果都被覆盖两次，所以当在满足当前糖果大于最小值的情况下，一定是分到的糖果越少越好，在固定最后一个糖果情况下。

```c++
void solve(){
	cin >> n >> m;
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    for (int i = 1; i <= n; i ++){
        for (int j = i; j <= n; j ++){
            st[s[j] - s[i - 1]] = true;
        }
    }
    int res = 1e9;
    for (int mn = 1; mn * m <= s[n] * 2; mn ++){
        if (!st[mn])continue;
        memset(f, 0x3f, sizeof f);
        f[0][0][0] = mn;
        for (int i = 1; i <= m; i ++){
            for (int k = 0; k <= n; k ++){
                int p = 0;
                for (int j = min(i, k); j <= n; j ++){
                    if(k > 0)f[i][j][k] = f[i][j][k - 1];
                    while(s[j] - s[p] >= mn && p <= k)p ++;
                    if(p)f[i][j][k] = min(f[i][j][k], max(s[j] - s[p - 1], f[i - 1][k][p - 1]));
                }
            }
        }
        res = min(res, f[m][n][n] - mn);
    }
    cout << res << "\n";
} 
```

### 13.动态dp(带修改dp)

**题目链接：** https://codeforces.com/contest/1814/problem/E

**题目描述：** 给定一个长度为 $n$ 的链，每一个边有一个权值，每个点上都有一个编号为 $i$ 的物品，现在要移动这些物品实现全错位排列。（即每个点上都有一个物品，且物品编号和这个点的编号不一致）。下面会给出 $q$ 个询问，每个询问给出一个 $k$ 和 $x$， 表示将第 $k$ 条边的权值修改为 $x$。

**思路分析：** 我们考虑利用 $dp$， 其中$f[i]$ 表示枚举到第 $i$ 条边，且选择第 $i$ 条边的最小价值，因为我们知道这个移动实际上可以等效为将这个链分成几个部分，中间有一些边是不选择的，他们作为连通几个联通块的桥梁，被选择的边都会被经过两次，因为被选择的连通块内所有点向他相邻的点移动，最后一个点向着起点移动。所以我们可以得到如下的转移方程： $f[i] = min(f[i - 1], f[i - 2]) + a[i]$。由于第1条边和第 $n - 1$ 条边是必选边，所以我们可以设置 $f[-1] = 0, f[0] = INF$,因为$f[0]$会影响到 $f[2]$ 及其后面的情况，所以应该注意。但是本题带修改，如果每次循环一次，一定会超时，那么我们考虑优化，这里就是动态$dp$ 的常用思想，利用线段树维护矩阵乘法。
$$
\begin{bmatrix}                     
   a[i] & a[i] \\           
   0 & INF \\
  \end{bmatrix}  \times \begin{bmatrix}                     
   f[i - 1] \\           
   f[i - 2] \\
  \end{bmatrix}=\begin{bmatrix}                     
   f[i]\\           
   f[i -1] \\
  \end{bmatrix}
$$
其中矩阵乘法相当于加法，矩阵的加法相当于取最小值。

**模板总结：** 

![1684675815519](C:/images/1684675815519-1684675817036.png)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int mod2 = 500000004, MOD2 = 499122177;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10, M = 2;
int n, m;
int a[N];
struct matrix{
	LL v[M][M];
	matrix(){
		for (int i = 0; i < 2; i ++){
			for (int j = 0; j < 2; j ++){
				v[i][j] = INF;
			}
		}
	}
	matrix operator*(const matrix &t){
		matrix res;
		for(int i = 0; i < 2; i ++){
			for (int j = 0; j < 2; j ++){
				for (int k = 0; k < 2; k ++){
					res.v[i][j] = min(res.v[i][j], v[i][k] + t.v[k][j]);
				}
			}
		}
		return res;
	}
};
struct Node{
	int l, r;
	matrix mt;
}tr[N * 4];
void pushup(int u){
	tr[u].mt = tr[u << 1].mt * tr[u << 1 | 1].mt;
}
void build(int u, int l, int r){
	if(l == r){
		tr[u] = {l, r};
		tr[u].mt.v[0][0] = tr[u].mt.v[0][1] = a[l];
		tr[u].mt.v[1][0] = 0;
		return;
	}
	tr[u] = {l, r};
	int mid = l + r >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}
void modify(int u, int x, int v){
	if(tr[u].l == x && tr[u].r == x){
		tr[u].mt.v[0][0] = tr[u].mt.v[0][1] = v;
		return;
	}
	int mid = tr[u].l + tr[u].r >> 1;
	if(x <= mid)modify(u << 1, x, v);
	else modify(u << 1 | 1, x, v);
	pushup(u);
}
matrix query(int u, int l, int r){
	if(tr[u].l >= l && tr[u].r <= r)return tr[u].mt;
	int mid = tr[u].l + tr[u].r >> 1;
	if(mid >= r)return query(u << 1, l, r);
	else if(mid < l)return query(u << 1 | 1, l, r);
	else return query(u << 1, l, r) * query(u << 1 | 1, l, r);
}
void solve(){
	cin >> n;
	for (int i = 1; i <= n - 1; i ++){
		cin >> a[i];
	} 
	build(1, 1, n - 1);
	int q; cin >> q;
	while(q --){
		int k, x; cin >> k >> x;
		modify(1, k, x);
		cout << query(1, 1, n - 1).v[0][1] * 2ll << "\n";
	}
} 
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 14.树形dp

**题目链接：** https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772845703169

**题目描述：** 给定一棵树，根节点为1，其中这棵树上有的点的颜色为黑色，有的为白色，要求修改某些节点的颜色，使得对于所有的结点来说，以它为根的子树一定满足黑色结点的个数和白色结点的个数差1。求最小代价，注意修改每个子树的代价都不相同。

**思路分析：** 考虑树形$dp$，设$f[i][3]$表示以$i$为根的子树的状态，其中0表示黑色结点和白色结点个数相同，1表示白色结点比黑色结点多1，2表示黑色结点比白色结点少1。

首先我们应该明确对于任意一个结点，一定满足它的子树结点个数为偶数的时候，只有$f[i][0]$被更新，如果它的子树结点个数为奇数的时候，只有$f[i][1]$和$f[i][2]$被更新。那么我们考虑如何进行转移。

首先，对于一个结点，它的孩子结点数量为$num$个，那么要对孩子结点进行分类讨论：如果孩子结点为根的子树大小为偶数，那么我们只需要$ans + f[son][0]$即可，如果是奇数的话，我们要保证$f[i][1]$和$f[i][2]$各占一半，也就是我们其实并不需要知道他有多少个孩子结点，我们关心的是以它的孩子结点为根的子树大小是奇数的个数，因为这里我们需要讨论，那么应该如何选择$f[i][1]$和$f[i][2]$呢？**这里是一个经典的问题，我们可以都先存储$f[i][2]$,即$ans+=f[i][2]$，然后把$f[i][1] - f[i][2]$存入到一个vector中，对vector进行排序后，从小到大加入ans**，这样就能保证各选择一半的情况下，总的代价最小。后面就是关于更新的分类讨论即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int mod2 = 500000004, MOD2 = 499122177;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
int c[N], p[N], sz[N];
vector<int>g[N];
int f[N][3];
void dfs(int u){
	int cnt = 0, ans = 0;
	vector<int>v;
	for (int i = 0; i < g[u].size(); i ++){
		int son = g[u][i];
		dfs(son);sz[u] += sz[son];
		if(sz[son] % 2){
			cnt ++; ans += f[son][2];
			v.push_back(f[son][1] - f[son][2]);
		}
		else ans += f[son][0];
	}
	sort(v.begin(), v.end());
	if(cnt % 2){
		for (int i = 0; i < cnt / 2; i ++){
			ans += v[i];
		}
		f[u][0] = min(ans + (c[u] == 1) * p[u], ans + (c[u] == 0) * p[u] + v[cnt / 2]);
	}
	else if(cnt == 0){
		f[u][1] = ans + (c[u] == 1) * p[u];
		f[u][2] = ans + (c[u] == 0) * p[u];
	}
	else {
		for(int i = 0; i < cnt / 2; i ++)ans += v[i];
		f[u][1] = min(ans + (c[u] == 1) * p[u], ans + (c[u] == 0) * p[u] + v[cnt / 2]);
		f[u][2] = min(ans + (c[u] == 0) * p[u], ans + (c[u] == 1) * p[u] - v[cnt / 2 - 1]);
	}
}
void solve(){
	cin >> n;
	vector<int>fa(n + 1);
	for (int i = 1; i <= n; i ++){
		cin >> c[i] >> p[i] >> sz[i];
		for (int j = 1; j <= sz[i]; j ++){
			int x; cin >> x;
			g[i].push_back(x);
		}
		sz[i] ++; 
	}
	memset(f, 0x3f, sizeof f);
	dfs(1);
	cout << min({f[1][0], f[1][1], f[1][2]});
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 15.括号序列（重复问题的处理）

**题目链接：** https://www.luogu.com.cn/problem/P7914

**题目描述：** 给定一个字符串，包含$( ) * <?$四种字符，现在要把$?$替换成另外三种字符的一种，使得形成一个合法的超级括号序列。一个合法的超级括号序列如下：

1.$(),(S)$都是合法的括号序列。

2.如果$A$和$B$都是合法的括号序列，那么$AB,ASB$均为合法的括号序列。

3.如果$A$是合法的括号序列，那么$(A),(AS),(SA)$也都是合法的括号序列。

4.$S$是指长度不超过$m$的由$*$构成的字符串。

**思路分析：** 本题实际就是区间$dp$问题，由于下面两种情况可能会出现重复$()()(),()*()*()$，所以我们设置四个$dp$方程，其中$f[l][r]$是指$l$到$r$这个区间中且端点恰好构成一个括号的方案数，即$(......)$这种类型。$g[l][r]$表示的是$**(),()**$即左右两边必须是星或者括号中的一个，$dp[l][r]$表示这个区间内所有合法的超级括号序列数量。由于有$ASB$,所以我们额外用一个$g1[l][r]$表示这个区间满足$()**$的个数。

```c++
int f[N][N], g[N][N], g1[N][N], dp[N][N];
void solve(){
    cin >> n >> m;
    string s; cin >> s; s = " " + s;
    for (int i = 1; i <= n; i ++)g[i][i - 1] = 1;
    vector<int>sum(n + 1);
    for (int i = 1; i <= n; i ++){
        sum[i] = sum[i - 1] + (s[i] == '?' || s[i] == '*');
    }
    for (int l = 1; l <= n; l ++){
        for (int r = l; r <= n; r ++){
            if(r - l + 1 <= m)g[l][r] = (sum[r] - sum[l - 1] == r - l + 1);
        }
    }
    for (int len = 2; len <= n; len ++){
        for (int l = 1; l + len - 1 <= n; l ++){
            int r = l + len - 1;
            if((s[l] == '(' || s[l] == '?') && (s[r] == ')' || s[r] == '?')){
                f[l][r] = (g[l + 1][r - 1] + dp[l + 1][r - 1]) % mod;
            }
            for (int k = l; k < r; k ++){
                if(r - k <= m && sum[r] - sum[k] == r - k)g1[l][r] = (g1[l][r] + dp[l][k]) % mod;
                if(k - l + 1 <= m && sum[k] - sum[l - 1] == k - l + 1)g[l][r] = (g[l][r] + dp[k + 1][r]) % mod;
            }
            g[l][r] = (g[l][r] + g1[l][r]) % mod; 
            for (int k = l; k < r; k ++){
                dp[l][r] = (dp[l][r] + 1ll * dp[l][k] * f[k + 1][r] % mod) % mod;
                dp[l][r] = (dp[l][r] + 1ll * g1[l][k] * f[k + 1][r] % mod) % mod;
            }
            dp[l][r] = (dp[l][r] + f[l][r]) % mod;
            //cerr << l << " " << r << " " << f[l][r] << " " << g1[l][r] << " " << g[l][r] << " " << dp[l][r] << "\n";
        }
    }
    cout << dp[1][n] << "\n";
}
```

### 16.dp计数——字符串计数(1)

**题目链接：** https://atcoder.jp/contests/abc299/tasks/abc299_f

**题目描述：** 给定一个字符串$S$,找到$S$的本质不同的子序列个数$TT$。

**思路分析：** 我们可以考虑$dp$方法处理，首先因为我们要找到的是不同的子序列，那么我们在统计时候很可能会出现重复比如$zzz$，那么我们在计算的时候，会算3次，这样还需要去重，较为麻烦，所以我们考虑把子序列分成前后两个部分，我们要求每个选择的字母之间的距离尽量的近，那么我们就不会重复，因为比如$ababb$在$a$之后有两个$b$可以选择，但是第一个$b$离得更近那么就选第一个，这样不会重复，其中对于第一个$T$第一个字符选择$S$中的第一个字符。

```c++
void solve(){
   string s; cin >> s;
   int n = s.size();
   s = " " + s;
   vector<int>pos(26, -1);
   vector<vector<int>>ne(n + 1, vector<int>(26));
   for (int i = n; i >= 1; i --){
      for (int j = 0; j < 26; j ++){
         ne[i][j] = pos[j];
      }
      pos[s[i] - 'a'] = i;
   }
   int ans = 0;
   for (int p = 2; p <= n; p ++){
      vector<vector<int>>f(n + 1, vector<int>(n + 1));
      int x = s[p] - 'a';
      int l = pos[x], r = p;
      f[l][r] = 1;
      for(int i = l; i < r; i ++){
         for(int j = r; j <= n; j ++){
            for(int k = 0; k < 26; k ++){
               int nl = ne[i][k], nr = ne[j][k];
               if (nl == -1 || nr == -1 || nl >= r)continue;
               f[nl][nr] = (f[nl][nr] + f[i][j]) % MOD;
            }
         }
      }
      for(int i = l; i < r; i ++){
         for(int j = r; j <= n; j ++){
            if (ne[i][x] == r){
               ans = (ans + f[i][j]) % MOD;  
            }
         }
      }
   }
   cout << ans << "\n";
}
```

### 17.dp计数——字符串计数(2)

**题目链接：** https://atcoder.jp/contests/abc301/tasks/abc301_f

**题目描述：** 给一个字符串，其中含有$?$，把这些$?$替换成一个大写字母或者小写字母，其中替换后这个字符串不能存在一个子序列使得这个子序列是$DDoS$ 型，即前两个是相同的大写字母，第三个是小写字母，最后一个是大写字母，求构造的方案数。

**思路分析：** 我们发现符合的字符串一定是下面三种中的一种且下面三种一定没有重复：

1.全部都是小写字母； 2.有至少一个大写字母，且大写字母之后没有小写字母； 3.前面的大写字母互不相同，即没有任意两个字符是出现两次，然后后面是第二种情况。

我们可以先把第一种和第二种情况预处理出来。第三种情况我们记录前面的$?$数量，用组合计数的方式即可求出答案，假设有$q$个问号，有$x$个大写字母未出现过，则我们可以枚举选$r$个大写字母，那么就是$C(q, r) * C(x, r) * fac[r] * 26^{q - r}$。

```c++
void solve(){
    string s; cin >> s;
    int n = s.size();
    s = " " + s;
    vector<vector<int>>f(n + 2, vector<int>(2));
    auto g = [&](char c, int op){
        if(c >= 'A' && c <= 'Z')return op;
        else if(c == '?')return 26;
        else return (op ^ 1);
    };
    f[n + 1][0] = 1;
    for (int i = n; i >= 1; i --){
        f[i][0] = 1ll * f[i + 1][0] * g(s[i], 0) % MOD;
        f[i][1] = 1ll * (f[i + 1][0] + f[i + 1][1]) % MOD * g(s[i], 1) % MOD;
        //cerr << f[i][0] << " " << f[i][1] << "\n";
    }
    int ans = (f[1][0] + f[1][1]) % MOD;
    unordered_set<char>ha;
    int q = 0;
    for (int i = 1; i <= n; i ++){
        int sum = 0;
        int sz = ha.size();
        for (int j = 0; j <= min(26 - sz, q); j ++){
            sum = (sum + 1ll * C(q, j) * C(26 - sz, j) % MOD * fac[j] % MOD * p[q - j]) % MOD;
        }
        ans = (ans + 1ll * sum * g(s[i], 0) % MOD * f[i + 1][1] % MOD) % MOD;
        if(s[i] == '?')q ++;
        else if(s[i] >= 'A' && s[i] <= 'Z'){
            if(ha.count(s[i]))break;
            ha.insert(s[i]);
        }
    }
    cout << ans << "\n";
} 
```

### 18.数位统计dp——统计众数

**题目链接：** https://codeforces.com/gym/104337/problem/B

**题目描述：** 计算$L$到$R$这个范围内所有数字出现次数最多的数字的次数之和。如$f(113)=2$。

**思路分析：** 数位统计$dp$，如果按照常规思路我们枚举每个数位出现的次数，那么状态数量较多，本题只要求求出每个数字出现最多的数字出现多少次，并不要求求出众数是谁，所以我们设状态$S={b[1],b[2], ……, b[18]}$各出现多少次，经过暴力$dfs$能够发现答案状态只有$1477$个，那么根据这个思路我们可以用$S$来表示状态。我们设$f[pos][S]$表示枚举到第$pos$个位置，且从$pos-len$这一段数字出现的状态为$S$。对于后面的更新，我们实际上只要考虑同等情况下的$dfs$就可以了，假设目前$limit==0$即没有限制了，举一个例子假设目前已经遍历到的数字是$123xxx$，对于后面的$x$它是$0-9$都可以取得的，那么我们就可以统计出目前是$123$的情况下后面数字任意取值时众数的次数的和。我们再考虑如果再次遍历到$f[pos][S]$是否可以记忆化，因为当$S$确定后，后面的数字任意取值，那么答案一定是确定的，例如$123xxx$和$456xxx$是同样的众数出现次数最大值，所以是可以记忆化的。

**重点分析：** 数位统计$dp$设置的状态是$f[pos][S]$表示从最高位枚举到$pos$这个位置的时候，状态是$S$这个情况下的答案$(例如方案数等)$。注意数位统计$dp$可以分成两部分看，一个是普通的$dfs$，是为了处理后面，还有一个是记忆化部分，记忆化要求当达到这个状态的时候，后面无论怎么取值都是一样的答案。

```c++
int n, m;
int a[N], len;
int cnt[N];
using state = array<int, 19>;
map<state, LL>f[19];
state get() {
    state S{};
    for (int i = 0; i < 10; i++) {
        S[cnt[i]]++;
    }
    return S;
}
LL dfs(int pos, int limit, int lead){
    auto S = get();
    if(!pos){
        if(lead)return 1;
        else {
            for (int i = 18; i >= 0; i --){
                if(S[i])return i;
            }
        }
    }
    if(!limit && !lead && f[pos].count(S))return f[pos][S];
    int up = limit ? a[pos] : 9;
    LL sum = 0;
    for (int i = 0; i <= up; i ++){
        if(lead && !i){
            sum += dfs(pos - 1, limit && i == up, 1);
        }
        else {
            cnt[i] ++;
            sum += dfs(pos - 1, limit && i == up, 0);
            cnt[i] --;
        }
    }
    return (!limit && !lead) ? f[pos][S] = sum : sum;
}
LL cal(LL x){
    len = 0;
    while(x)a[++ len] = x % 10, x /= 10;
    return dfs(len, 1, 1);
}
void solve(){
    LL l, r;cin >> l >> r;
    LL ans = 0;
    if(r == 1e18)ans += 18, r--;
    ans += cal(r);
    if(l)ans -= cal(l - 1);
    cout << ans << "\n";
}
```

### 19.数位统计dp与LIS结合问题

**题目链接：** https://vjudge.net/problem/HDU-4352

**题目描述：** 求$L$到$R$这个区间内所有数字有多少个数字的最长上升子序列的长度为$k$

**思路分析：** 首先数位统计$dp$问题都具有比较明显的特征，那么我们思考如何维护$dp$状态，首先如果要求到目前为止的最长公共子序列我们可以利用$LIS$问题的二分的方法，即我们利用$LIS$的思想，我们维护每个位置能够出现的最小值，注意这里的每个位置并不一定就是$LIS$问题的一种方案，但是它一定是最优解，由于数字的个数只有10个，所以我们可以维护一个二进制状态压缩来表示当前的$LIS$方法产生的集合是哪些数字构成的，由于本题是多组样例，所以我们可以再加一个$k$即题目中的$k$这个状态又可以进行记忆化部分。

```c++
LL f[N][M][12];
int change(int state, int x){
    for (int i = x; i <= 9; i ++){
        if(state >> i & 1){
            //找到第一个大于它的数字，用这个数字代替那个数字
            state ^= (1 << i);
            break;
        }
    }
    state |= (1 << x);
    return state;
}
LL dfs(int pos, int state, int limit, int lead){
    if(!pos){
        auto check = [&](int st){
            int cnt = 0;
            for (int i = 0; i < 10; i ++){
                if(st >> i & 1)cnt ++;
            }
            return cnt == k;
        };
        if(check(state))return 1;
        else return 0;
    }
    if(!limit && !lead && f[pos][state][k] != -1)return f[pos][state][k];
    int up = limit ? a[pos] : 9;
    LL ans = 0;
    for (int i = 0; i <= up; i ++){
        if(!i && lead){
            ans += dfs(pos - 1, state, limit && i == up, 1);
        }else{
            ans += dfs(pos - 1, change(state, i), limit && i == up, 0);
        }
    }
    return (!limit && !lead) ? f[pos][state][k] = ans : ans;
}
LL cal(LL x){
    len = 0;
    while(x)a[++ len] = x % 10, x /= 10;
    return dfs(len, 0, 1, 1);
}
void solve(){
    LL l, r;
    cin >> l >> r >> k;
    cout << cal(r) - cal(l - 1) << "\n";
}
```

### 20.枚举数值dp—前缀gcd之和

**题目链接：** https://codeforces.com/contest/1614/problem/D1

**题目描述：** 给一个数组，可以通过将数组元素重排，从而使得$\sum_{i=1}^{n}gcd(a_1, a_2, ……, a_n)$最大，求最大值。

**思路分析：** 考虑$dp$，设$f[i]$表示重排后$gcd$最大值为$i$，那么最大值的一段一定是排在最前面的，后面的$gcd$一定是$i$的约数，因此我们可以通过统计$cnt[i]$表示数组中是$i$的倍数的个数，那么我们可以得到转移方程
$$
f[i] = max(f[i], f[j] + cnt[j] * (j - i))
$$
公式推导的方法：因为$f[i]$表示的是这个数组中最大公约数为$i$时的和的最大值，而$j$是$i$的倍数，那么前面一段有$cnt[j]$个$j$，那么$f[j] = cnt[j] *j$，考虑后面一段的$gcd$，可以通过$f[i]$得出，也就是把$cnt[j] * i$减去后，后面的值就是最大公约数为$j$的情况下的和。所以可以得到上面的转移方程。

```c++
void solve(){
    cin >> n;
    vector<int>a(n + 1), cnt(M);
    for (int i = 1; i <= n; i ++){
        cin >> a[i];
        cnt[a[i]] ++;
    }
    for (int i = 1; i < M; i ++){
        for (int j = i + i; j < M; j += i){
            cnt[i] += cnt[j];
        }
    }
    vector<LL>f(M);
    f[1] = n;
    LL ans = 0;
    for (int i = 1; i < M; i ++){
        for (int j = i + i; j < M; j += i)
            f[j] = max(f[j], 1ll * cnt[j] * (j - i) + f[i]);
        ans = max(ans, f[i]);
    }
    cout << ans << "\n";
}
```

### 21.根据范围优化的dp方案数问题

**题目链接：** https://codeforces.com/contest/1845/problem/E

**题目描述：** 给定$n$个盒子和$m$个球，其中每个盒子最多一个球，现在一次操作可以移动盒子里的球到相邻的盒子，问恰好操作$k$次的情况下，能有多少中不同的排列。

**数据范围：** $m<=n<=1500$

**思路分析：**恰好$k$次操作较难直接进行分析，我们考虑另一种$dp$思路，$f[i][j][k]$表示枚举到第$i$个盒子，此时前$i$个盒子中恰好有$j$个球，且操作到这种排列，**最少**需要$k$次操作，因此最后答案就是从$0-k$中所有与$k$有相同的奇偶性的$f[n][m][k]$相加。最少操作那么就一定从原排列到现在的排列球的移动轨迹没有重合，转移的方法就是两种，一个是这个格子不放球，即$f[i][j][k]=f[i - 1][j][k]$，或者将第$x$个球从他初始位置移动到第$i$个箱子，即$f[i][j][k]=f[i - 1][j - 1][k - need]$,其中$need$是从初始位置到现在需要移动的次数。由于我们求的是最少次数，那么也一定移动的是当前排列下离$i$这个位置最近的一个球，那么我们考虑如果初始的时候他的前缀和是$S$,那么之后它的前缀和一定是在$(S-\sqrt{k},S+\sqrt{k})$，因为我们可以知道从后面或者前面移动$x$个球，那么要操作的步数最少是$1+2+3+……+x$，所以前缀和的变化最多是$\sqrt{k}$，因此利用这个我们可以把时间复杂度优化到$O(nk^{\frac{3}{2}})$。

```c++
void solve(){
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1), s(n + 1);
    int cnt1 = 0;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        cnt1 += (a[i] == 1);
    }
    if (cnt1 > n / 2){
        for(int i = 1; i <= n; i++){
            a[i] ^= 1;
        }
    }
    for(int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
    const int B = 60;
    vector<int> pos;
    for(int i = 1; i <= n; i++){
        if (a[i]){
            pos.push_back(i);
        }
    }
    const int S = pos.size();
    vector<vector<int>> dp(S + 1, vector<int>(k + 1));
    dp[0][0] = 1;
    for(int i = 1; i <= n; i++){
        int r = min(min(i, S), s[i] + B);
        int l = max(1, s[i] - B);
        for(int j = r; j >= l; j--){
            int need = abs(pos[j - 1] - i);
            for(int t = k; t >= need; t--){
                dp[j][t] = (dp[j - 1][t - need] + dp[j][t]) % mod;
            }
        }
    }

    int ans = 0;
    for(int i = k; i >= 0; i -= 2){
        ans = (ans + dp[S][i]) % mod;
    }
    cout << ans << "\n";
}
```

### 22.树形结构处理括号序列

**题目链接：** https://ac.nowcoder.com/acm/contest/60282/H

**题目描述：** 给一个由$'('$和$')'$构成的括号序列，定义一个括号序列的价值为 ：每次操作选择一对相邻的括号对（只能是$"()"$，但不能是$")("）$，将其删除，该操作的代价为这个括号对右边的')'字符数量。持续这个操作，将该字符串变成空串的最小代价之和，即为原字符串的权值。例如$"()()"$是权值为0（先删除右边的那对括号，再删除左边的），而$"(())"$的权值为1。对于非匹配的字符串，权值为0。 计算所有的子串的价值之和。

**思路分析：** 首先计算价值的得到的两种方式：

1. 在一个合法括号串两侧加一对括号，例如，$(()())$。这种生成括号的方式，会使得内部每个括号对的权值加1，外部那个括号的权值为0。
2. 将两个合法的括号串拼接，例如，$(())()$。这种生成括号串的方式，即将两个括号串的权值求和。

那么我们要计算所有的子串价值，就是要计算所有的括号的贡献是多少，我们根据上面的价值产生方法可以建立一棵树，每个括号内部的括号即为它的儿子，这意味着我们必须选取同一棵树的统一层结点才能是一个合法的括号序列，这时候的括号才有价值，因此我们计算这个括号的价值就是所有儿子结点的价值再加上儿子结点的个数，因为在外面增加一个括号对应内部所有括号权值+1，我们只需要计算同一层左右边各有多少个结点，然后乘起来即可知道这个括号在多少个子串中起作用。

```c++
void solve(){
   string s; cin >> s;
   s = ')' + s;
   int n = s.size();
   stack<int>st;
   st.push(0);
   int cnt = 0;
   vector<vector<int>>g(n);
   vector<int>vis(n);
   vector<Z>sz(n), dp(n);
   for(int i = 1; i < n; i ++){
      if(s[i] == '('){
         cnt ++;
         st.push(i);
      } else {
         cnt --;
         if(cnt < 0){
            cnt = 0;
            st.pop();
            st.push(i);
            continue;
         }
         int u = st.top();
         st.pop();
         int v = st.top();
         g[u].push_back(v);
         g[v].push_back(u);
      }
   }
   Z res = 0;
   auto dfs = [&](auto &self, int u, int fa) -> void{
      vis[u] = 1;
      sz[u] = 1;
      for(auto j : g[u]){
         if(j == fa)continue;
         self(self, j, u);
         sz[u] += sz[j];
      }
      int sum = 0;
      for(auto j: g[u]){
         if(j == fa)continue;
         sum ++;
         dp[u] += sz[j] + dp[j];
      }
      int left = 0;
      for(auto j: g[u]){
         if(j == fa)continue;
         res += 1ll * dp[j] * (left + 1) * (sum - left);
         left ++;
      }
   };
   for(int i = 0; i < n; i ++){
      if(!vis[i])dfs(dfs, i,-1);
   }
   cout << res << "\n";
}
```

### 23.区间dp

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7277

**题目描述：** 有$n$张卡片排成一列，刚开始时所有的卡片等级都为1，卡片有多种种类，可以合并相邻的两个同等级同类型的卡片把他们合成较高级别**（级别+1）**，然后可以出售卡片，一个卡片的价值是$P^{R-1}*V$，其中$P$是一个常数，$R$是等级，$V$是这个类型的卡片的价值，求通过合并和出售后所有卡片的价值之和。

**思路分析：** 由于数据范围比较小，可以采用区间$dp$，我们设$dp[l][r][x][k]$表示$[l, r]$这个区间内部只有一张牌，且这个牌的类型为$x$等级为$k$的最大收益，我们用$f[l][r][0][0]$表示答案状态。

下面考虑转移，首先是等级为1的时候的转移，我们可以枚举$[l, r]$内所有的点，$f[l][r][a[k]][1] = min(f[l][k - 1][0][0] + f[k+ 1][r][0][0]+a[k])$，其中注意$k<=r$因为$k$也可以取右端点，所以要注意初始化$f[l][l - 1][0][0]=0$。

现在考虑低等级转化为高等级的转移直接枚举等级$j$和这一段区间仅剩的一张牌的位置即可，

$f[l][r][a[k]][j] = max(f[l][r][a[k]][j], f[l][k][a[k]][j - 1] + f[k + 1][r][a[k]][j - 1])$。

最后是答案状态的转移，$f[l][r][0][0]$这个可以由两种更新，一种是枚举$k$，将$f[l][k][0][0]+f[k+1][r][0][0]$加起来，另一种是枚举物品种类和等级，类似于等级1的转移。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int inf = 2e18;
void solve() {
    int n, m, d, p; 
    cin >> n >> m >> d >> p;
    int x = log2(n) + 1;
    d = min(d, x);
    vector<int>a(n + 1), v(m + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++) {
        cin >> v[i];
    }
    vector<vector<vector<vector<int>>>>f(n + 2, vector<vector<vector<int>>>(n + 2, vector<vector<int>>(m + 1, vector<int>(d + 1, -inf))));
    vector<int>P(d + 1, 1);
    for (int i = 1; i <= d; i++) {
        P[i] = P[i - 1] * p;
    }
    for (int i = 1; i <= n; i++) {
        f[i][i][0][0] = v[a[i]];
        f[i][i][a[i]][1] = 0;
        f[i][i - 1][0][0] = 0;//1级卡片转移时的边界情况
    }
    f[n + 1][n][0][0] = 0;
    for (int len = 2; len <= n; len++) {
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            //低级合并为高级
            for (int k = l; k < r; k++) {   
                for (int j = 1; j <= d; j++) {
                    f[l][r][a[k]][j] = max(f[l][r][a[k]][j], f[l][k][a[k]][j - 1] + f[k + 1][r][a[k]][j - 1]);
                }
            }
            //1级卡片
            for (int k = l; k <= r; k++) {
                f[l][r][a[k]][1] = max(f[l][r][a[k]][1], f[l][k - 1][0][0] + f[k + 1][r][0][0]);
            }
            //[l, r]全部出完后的收益
            for (int k = l; k < r; k++) {
                f[l][r][0][0] = max(f[l][r][0][0], f[l][k][0][0] + f[k + 1][r][0][0]);
            }
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= d; j++) {
                    f[l][r][0][0] = max(f[l][r][0][0], f[l][r][i][j] + v[i] * P[j - 1]);
                }
            }
        }
    }
    cout << f[1][n][0][0] << '\n';
}
signed main(){
   ios::sync_with_stdio(false);
   cin.tie(0), cout.tie(0);
   cout << fixed << setprecision(10);
   //init();
   
   int T = 1;
   cin >> T;
   while(T --) solve();
   
   return 0;
}
```

### 24.线性dp

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7296

**题目描述：** 有$n$个人，小明要选其中几个人作为他的朋友，其中要求每$m$个人中有两个他的朋友，和每个人交朋友有一个代价为$a[i]$，求最小代价之和。

**思路分析：** 设$f[i][j ]$表示目前最后一个选的朋友是第$i$个朋友，其中倒数第二个朋友距离最后一个朋友为$j$，那么我们考虑转移，首先确定倒数第三个朋友的可能位置，由于每$m$个人就需要有两个朋友，所以$k>=i-m$，所以可以得到第三个朋友的下标应该是$i -m<=k<=i-j$。所以我们就可以得到转移方程是$f[i][j]=min(f[i-j][j-k])+a[i]$，其中最小值部分可以通过前缀和优化得到。

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    vector<int>a(n + 1);
    vector<int>mod(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        mod[i] = i % m;
    }
    vector<vector<int>>f(m + 1, vector<int>(m + 1, inf));
    vector<vector<int>>pre(m + 1, vector<int>(m + 1, inf));
    for (int i = 2; i <= m; i++) {
        for (int j = 1; j < i; j++) {
            int x = mod[i];
            f[x][j] = a[i] + a[i - j];
            pre[x][j] = min(pre[x][j - 1], f[x][j]);
        }
    }
    for (int i = m + 1; i <= n; i++) {
        for (int j = 1; j < m; j++) {
            int k = m - j;
            int x = mod[i], y = mod[i - j];
            f[x][j] = pre[y][k] + a[i];
            pre[x][j] = min(pre[x][j - 1], f[x][j]);
        }
    }
    int minv = inf;
    for (int i = n - m + 2; i <= n; i++) {
        for (int j = n - m + 1; j < i; j++) {
            int x = mod[i];
            minv = min(minv, f[mod[i]][i - j]);
        }
    }
    cout << minv << "\n";
}
```

### 25.计数dp

**题目链接：** https://ac.nowcoder.com/acm/contest/57357/B

**题目描述：** 有$2n$个数字，设$a, b$是两个相邻的数字，且$a$在前，如果$a>n,b>n$，则要求$a>b$，如果$a<=n, b<=n$，则要求$a<b$,如果其中一个大于$n$，一个小于$n$，则不要求，一个排列权值定义为第一个不满足条件的下标，求所有排列的权值之和。

**思路分析：** 首先就是0 1一定是交替出现的，我们设$f[i][j][0/1]$表示目前有$i$个数字小于$n$，$j$个数字大于$n$，且当前是以哪种状态结尾的，我们考虑转移$f[i+k][j][0]+=f[i][j][1]*C(n-i,k)$，其中$1$结尾同理，那么我们考虑失败的情况，我们同样考虑失败的那一段是有$k$个0，那么$ans+=f[i][j][1]*(i+j+k)*(k-1)*C(n-i,k)*(2*n-i-j-k)!$，各项的含义从左到右依次是前面的合法情况的方案数，这个失败的时候的权值，后面两项是失败的情况的方案数(理解为k个排好序后，将任意一个个数字放到最后一位，因为要求这一轮必须放k个数字，所以不合法一定发生在最后一个数字)，还有剩下的数字的排列，另一种情况同理，最后还要考虑没有失败的情况，即全部猜对。

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    Z::setMod(m);
    vector<vector<Z>>C(n + 1, vector<Z>(n + 1));
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            if(!j)C[i][j] = 1;
            else C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
        }
    }
    // cerr << 1 << "\n";
    vector<Z>fac(2 * n + 1, 1);
    for (int i = 1; i <= 2 * n; i++) {
        fac[i] = fac[i - 1] * i;
    }
    vector<vector<vector<Z>>>f(n + 1, vector<vector<Z>>(n + 1, vector<Z>(2)));
    Z ans = 0;
    f[0][0][0] = f[0][0][1] = 1;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            for (int k = 1; k <= n - i; k++) {
                f[i + k][j][0] += f[i][j][1] * C[n - i][k];
                ans += f[i][j][1] * (k - 1) * C[n - i][k] * (i + j + k) * fac[2 * n - i - j - k];
            }
            for (int k = 1; k <= n - j; k++) {
                f[i][j + k][1] += f[i][j][0] * C[n - j][k];
                ans += f[i][j][0] * (k - 1) * C[n - j][k] * (i + j + k) * fac[2 * n - i - j - k];
            }
        }
    }
    ans += (f[n][n][0] + f[n][n][1]) * 2 * n;
    cout << ans << "\n";
}
```

### 26.Kruskal重构树+树上背包

**题目链接：** https://ac.nowcoder.com/acm/contest/57360/C

**题目描述：** 有一棵$n$个结点的树，树上的结点颜色有黑白两种，其中把一个结点颜色变化需要代价$cost[i]$，这棵树的收益定义为两个不同颜色的点之间路径最大值的和，求收益—代价的最大值。

**思路分析：** 首先我们考虑如何确定两个点对之间路径的最大值，这个有两种思路一种是$lca$，一种是$kruskal$重构树，但是本题中我们考虑合并两个点的收益是这两个点之间路径的最大值，如果用$lca$离线处理的话无法实现合并过程，因此我们使用$kruskal$重构树的方法，首先我们按照边权排序，然后合并两个顶点所处的集合，这两个集合之间的最大路径一定就是当前的边权（因为本题是一棵树，所以任意两个点之间只有一个简单路径），那么收益就是两个集合中不同颜色分别相乘求和，$dp[i][j]$表示以$i$为根的子树中有$j$个是黑色的结果最大值，通过树上背包合并即可。

```c++
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    vector<int> p(n + 1);
    vector<vector<int>>dp(n + 1, vector<int>(n + 1));
    for (int i = 1; i <= n; i++) {
        cin >> p[i];
        dp[i][a[i]] = 0;
        dp[i][a[i] ^ 1] = -p[i];
    }
    vector<array<int, 3>>edge;
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edge.push_back({w, u, v});
    }
    sort(edge.begin(), edge.end());
    DSU dsu(n);
    for (auto t : edge) {
        int w = t[0], u = t[1], v = t[2];
        u = dsu.find(u), v = dsu.find(v);
        vector<int>tmp(dsu.sz[u] + dsu.sz[v] + 1, -1e18);
        for (int i = 0; i <= dsu.sz[u]; i++) {
            for (int j = 0; j <= dsu.sz[v]; j++) {
                tmp[i + j] = max(tmp[i + j], dp[u][i] + dp[v][j] + i * (dsu.sz[v] - j) * w + j * (dsu.sz[u] - i) * w);
            }
        }
        dsu.merge(u, v);
        for (int i = 0; i <= dsu.sz[u]; i++) {
            dp[u][i] = tmp[i];
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if(dsu.find(i) == i) {
            for (int j = 0; j <= n; j++) {
                ans = max(ans, dp[i][j]);
            }
        }
    }
    cout << ans << "\n";
}
```

### 27.LCP+dp

**题目链接：** CCPC2023网络预选赛A

**题目描述：** 给两个字符串 $s$ 和 $t$ ，将 $s$ 划分为 $n$ 份，使得每一份都是 $t$ 的合法前缀，合法前缀是指长度小于等于 $t$ 的长度，并且它最多只有一个位置的字母和 $t$ 前缀不同，求$\sum n^2$，其中 $n$ 为每个划分的段数。

**思路分析：** 求LCP的方法：二分+ $hash$，时间复杂度为 $O(nlogn)$。之后我们利用 $dp$ 进行转移，我们利用三个数组，分别是 $f$, $g$, $h$，分别表示 $\sum n^2$， $\sum n$，方案数，因为我们发现对于一个转移，$\sum{(n+1)^2}= \sum n^2 + \sum 2n + \sum 1$，所以分别维护几个 $dp$ 数组即可。注意转移的方式即可。

```c++
void solve(){
    string s, t;
    cin >> s >> t;
    int n = s.size(), m = t.size();

    vector<int> R(n);
    Hash hs(s), ht(t);
    for (int i = 0; i < n; i++) {
        int l = 0, r = min(n - i, m);
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(hs.get(i, i + mid) == ht.get(0, mid)) l = mid;
            else r = mid - 1;
        }
        // cerr << i << " " << l << "\n";
        if(i + l == n || l == m) {
            R[i] = i + l;
        } else if(i + l + 1 == n || l == m) {
            R[i] = i + l + 1;
        } else {
            int p1 = i + l + 1, p2 = l + 1;
            int l = 0, r = min(n - p1, m - p2);
            while(l < r) {
                int mid = l + r + 1 >> 1;
                if(hs.get(p1, p1 + mid) == ht.get(p2, p2 + mid))l = mid;
                else r = mid - 1;
            }
            R[i] = p1 + l;
        }
        R[i] += 1;
    }

    vector<Z> f(n + 2), g(n + 2), h(n + 2);
    h[0] = 1;
    h[1] = -1;
    for (int i = 1; i <= n; i++) {
        f[i] += f[i - 1] + 2 * g[i - 1] + h[i - 1];
        f[R[i - 1]] -= f[i - 1] + 2 * g[i - 1] + h[i - 1];
        f[i] += f[i - 1];

        g[i] += g[i - 1] + h[i - 1];
        g[R[i - 1]] -= g[i - 1] + h[i - 1];
        g[i] += g[i - 1];
        
        h[i] += h[i - 1];
        h[R[i - 1]] -= h[i - 1];
        h[i] += h[i - 1];

        // cerr << i  << " " << f[i] << " " << g[i] << " " << h[i] << "\n";
    }
    cout << f[n] << "\n";
}
```

### 28.前缀最大值优化dp

**题目链接：** https://codeforces.com/contest/1858/problem/D

**题目描述：** 给一场长度为 $n$  的 $01$串，其中 $n \leq 3000$，你可以做 $k$ 次修改，你要回答对于1到 $n$ 中所有的数，当 $a$是它的时候， $a \times l_0 + l_1$最大，其中 $l_0$ 是最长的连续的0的长度，$l_1$是最长的连续的1的长度。

**思路分析：** 首先设 $dp[i][j][k]$ 表示枚举到第 $i$ 个字符，已经修改了 $j$ 个字符，且当前字符为 $k$ 的方案数，之后我们需要正着倒着分别做一遍，然后需要求出前缀最大值，然后依次枚举分界点，求出当 0 的长度为$i$时，对应的 $1$的最大长度是多少即可，之后即可统计答案。

```c++
void solve(){
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    s = " " + s;
    vector<vector<array<int, 2>>> dp1(n + 1, vector<array<int, 2>>(k + 1));
    vector<vector<array<int, 2>>> dp2(n + 1, vector<array<int, 2>>(k + 1));
    auto get = [&](vector<vector<array<int, 2>>> &dp) {
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int t = 0; t < 2; t++) {
                    int cost = (s[i] - '0' != t);
                    if(j >= cost) {
                        dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - cost][t] + 1);
                    }
                }
            }
        }
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int t = 0; t < 2; t++) {
                    if(i >= 1)dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j][t]);
                    if(j >= 1)dp[i][j][t] = max(dp[i][j][t], dp[i][j - 1][t]);
                }
            }
        }
    };
    get(dp1);
    reverse(s.begin() + 1, s.end());
    get(dp2);
    vector<int> f(n + 1, -1e9);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= k; j++) {
            for (int t = 0; t < 2; t++) {
                int mx1 = dp1[i][j][t];
                int mx2 = dp2[n - i][k - j][t ^ 1];
                if(t) {
                    f[mx2] = max(f[mx2], mx1);
                } else {
                    f[mx1] = max(f[mx1], mx2);
                }
            }
        }
    }
    vector<int> ans(n + 1);
    for (int i = 0; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            ans[j] = max(ans[j], i * j + f[i]);
        }
    }
    for (int i = 1; i <= n; i++) {
        cout << ans[i] << " \n"[i == n];
    }
}
```

### 29.优化暴力dp技巧

**题目链接：** https://codeforces.com/contest/1859/problem/E

**题目描述：** 给两个个长度为 $n$ 的数组，从这里面选择一些不相交的段，使得段的总长为 $k$，且段的价值之和最大，其中一段的价值定义为 $|a[l]-b[r]| + |a[r]-b[l]|$。

**思路分析：** 首先如果暴力的话我们可以定义 $dp[i][j]$ 表示枚举到第 $i$ 个物品，且已经选了 $j$ 个物品的价值最大值，那么 $dp[i][j] = dp[i-k][j - k)]+cost$，但是这个复杂度显然不行，我们考虑如何优化，首先我们思考如何去掉绝对值，我们利用 $dp[i][j] = dp[i -k][j-k] + max$，其中$max()$为四种取值， 即下面四种取值 $dp[i-k][j-k] + b_{i-k+1} + a_{i-k+1}, dp[i-k][j-k] - b_{i-k+1} + a_{i-k+1}$ 

$dp[i-k][j-k] + b_{i-k+1} - a_{i-k+1}, dp[i-k][j-k] - b_{i-k+1} - a_{i-k+1}$ 

所以我们维护四个最大值即可，同时我们发现只有当 $i-j$ 相同的时候才能转移，所以我们分别维护即可。

```c++
constexpr int dx[4] = {1, 1, -1, -1};
constexpr int dy[4] = {1, -1, 1, -1};
void solve(){
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1), b(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    vector<vector<int>> dp(n + 1, vector<int> (m + 1));
    vector<vector<int>> f(n + 1, vector<int> (4, -1e18));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= min(i, m); j++) {
            for (int k = 0; k < 4; k++) {
                f[i - j][k] = max(f[i - j][k], dp[i - 1][j - 1] + dx[k] * a[i] + dy[k] * b[i]);
            }
            dp[i][j] = dp[i - 1][j];
            for (int k = 0; k < 4; k++) {
                dp[i][j] = max(dp[i][j], f[i - j][k] - dx[k] * b[i] - dy[k] * a[i]);
            }
        }
    }
    cout << dp[n][m] << "\n";
}
```

### 30.期望dp

**题目链接：** https://ac.nowcoder.com/acm/contest/63804/E

**题目描述：** 一共有 $n$ 个人，参加 $m$ 轮抽奖活动，每次随机选择 $k$ 个人，发放奖品，如果有人连续 $d$ 轮都没有奖品，那么会给他一个奖品，问奖品的期望。

**思路分析：** 每个人是独立的，所以对于一个人分析即可，设 $f[i][j]$ 表示从第 $i$ 轮开始，现在已经连续输了 $j$ 轮，到达最后能够获得奖品的期望，利用常见倒推转移即可。

```c++
void solve()
{
    int n, m, k, d;
    cin >> n >> m >> k >> d;
    Z p = Z(k) / n;
    Z q = Z(n - k) / n;
    vector<vector<Z>> f(m + 2, vector<Z>(d + 1));
    for (int i = m; i >= 1; i--) {
        for (int j = d - 1; j >= 0; j--) {
            if(j == d - 1) {
                f[i][j] = f[i + 1][0] + 1;
            } else {
                f[i][j] = (f[i + 1][0] + 1) * p + f[i + 1][j + 1] * q;
            }   
        }        
    }
    cout << f[1][0] * n << "\n";
}
```

### 31.mex+dp

**题目链接：** https://codeforces.com/contest/1870/problem/E

**题目描述：** 给一个长度为 $n$ 的数组，可以选择几个不重合的子数组，求出他们每一个的 $mex$ 值后，求出这些 $mex$ 的异或值，求最大异或值。

**思路分析：** 首先我们考虑 $f[i][j]$ 表示 枚举到第 $i$ 个位置，且当前异或值为 $j$ 是否可以被计算到，那么我们需要枚举右端点，然后枚举左端点进行更新，这个是需要 $O(n ^ 3)$ 计算的，所以我们考虑如何优化，实际上我们考虑如果存在一个区间 $[l', r']$ 和 $[l, r]$，如果 $l' \geq l$ 并且 $r' \leq r$ 并且$mex(l', r') = mex(l, r)$，那么 $[l, r]$ 就是无效区间，所以我们考虑实际有效区间的数量，下面证明有效区间数量不超过 $n \times 2$。

 **Now let's prove that there are no more than $n \cdot 2$ irreplaceable segments. For each irreplaceable segment, let's look at the larger element of the pair $a_l, a_r$, let's assume $a_l$ is larger (the other case is symmetric). Now, let's prove that there is at most one segment where $a_l$ is the left element and $a_l \geq a_r$, by contradiction: Suppose there are at least 2 such segments, let's call their right boundaries $r_1, r_2$ ($r_1 < r_2$). Notice that $MEX(l, r_1) > a_l$, otherwise the segment $l, r_1$ would not be irreplaceable (we could remove $a_l$). Since $a_l \geq a_{r_2}$, then $MEX(l, r_1) > a_{r_2}$. It is obvious that $a_{r_2}$ appears among the elements $[a_l, \dots, a_{r_1}]$, and therefore $MEX(l, r_2-1) = MEX(l, r_2)$, which means that the segment $l, r_2$ is not irreplaceable, contradiction.** 

```c++
void solve(){
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));
    vector<vector<int>> st(n + 1, vector<int>(n + 1));
    dp[0][0] = 1;
    int ans = 0;
    for(int i = 1; i <= n; i++) {
        dp[i] = dp[i - 1];
        vector<int> v(n + 2);
        int mex = 0;
        for(int j = i; j >= 1; j--) {
            v[a[j]] = true;
            if (v[mex]){
                while(v[mex]) mex++;
                if (st[j][mex]) continue;
                st[j][mex] = true;
                for(int k = 0; k <= j; k++) {
                    if (dp[j - 1][k]){
                        dp[i][k ^ mex] = true;
                    }
                }
            }
        }
        for(int j = 1; j <= n; j++) {
            if (dp[i][j]) {
                ans = max(ans, j);
            }
        }
    }
    cout << ans << "\n";
}
```





## 四、数论与组合数学

### 1.数字重复出现的排列问题

**题目链接：**https://codeforces.com/contest/1794/problem/D

**题目描述：**给一个 $2n$个数字组成的集合，要求把这些数字组成自然数分解定理的形式，即将这些数字组成一个数字 $N=p_1^{a_1} * p_2^{a_2}*……*p_n^{a_n}$ ，使得 $p$ 均为质数，且 $a$ 均为正整数。求能组成多少个$N$？

**思路分析：** 当有 $n$ 个数字，其中有 $m_1$ 个 $a_1$，$m_2$ 个 $a_2$，$\cdots$，$m_k$ 个 $a_k$ 时，它们的不同排列数为：

$$\frac{n!}{m_1! \cdot m_2! \cdots m_k!}$$

那么本题实际上就是所有的合数包括1利用上面的式子算出$h_1!*h_2!*h_3!*……$, 对于质数利用dp求出来所有的方案数即选出$n$个质数，剩下的作为合数有多少中方案，所以本题的表达式就是
$$
\sum{\frac{n!}{a_1!*a_2!*……*a_n!*b_1!*b_2!*……*b_n!}}
$$
其中$a$是每个合数的个数，$b$是选出来后质数剩余的个数，其中本题的求解就是先预处理出来$a!$和$n!$后进行计算，求取所有质数的方案数和即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2> PII;
const int N = 4050, mod = 998244353;
int n, m, a[N];
LL f[N][N];
LL fac[N], infac[N];
int qmi(int a, int b, int p)
{
	int res = 1;
	while(b){
		if(b & 1)res = 1ll * res * a % mod;
		b >>= 1;
		a = 1ll * a * a % mod;
	}
	return res;
}
void init()
{
	fac[0] = 1, infac[0] = 1;
	for (int i = 1; i < N; i ++){
		fac[i] = fac[i - 1] * i % mod; 
		infac[i] = infac[i - 1] * qmi(i, mod - 2, mod) % mod;
	}
}
bool check(int x)
{
    if(x == 1)return false;
	for (int i = 2; i <= x / i; i ++){
		if(x % i == 0)return false;
	}
	return true;
}
void solve()
{
	init();
	cin >> n;
	unordered_map<int, int>ha, hb;
	for (int i = 1; i <= 2 * n; i ++){
		cin >> a[i];
		if(check(a[i]))ha[a[i]] ++;
		else hb[a[i]] ++;
	}
	if(ha.size() < n){
		cout << 0 << "\n";
	}
	else{
		vector<PII>v;
		int cnt = 0;
		v.push_back({0, 0});
		for (auto [x, y] : ha){
			v.push_back({x, y});
			cnt += y;
		}
		LL ans = fac[n];
		for (auto [x, y] : hb){
			ans = ans * infac[y] % mod;
		}
		f[0][0] = 1;
		for(int i = 1; i < v.size(); i ++){
        f[i][0] = f[i - 1][0] * infac[v[i][1]] % mod;
        for(int j = 1; j <= i; j ++)
            f[i][j] = (f[i - 1][j - 1] * infac[v[i][1] - 1] % mod + f[i - 1][j] * infac[v[i][1]] % mod) % mod;
    }
		ans = ans * f[v.size() - 1][n] % mod;
		cout << ans << "\n";
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(T --)solve();
	
	return 0;
}
```

### 2.辗转相除法的应用

**题目链接：** https://www.luogu.com.cn/problem/P1592

**题目描述：** 求与 $n$ 互质的第 $k$ 个数字， $n <= 10^6, k <= 10^8$

**思路分析：** 利用$gcd(a,b) = gcd(a + b, b)$，可以先把 1 到 $n$中所有的与 $n$ 互质的数算出来然后利用前面的公式，一定是存在循环关系的。即每个和 $n$ 互质的数字一定满足 $x = k * n + a$， 其中 $a$ 是小于 $n$ 和 $n$ 互质的数字。注意本题中也可以利用二分 + 容斥的思想，也就是设第 $k$ 个数字是 $x$, 那么小于 $x$ 的和 $n$ 互质的数字就可以通过 容斥原理把 $n$ 的因子全部筛去。

**常用方法：** 若已知 $lcm(a, x) = b$， 则反求 $x$ 的方法是枚举 $b$ 的所有约数，然后判断约数和 $a$ 的公约数是否为 $b$，根据这个可以求出所有的满足条件的 $x$ 的值。

```c++
void solve()
{
	cin >> n >> m;
	vector<int>a(n + 1);
	int cnt = 0;
	for(int i = 1; i <= n; i ++)
		if(__gcd(i,n) == 1)a[++ cnt] = i;
	cout << (m - 1) / cnt * n + a[(m - 1) % cnt + 1] << "\n";
}
```

### 3.概率统计方案个数问题

**题目链接：** https://pintia.cn/problem-sets/994805046380707840/exam/problems/1518582895035215872

**题目描述：** 对于一棵树所有的 $dfs$ 序中逆序对个数的总数是多少（不同的 $dfs$ 序是指对于儿子的遍历方法不同）

**思路分析：** 首先我们把这个树中的点分为两类点，第一类是存在父子关系的点，这时候父亲一定在子节点之前被遍历到，那么只需要利用树状数组统计这个的方案数即可，另一种是不存在父子关系的一对点，对于这种点，我们需要首先明确遍历到他们的 $lca$ 时有两种选择，即向着两个点的子树前进，那么他们的**概率是相同的**，尤其是这种题目$1/2$ 是一个常见的求方案数的方法，最后我们只需要统计一共有多少中 $dfs$ 序即可，总共的 $dfs$ 序即为所有儿子结点的阶乘乘在一起的个数。对于第一类结点的个数我们可以用树状数组来求解，第二类点的个数，我们这里采用的是用总共的序对个数减去第一类结点的个数，由于点的权值一定不相同，所以一定是总共的序对个数除以2.

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f, mod2 = 500000004;
const LL INF = 1e18;
const int N = 3e5 + 10;
int n, m;
vector<int>g[N];
int d[N], rv[N], p[N];
int tr[N];
int num = 1;
int lowbit(int x){return x & -x;}
void add(int x, int v){
	for (int i = x; i <= n; i += lowbit(i))tr[i] += v; 
}
int ask(int x){
	int res = 0;
	for (int i = x; i; i -= lowbit(i))res += tr[i];
	return res; 
}
void dfs(int u, int fa){
	int cnt = 0;
	rv[u] = ask(n) - ask(u);
	add(u, 1);
	for (int i = 0; i < g[u].size(); i ++){
		int v = g[u][i];
		if(v == fa)continue;
		cnt ++;
		dfs(v, u);
		d[u] += d[v];
	}
	d[u] += cnt;
	num = 1ll * num * p[cnt] % mod;
	add(u, -1);
}
void solve(){
	int r;cin >> n >> r;
	p[0] = 1;
	for (int i = 1; i <= n; i ++){
		p[i] = 1ll * p[i - 1] * i % mod;
	}
	for (int i = 1; i <= n - 1; i ++){
		int u, v;cin >> u >> v;
		g[u].push_back(v), g[v].push_back(u);
	}
	dfs(r, -1);
	LL tmp = 1ll *  n * (n - 1) % mod * mod2 % mod;
	for (int i = 1; i <= n; i ++){
		tmp = (tmp - d[i] + mod) % mod;
	}
	LL res = tmp * mod2 % mod;
	for (int i = 1; i <= n; i ++)res = (res + rv[i]) % mod;
	res = res * num % mod;
	cout << res << "\n";
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 4.容斥原理的应用

**题目链接：** https://ac.nowcoder.com/acm/contest/56825/F

**题目描述：** 有$n$个人，$m$个座位，求$n$个人坐到位置后最大间隔的数学期望。

**思路分析：** $n$个人坐后会产生$n+1$个空位，其中空位的数量为$m -n$，那么设$p$为一个合法的方案，那么$f(p)$为这个方案的最大间隔，我们需要求的答案就是$\sum_{x=1}^{n+1}xP(f(p)=x)$ ，那么这个可以等价于$\sum_{x=1}^{n+1}P(f(p)>=x)$，这个又等价于$\sum_{x=1}^{m+1}(1-P(f(p)<x)$ 。那么我们实际上就要求$f(p)<x$的方案数。

考虑利用容斥原理求解方案数，我们令$i$是间隔大于等于$x$的个数，那么就可以得到下面的方法：

![1683976343379](C:/images/1683976343379-1683976347321.png)

其中$C(m-x\times i,n)$是通过隔板法求出。这样就可以得到答案。

**重要知识点(与本题无关):** 一共有$n$中颜色，每种颜色各有$s$个，则将他们排列能得到的不同序列的数量是$\frac{(ns)!}{(s!)^k}$ .

```c++
void solve(){
    cin >> n >> m;
    LL ans = 0, sum = C(m, n);
    for (int i = 1; i <= m; i ++){
        LL res = 0;
        for (int j = 0; j * i <= m - n && j <= n + 1; j ++){
            LL sgn = (j % 2 ? -1 : 1);
            res = (res + sgn * C(n + 1, j) * C(m - i * j, n) % mod + mod) % mod;
        }
        //cerr << res << "\n";
        ans = (ans + sum - res + mod) % mod;
    }
    ans = ans * qmi(sum, mod - 2, mod) % mod;
    cout << ans << "\n";
}
```

### 5.LCM与质数个数

**题目链接：** https://codeforces.com/contest/1834/problem/E

**题目描述：** 给定一个长度为$n$的数组，求这个数组所有子段的最小公倍数构成的数组的$mex$值是多少，其中忽略0.

**思路分析：** 首先对于长度为$n$的数组，它的$mex$不可能超过$n^2$。所以我们只需要存储所有$lcm$值小于等于$n^2$的数字。接下来分析，对于一个固定的右端点，他能够形成的$lcm$值最多是几个。设对于一个固定的右端点$r$，其左端点从$1-r$时能够形成的$lcm$为$x_1, x_2, ……， x_k$，不妨设$x_1<x_2<……<x_k$，那么一定有$x_{i+1}$是$x_i$的倍数，因此$x_{i+1}\geq2\times x_i$，所以就有 $n^2\geq x \geq 2^{k-1}$，所以就有$k<=2log_2 n+1$，所以也就是每个数字为右端点的最小公倍数个数实际很少只有$log$这个数量级，因此我们可以利用暴力的方法。

**思考总结：** 经过本题代码我们可以发现$mex$一定是小于等于 $n \cdot (1 + 2 \log_2 n)$ .

```c++
void solve(){
    int n;cin >> n;
    vector<int>a(n);
    for (int i = 0; i < n; i ++){
        cin >> a[i];
    }
    int lim = 20 * n;
    set<int>st;
    vector<int>l;
    for (int i = 0; i < n; i ++){
        vector<int>nl;
        if(a[i] < lim){
            nl.push_back(a[i]);
        }
        for(auto x : l) {
            LL v = lcm(1ll * x, 1ll * a[i]);
            if (v < lim) {
                nl.push_back(v);
            }
        }
        sort(nl.begin(), nl.end());
        nl.erase(unique(nl.begin(), nl.end()), nl.end());
        l = nl;
        for (auto x : l) {
            st.insert(x);
        }
    }
    int ans = 1;
    while(st.count(ans)) {
        ans ++;
    }
    cout << ans << "\n";
}
```

### 6.excrt解决周期最早相遇（同余方程）

**题目链接：** https://ac.nowcoder.com/acm/contest/57355/L

**题目描述：** 有三个排列$a, b, c$，初始时有三个数字$x, y, z$他们都是1，现在执行下面的变化，求到达目标状态$x',y',z'$的最短时间，如无法到达输出-1。变化是每次$x, y, z$变成$a[y], b[z], c[x]$。

**思路分析：** 首先我们考虑这个变化的规律，因为三个数字互相依赖，所以较难发现一些规律，所以我们考虑能否把每个变化独立出来找到相应的求解方法。我们看对于$a$数组的变化：
$$
x\rightarrow a_y\rightarrow a_{b_z}\rightarrow a_{b_{c_x}}  
$$
我们可以发现通过三次变化后$x$变成了$a_{b_{c_x}}$,也就是只和自己有关了，所以也就形成了一种置换关系，即$f(x)=(a \circ b \circ c)_x$,置换即对于一个排列令$f(x)->x$，根据置换的定义对于一个排列，和一个给定的置换公式，一定会形成多个环。所以我们需要预处理出来三个排列对应的置换公式，然后记录每个排列所构成的多个环和他们的长度。接下来我们处理最小时间，首先我们要找到三个起始状态即$x,a_y,a_{b_x}$，然后找到三个对应的环，之后我们发现对于题目给定的$x'$，枚举三个环，到达他的时间一定是$x'$到起始状态的时间设为$t_0$，那么能够到达的时间即为$t_0+kL$,$L$为环的长度，之后对于三个状态，我们分别设计三个同余方程，利用$excrt$即可求解。

```c++
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
bool merge(LL &m1, LL &a1, LL m2, LL a2) {
    LL u, v;
    LL g = exgcd(m1, m2, u, v);
    LL m = m1 / g * m2;
    if ((a2 - a1) % g != 0) {
        return false;
    }
    LL d = (a2 - a1) / g;
    LL x = (__int128(u) * m1 * d + a1) % m;
    if (x < 0) {
        x += m;
    }
    m1 = m, a1 = x;
    return true;
}

void solve(){
    int n;
    cin >> n;
    vector<int>a(n + 1), b(n + 1), c(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> c[i];
    }
    vector<vector<int>>p(3, vector<int>(n + 1));
    for (int i = 1; i <= n; i++) {
        //求置换关系
        p[0][i] = a[b[c[i]]];
        p[1][i] = b[c[a[i]]];
        p[2][i] = c[a[b[i]]];
    }
    vector<vector<int>>pos(3, vector<int>(n + 1, -1));//在环中的位置
    vector<vector<int>>bel(3, vector<int>(n + 1, -1));//属于的环
    vector<vector<int>>len(3, vector<int>(n + 1, -1));//此点所属的环的长度
    for (int t = 0; t < 3; t++) {
        for (int i = 1; i <= n; i++) {
            if(pos[t][i] == -1){
                int cur = 0, j = i;
                while(pos[t][j] == -1){
                    bel[t][j] = i;
                    pos[t][j] = cur ++;
                    j = p[t][j];
                }
                j = i;
                for (int i = 0; i < cur; i++) {
                    len[t][j] = cur;
                    j = p[t][j];
                }
            }
        }
    }
    int q;
    cin >> q;
    while(q --) {
        int x1, y1, z1;
        cin >> x1 >> y1 >> z1;
        LL ans = -1;
        int x0 = 1, y0 = 1, z0 = 1;
        for (int t = 0; t < 3; t++) {
            if (bel[0][x0] == bel[0][x1] && bel[1][y0] == bel[1][y1] && bel[2][z0] == bel[2][z1]) {//首先判断所处的是否和初始状态一个环
                LL m1 = len[0][x0], a1 = pos[0][x1] - pos[0][x0];
                LL m2 = len[1][y0], a2 = pos[1][y1] - pos[1][y0];
                LL m3 = len[2][z0], a3 = pos[2][z1] - pos[2][z0];
                if (a1 < 0) {
                    a1 += m1;
                }
                if (a2 < 0) {
                    a2 += m2;
                }
                if (a3 < 0) {
                    a3 += m3;
                }
                if (merge(m1, a1, m2, a2)) {
                    if (merge(m1, a1, m3, a3)) {
                        LL res = t + 3 * a1;
                        if (ans == -1 || ans > res) {
                            ans = res;
                        }
                    }
                }
            }
            tie(x0, y0, z0) = make_tuple(a[y0], b[z0], c[x0]);//改变初始状态
        }
        cout << ans << "\n";
    }
}
```

### 7.球盒模型（部分可用生成函数）

#### 1.无编号的球放入无编号的盒子

​    允许为空的时候，可以通过$dp$来解决，$dp[i][j]$表示枚举到第$i$个球，现在已经选择了$j$个盒子，那么转移是类似于自然数划分的，即将一个自然数划分为$j$个自然数之和，那么$dp[i][j]=dp[i-j][j]+dp[i][j-1]$。

​    若不允许为空，那么我们可以理解为所有的盒子先放入一个球，即求$dp[i-j][j]$即可。

#### 2.无编号的球放入有编号的盒子（隔板法）

​    例将$n$个无编号的球放入$m$个有编号的盒子，每个盒子里至多$t$个球。

​    ![1691673879547](C:/images/1691673879547-1691673881139.png)

![1691673910877](C:/images/1691673910877-1691673912995.png)

#### 3.有编号的球放入无编号的盒子

​	盒子不允许为空的时候，为斯特林数，即$f[i][j]=f[i-1][j-1]+f[i-1][j]*j$，即将前$i$个球放入$j$个盒子中的方案数。若盒子允许为空，则就是斯特林数前缀和即可。

​    **扩展题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7328

​	**题目描述：** 将$n$个有编号的球放入$m$个无编号的盒子，每个盒子球不超过$k$个，求方案数。

​	**思路分析：** 我们考虑容斥，$f[i]$表示至少有$i$个盒子的求大于$k$个，那么$f[i]=C(n-k\times i-1,k-1)$。那么      答案就是$f[0]-f[1]+f[2]-f[3]+……$。

#### 4.有编号和无编号盒子的转化

注意当球是有编号的时候，转化是可以直接乘或者除以盒子数量的阶乘，当球是没有编号的，不能直接乘或者除以

### 8.更相减损术与辗转相除法转化的应用

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7311

**题目描述：** 有$n$个点用$(x, y)$表示，有$q$个询问用$(A, B)$表示，对于每个询问求出它可以变成的点个数，其中变化必须是下面两种之一：$(A + B, B)$，$(A, A +B)$。

**思路分析：** 首先它的逆变化是等效的，即可以通过变化点$(x, y) \rightarrow (x, x - y)$这样的，所以我们考虑将每个点变化过程存起来，显然若$x>y$时，$(x, y) \rightarrow (x - y, y)$，若$x<y$时，$(x, y) \rightarrow(x, y - x)$。但是当$x$和$y$相差很大的时候复杂度会很高，所以我们需要考虑优化，优化的方法是一种常见思路：将更相减损法转化为辗转相除法，比如$(11, 3)\rightarrow(8, 3)\rightarrow(5, 3)\rightarrow(2, 3)$。那么我们只需要记录$(11, 3)\rightarrow(2, 3)$。那么我们对于每个点只需要记录拐点，即$x$和$y$大小发生变化的点即可，这个是$log$级别的数量。对于询问$(A, B)$，我们可以分成如下几个部分讨论：
1.若$A$大于$B$,则我们去$map[{A\pmod B, B}]$二分找到大于$A$的值，这个是可以证明的，如果对于$(x, y)$来说，若$x>y$那么我们就会把$x$放入$map[{x \pmod y, y}]$，若$(A, B)$出现在$(x, y)$变化的路径上面，那么他一定会变成$(x \pmod y,y)$。所以成立。对于另外两种情况是可以同理得出的。

```c++
void solve(){
    int n, q;
    cin >> n >> q;
    map<PII, vector<int>>ma;
    map<PII, vector<int>>mb;
    map<int, int>mc;
    auto gcd = [&](int x, int y) -> void {
        if(x == y) {
            mc[x] ++;
            return;
        }
        while(x && y) {
            if(x > y) {
                int lx = x;
                x %= y;
                mb[{x, y}].push_back(lx);
            } else {
                int ly = y;
                y %= x;
                ma[{x, y}].push_back(ly);
            }
        }
    };
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        gcd(x, y);
    }
        for (auto &pr: ma) {
        sort(pr.second.begin(), pr.second.end());
    }
    for (auto &pr: mb) {
        sort(pr.second.begin(), pr.second.end());
    }
    while (q--) {
        int A, B;
        cin >> A >> B;
        int ans = 0;
        if (A > B) {
            auto it = mb.find({A % B, B});
            if (it != mb.end()) {
                auto &v = it->second;
                ans = v.end() - lower_bound(v.begin(), v.end(), A);
            }
        }
        else if (A == B) {
            auto it1 = ma.find({A, 0});
            if (it1 != ma.end()) {
                auto &v1 = it1->second;
                ans += v1.end() - lower_bound(v1.begin(), v1.end(), A);
            }
            auto it2 = mb.find({0, A});
            if (it2 != mb.end()) {
                auto &v2 = it2->second;
                ans += v2.end() - lower_bound(v2.begin(), v2.end(), A);
            }
            auto it3 = mc.find(A);
            if (it3 != mc.end()) {
                ans += it3->second;
            }
        }
        else {
            auto it = ma.find({A, B % A});
            if (it != ma.end()) {
                auto &v = it->second;
                ans = v.end() - lower_bound(v.begin(), v.end(), B);
            }
        }
        cout << ans << "\n";
    }
}
```

### 9.类欧公式

**题目链接：** https://ac.nowcoder.com/acm/contest/57360/C

**题目描述：** 求$1!! \times 2!! \times 3!! \times …… \times n!!$ 后导零的个数。

**思路分析：** 对于一个奇数的双阶乘乘一个偶数的双阶乘，等价于这个偶数的阶乘，又根据阶乘中的公式 ，进行求和即可。进行化简可以得到![1691416425374](C:/images/1691416425374-1691416427233.png)这里类似于类欧的形式![1691416392503](C:/images/1691416392503-1691416394575.png)可以直接根据公式求解。

```c++
__int128 floor_sum(__int128 n, __int128 m, __int128 a, __int128 b) {
    if(n == 0) return 0;
    __int128 ans = 0;
    ans += (a / m) * n * (n - 1) / 2, a %= m;
    ans += (b / m) * n, b %= m;
    __int128 y_max = a * n + b;
    ans += floor_sum(y_max / m, a, m, y_max % m);
    return ans;
}
void solve(){
    __int128 n;
    scan(n);
    __int128 ans = 0;
    if(n % 2) {
        LL p = 5;
        for (int i = 1; i <= 26; i++) {
            ans += (n / p + 1) / 2;
            p *= 5ll;
        }
    }
    LL p = 5;
    for (int i = 1; i <= 26; i++) {
        ans += floor_sum(n / 2 + 1, p, 2, 0);
        p *= 5ll; 
    }
    print(ans);
}
```





## 五、搜索与图论

### 1.DFS的应用

**题目链接：**https://www.acwing.com/problem/content/4872/

**题目描述：** 给定一个长度为n的数组，找一个非负数x，使得 max{a[i] ^ x} 最小，求出最小值。

**基本思路：** 我们发现可以通过构建一棵二叉树来求解，因为对于同一个层次最多有两种情况0和1，那么为了求解最小值，我们关心的是是否存在某一层他们是相同的，也就是某个点的子树中的某一层全是0或者全是1是最好的，这里可以利用递归来解决。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int son[2][N * 32], cnt;
int a[N];
int dfs(vector<int> c, int u)
{
    if (u < 0) return 0;
    vector<int> a, b;
    for (auto x: c)
        if (x >> u & 1)a.push_back(x);
        else b.push_back(x);
    if (!a.size() || !b.size()) return dfs(c, u - 1);
    else return min(dfs(a, u - 1), dfs(b, u - 1)) + (1 << u);
}
void solve()
{
    int res = 1e9;
    int n;scanf("%d", &n);
    vector<int>nums;
    for (int i = 1; i <= n; i ++)scanf("%d", &a[i]), nums.push_back(a[i]);
    cout << dfs(nums, 29);
}
int main()
{
    int T = 1;
    while(T --)solve();
    return 0;
}
```

### 2.最短路+dp

**题目链接：** https://codeforces.com/contest/1802/problem/F

**题目描述：** 有$n$个城市，之间有$m$条单向道路，一个人从$1$出发，要去$n$ 号点，开始时它只有$q$元钱，他可以在任意城市进行表演赚钱，其中每个城市表演赚钱为$w[i]$,求他最少要表演几次才能到达终点。

**数据范围：**$n<=800,m<=10000,q<=1e9$

**思路分析：** 先跑$n$次$dijkstra$来求每两个点之间的最短路，然后我们用一个$PII$  $a[i][j]$来表示从$1$到$i$并且在$j$表演需要表演的最小次数情况下最多剩余钱的数量，这个也是可以通过最短路实现的。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<LL, 2>PII;
const int N = 810;
const LL INF = 1e18;
vector<PII>g[N];
LL d1[N][N], a[N];
PII d2[N][N];
bool v[N][N];
int n, m, p;
struct Node
{
    int x, y;
    LL c, remain;
    bool operator<(const Node &t) const{
        if (c != t.c) return c > t.c;
        return remain < t.remain;
    }
};
void dijkstra(int st, LL d[])
{
    static bool v[N];
    for(int i = 1; i <= n; i++){
        v[i] = 0;
        d[i] = INF;
    }
    priority_queue<PII, vector<PII>, greater<PII>>q;
    d[st] = 0;
    q.push({0, st});
    while(!q.empty()){
        int t = q.top()[1];
        q.pop();
        if (v[t]) continue;
        v[t] = 1;
        for(auto [j, w] : g[t]){
            if (d[j] > d[t] + w){
                d[j] = d[t] + w;
                q.push({d[j], j});
            }
        }
    }
}
void solve()
{
	cin >> n >> m >> p;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        g[i].clear();
    }
    while(m--){
        int a, b, c;
        cin >> a >> b >> c;
        g[a].push_back({b, c});
    }
    for(int i = 1; i <= n; i++) dijkstra(i, d1[i]);
    if (d1[1][n] > INF / 2){
        cout << -1 << '\n';
        return;
    }
    if (d1[1][n] <= p){
        cout << 0 << '\n';
        return;
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            d2[i][j] = {INF, 0}, v[i][j] = 0;
    LL ans = INF;
    priority_queue<Node> q;
    q.push({1, 1, 0, p});
    while(!q.empty()){
        auto [x, y, c, remain] = q.top();
        q.pop();
        if (v[x][y]) continue;
        v[x][y] = 1;
        for(auto [j, w] : g[x]){
            LL need = max(0LL, (w - remain + a[y] - 1) / a[y]);
            LL nc = c + need;
            LL nreamin = remain + need * a[y] - w;
            int ny = a[j] > a[y] ? j : y;
            if (d1[j][n] <= nreamin){
                ans = min(ans, nc);
            }
            if (nc < d2[j][ny][0] || (nc == d2[j][ny][0] && nreamin > d2[j][ny][1]))             {
                d2[j][ny] = {nc, nreamin};
                q.push({j, ny, nc, nreamin});
            }
        }
    }
    cout << ans << '\n';
}
int main(){

    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int T;
    cin >> T;
    while(T--)solve();

}
```

### 3.限制性问题图论解决

**题目链接：** https://codeforces.com/contest/1715/problem/D

**题目描述：** 构造一个长度为 $n$ 的数组，使得它满足 $m$ 个条件，每个条件是 $a[i] | a[j] = x$ , 构造一个字典序最小的数组。

**思路分析：** 对于二进制的题目我们一般考虑采用按位枚举，因此我们先把所有的 $a$ 数组设置为全1，对于任意两个or值为0，那么这个位置一定都是0，如果是1的话需要单独考虑。如何考虑这一位为1的情况，我们可以先枚举二进制位，然后从小到大枚举第几个数字，如果所有和他相邻的点的这个位置要求是1的情况下都是1，那么这个点的这个位置就可以设置成0。

```c++
void solve() 
{
    int q;cin >> n >> q;
    for (int i = 1; i <= n; i ++)a[i] = (1 << 30) - 1;
    while (q --){
        int i, j, x; cin >> i >> j >> x;
        if (i == j){
            st[i] = 1;
            a[i] = x;
        }
        else{
            g[i].push_back({ j,x });
            g[j].push_back({ i,x });
            for (int k = 0; k <= 29; k ++)
				if ((x >> k & 1) == 0){
                	if(a[i] >> k & 1)a[i] ^= (1 << k);
                	if(a[j] >> k & 1)a[j] ^= (1 << k);
            }
        }  
    }
    for (int k = 29; k >= 0; k --){
        for (int i = 1; i <= n; i ++){
            if (st[i])continue;
            if ((a[i] >> k & 1) == 0)continue;
            bool flag = true;
            for (auto p : g[i]){
                int j = p[0], x = p[1];
                if ((x >> k & 1) == 0)continue;
                if ((a[j] >> k & 1) == 0)flag = false;
            }
            if (flag)a[i] ^= (1 << k);
        }
    }
    for (int i = 1; i <= n; i ++)cout << a[i] << " \n"[i == n];
}
```

### 4.BFS解决哈夫曼路径问题

**题目链接：** https://ac.nowcoder.com/acm/contest/53485/E

**题目描述：** 有一个 $n *m$的矩形，其中有三种图案 . , #, x，分别表示空地，不可用地，建筑，现在要构造一个 $r * c$区域的建筑，其中要求这个区域内所有的图案都是$.$，且这个区域内离 $x$ 最近的一个点的哈夫曼距离必须要小于 $d$，求有多少个区域满足要求。

**思路分析：**对于一个区域利用二维前缀和预处理这个区域的空地情况，再用多源汇最短路把所有x存入队列中，bfs一遍找到所有空地到这些点的最小距离后，再用一个二维前缀和预处理出来一个矩阵内是否有距离x小于d的点，之后枚举一遍即可，本题关键是哈夫曼长度问题可以用bfs来解决。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
const LL inf = 0x3f3f3f3f, INF = 1e18;
const int mod = 1e9 + 7, MOD = 998224353;
const int N = 1e6 + 10;
int n, m;
int a[N];
void solve()
{
    int r, c, dist;cin >> n >> m >> r >> c >> dist;
    vector<vector<int>>s1(n + 1, vector<int>(m + 1, 0));
    vector<vector<int>>s2(n + 1, vector<int>(m + 1, 0));
    vector<vector<int>>d(n + 1, vector<int>(m + 1, -1));
    queue<PII>q;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j ++){
        	char c;cin >> c;
            if(c == '.')s1[i][j] = 0;
            else s1[i][j] = 1;
            if(c == 'x'){
                d[i][j] = 0;
                q.push({i, j});
            }
        }
    }
    if(!q.size()){
        cout << 0 << "\n";
        return;
    }
    while(q.size()){
        auto t = q.front();q.pop();
        for(int k = 0; k < 4; k ++){
            int a = t[0] + dx[k], b = t[1] + dy[k];
            if(a < 1 || a > n || b < 1 || b > m || d[a][b] != -1)continue;
            d[a][b] = d[t[0]][t[1]] + 1;
            q.push({a, b});
        }
    }
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j ++){
            s1[i][j] += s1[i][j - 1] + s1[i - 1][j] - s1[i - 1][j - 1];
            s2[i][j] = s2[i - 1][j] + s2[i][j - 1] - s2[i - 1][j - 1] + (d[i][j] <= dist);
        }
    }
    int ans = 0;
    for(int i = r; i <= n; i ++){
        for(int j = c; j <= m; j ++){
            if(s1[i][j] - s1[i - r][j] - s1[i][j - c] + s1[i - r][j - c])continue;
            if(s2[i][j] - s2[i - r][j] - s2[i][j - c] + s2[i - r][j - c])ans ++;
        }
    }
   	cout << ans << "\n";
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	
	int T = 1;
	cin >> T;
	while(T --)solve();
	
	return 0;
}
```

### 5.树上差分的应用

**题目链接：** https://www.dotcpp.com/oj/problem3157.html（第十四届蓝桥杯省赛B组J题）

**题目描述：** 给一个 $n$ 个结点的无向树，和 $m$ 个点对，其中 $a[i]$ 和 $b[i]$ 互不相同，小明想知道选择哪一条边砍断后，能满足所有的 $a[i]$ 和 $b[i]$ 互不相同，输出可砍边的最大编号。

**思路分析：** 树上差分，我们把从 $a$ 到 $b$ 的边都加上1， 最后看有哪个边的和是 $m$ 即可，利用树上差分和前缀和思想就可以完成此题。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1e5 + 10;
int n, m;
vector<PII>g[N];
int a[N], b[N], d[N], s[N], id[N];
int fa[N][18];
int ans;
void bfs(int root){
    queue<int>q;
    memset(d, 0x3f, sizeof d);
    d[0] = 0, d[root] = 1;
    q.push(root);
    while(q.size()){
        int u = q.front();q.pop();
        for (int i = 0; i < g[u].size(); i ++){
            int j = g[u][i][0], idx = g[u][i][1];
            if (d[j] > d[u] + 1){
                d[j] = d[u] + 1;
                id[j] = idx;
                q.push(j);
                fa[j][0] = u;
                for (int k = 1; k <= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}
int lca(int a, int b){
    if(d[a] < d[b])swap(a, b);
    for (int i = 15; i >= 0; i --)
        if(d[fa[a][i]] >= d[b])a = fa[a][i];
    if(a == b)return a;
    for (int i = 15; i >= 0; i--)
        if(fa[a][i] != fa[b][i]){
            a = fa[a][i];
            b = fa[b][i];
        }
    return fa[a][0];
}
void dfs(int u, int fa){
	for (int i = 0; i < g[u].size(); i ++){
		int v = g[u][i][0], id = g[u][i][1];
		if(v == fa)continue;
		dfs(v, u);
		s[u] += s[v];
	}
	if(s[u] == m)ans = max(ans, id[u]);
}
void solve(){
	cin >> n >> m;
	for (int i = 1; i <= n - 1; i ++){
		int u, v;cin >> u >> v;
		g[u].push_back({v, i}), g[v].push_back({u, i});
	}
	bfs(1);
	for (int i = 1; i <= m; i ++){
		cin >> a[i] >> b[i];
		s[a[i]] ++;s[b[i]] ++;
		s[lca(a[i], b[i])] -= 2;
	}
	dfs(1, -1);
	cout << ans << "\n";
}
int main(){
	ios :: sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 6.带环的Flood Fill算法

**题目链接：** https://www.dotcpp.com/oj/problem3153.html（第十四届蓝桥杯省赛H题）

**题目描述：** 有一个 $m \times n$ 大小的格子，可以将其视为一个只包含 '0' (代表海水)和'1'(代表陆地)的二维数组，地图之外可以视为全部是海水，陆地会形成一个岛屿，但是有的岛屿可能会是一个环，环中的岛屿可以视为这个环的子岛屿，请统计一共有多少个岛屿，注意统计过程中不包括子岛屿。

**思路分析：** 本题中我们应该思考如何确定环，如果根据是否一个点被访问多次来判断环是存在问题的，我们应该逆向思考，我们应该找到所有海水可以覆盖到的范围，即最外层的海水可以到达的所有范围标记为 '2'，注意这里是8个方向。接着我们就需要进一步对所有的 ‘1’和'0'判断即可，如果是1则进入dfs，并把所有的能到达的1和0标记下来，这里就是用$flood fill$ 算法即可，难点是能够想到外层海水覆盖的范围，然后对于外层海水没有覆盖的范围说明要不然是环，要不然都是1，直接用flood fill算法即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 60;
int n, m;
char g[N][N];
void bfs1(){
    queue<PII>q;
    g[0][0] = '2';
    q.push({0, 0});
    while (!q.empty()){
        PII now = q.front();
        q.pop();
        for (int i = 0; i < 8; i++) {
            int tx = now[0] + dx[i];
            int ty = now[1] + dy[i];
            if (tx >= 0 && ty >= 0 && tx <= m + 1 && ty <= n + 1) {
                if (g[tx][ty] == '0') {
                    g[tx][ty] = '2';
                    q.push({tx, ty});
                }
            }
        }
    }
}
void bfs2(int x, int y){
    queue<PII>q;
    g[x][y] = '2';
    q.push({x, y});
    while (!q.empty()){
        PII now = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int tx = now[0] + dx[i];
            int ty = now[1] + dy[i];
            if (tx >= 1 && ty >= 1 && tx <= m && ty <= n) {
                if (g[tx][ty] == '0' || g[tx][ty] == '1') {
                    g[tx][ty] = '2';
                    q.push({tx, ty});
                }
            }
        }
    }
}
void solve(){
	cin >> m >> n;
    for (int i = 0; i <= m + 1; i ++)
    	for (int j = 0; j <= n + 1; j ++)
    		g[i][j] = '0';
    int ans = 0;
    for (int i = 1; i <= m; i ++)
        for (int j = 1; j <= n; j ++)
            cin >> g[i][j];
    bfs1();
    for (int i = 1; i <= m; i ++)
        for (int j = 1; j <= n; j ++)
            if (g[i][j] == '1'){
                ans ++;
                bfs2(i, j);
            }
    cout << ans << "\n";
}
int main(){
	ios :: sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 7.求图中任意两个点之间路径的最小值的最大值（LCA运用）

**题目链接：** https://www.luogu.com.cn/problem/P1967

**题目描述：** 有 $n$ 个城市，$m$ 个双向道路，每个道路有重量限制，给 $q$ 个询问，求每个询问货车的最大重量。

**思路分析：** 我们考虑有部分边是没有用的，因为不会走到这个上面，所以我们可以构造一个最大生成树或者最大生成森林，然后用倍增LCA求路径最小值即可，注意并查集最后用 find

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 5e4 + 10;
int n, m;
int p[N];
int d[N], fa[N][20], w[N][20];
struct edge{
	int x, y, z;
}e[N];
vector<PII>g[N];
int find(int x){
	if(p[x] != x)return p[x] = find(p[x]);
	return p[x];
}
void kruskal(){
	sort(e + 1, e + 1 + m, [&](edge &a, edge &b){
		return a.z > b.z;	
	});
	for (int i = 1; i <= m; i ++){
		int x = e[i].x, y = e[i].y;
		int pa = find(x), pb = find(y);
		if(pa != pb){
			p[pa] = pb;
			g[x].push_back({y, e[i].z});
			g[y].push_back({x, e[i].z});
		}
	}
}
void bfs(int u){
	queue<int>q;
	q.push(u);
	d[u] = 1, d[0] = 0;
	while(q.size()){
		int u = q.front();q.pop();
		for (int i = 0; i < g[u].size(); i ++){
			int v = g[u][i].x;
			if(d[v] < d[u] + 1)continue;
			d[v] = d[u] + 1;
			q.push(v);
			fa[v][0] = u, w[v][0] = g[u][i].y;
			for (int i = 1; i <= 15; i ++){
				fa[v][i] = fa[fa[v][i - 1]][i - 1];
				w[v][i] = min(w[v][i - 1], w[fa[v][i - 1]][i - 1]);
			}
		}
	}
}
int lca(int a, int b){
    if(d[a] < d[b])swap(a, b);
    int ans = 1e9;
    for (int i = 15; i >= 0; i --)
        if(d[fa[a][i]] >= d[b]){
        	ans = min(ans, w[a][i]);
        	a = fa[a][i];
		}
    if(a == b)return ans;
    for (int i = 15; i >= 0; i --)
        if(fa[a][i] != fa[b][i]){
        	ans = min({ans, w[a][i], w[b][i]});
            a = fa[a][i], b = fa[b][i];
        }
    ans = min({ans, w[a][0], w[b][0]});
    return ans;
}
void solve(){
	cin >> n >> m;
	for (int i = 1; i <= m; i ++){
		int x, y, z;cin >> x >> y >> z;
		e[i] = {x, y, z};
	}
	for (int i = 1; i <= n; i ++)p[i] = i;
	kruskal();
	memset(d, 0x3f, sizeof d);
	memset(w, 0x3f, sizeof w);
	for (int i = 1; i <= n; i ++){
		if(d[i] == inf)bfs(i);
	}
	int q;cin >> q;
	while(q --){
		int x, y;cin >> x >> y;
		if(find(x) != find(y)){
			cout << -1 << "\n";
		}
		else{
			cout << lca(x, y) << "\n";
		}
	}
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 8.LCA判断树上点是否构成一条链

**题目链接：** https://codeforces.com/contest/1702/problem/G2

**题目描述：** 给定一棵树，有 $q$ 个询问，$q<=10^5$ , 每次询问给出一个整数 $k$ 和 一个大小为 $k$ 的集合，求这个集合能够从某个点出发不重复经过边，但能到达集合中所有点，注意可以走到不属于集合中的点，但不能重复走集合中的点。

**思路分析：** 对于一个集合，如果能够不重复走到所有的点，那么他一定是一个链，那么我们可以把这个集合按照深度排序，从深度深的开始判断，如果某个点和最深的点 $LCA$ 是自己的话，那么把它标记为 $true$，之后对于剩下的点，我们找到最深的点，再把没有标记的重复标记一遍，最后判断是否所有点都被标记，并且判断这两个最深的点的 $LCA$ 是深度最浅的点的儿子结点即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
int p[N];
int d[N], fa[N][30];
vector<int>g[N];
void bfs(int u){
	queue<int>q;
	q.push(u);
	memset(d, 0x3f, sizeof d);
	d[u] = 1, d[0] = 0;
	while(q.size()){
		int u = q.front();q.pop();
		for (int i = 0; i < g[u].size(); i ++){
			int v = g[u][i];
			if(d[v] < d[u] + 1)continue;
			d[v] = d[u] + 1;
			q.push(v);
			fa[v][0] = u;
			for (int i = 1; i <= 18; i ++){
				fa[v][i] = fa[fa[v][i - 1]][i - 1];
			}
		}
	}
}
int lca(int a, int b){
    if(d[a] < d[b])swap(a, b);
    int ans = 1e9;
    for (int i = 18; i >= 0; i --)
        if(d[fa[a][i]] >= d[b]){
        	a = fa[a][i];
		}
    if(a == b)return a;
    for (int i = 18; i >= 0; i --)
        if(fa[a][i] != fa[b][i]){
            a = fa[a][i], b = fa[b][i];
        }
    return fa[a][0];
}
void solve(){
	cin >> n;
	for (int i = 0; i < n - 1; i ++){
		int u, v;cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	bfs(1);
	int q;cin >> q;
	while(q --){
		int k;cin >> k;
		for (int i = 1; i <= k; i ++)cin >> p[i];
		vector<int>st(k + 1);
		sort(p + 1, p + 1 + k, [&](int x, int y){
			return d[x] > d[y];
		});
		for (int i = 1; i <= k; i ++){
			if(lca(p[1], p[i]) == p[i])st[i] = true;
		}
		int f = 1;
		while(f <= k && st[f])f ++;
		if(f > k){
			cout << "YES" << "\n";
			continue;
		}
		for (int i = 1; i <= k; i ++){
			if(lca(p[f], p[i]) == p[i])st[i] = true;
		}
		bool flag = 1;
		for (int i = 1; i <= k; i ++)flag &= st[i];
		flag &= (d[(lca(p[1], p[f]))] <= d[p[k]]);
		cout << (flag ? "YES" : "NO") << "\n";
	}
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 9.双端队列处理每一步价值不同问题

**题目链接：** https://ac.nowcoder.com/acm/problem/230920

**题目描述：** 有一个 $n \times m$ 的地图，迷宫每一格都标有一个字母表示走到这个方格下一次的方向，现在想知道如果从 $(1, 1)$ 出发，到达 $(n, m)$ ，至少需要修改多少个地图上的点，并写出具体方案。

**思路分析：** 与 $AcWing$ 提高课双端队列BFS模板题一致思想，也就是处理修改或者不一致的时候使用到的最短路思想，本题记录主要是为了强调双端队列BFS的思想。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, -1, 1, 1, 1, -1, -1};
int dy[8] = {-1, 1, 0, 0, -1, 1, 1, -1};
char dir[4] = {'L', 'R', 'U', 'D'};
const int mod = 1e9 + 7, MOD = 998244353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 1010;
int n, m;
void solve() {
    cin >> n >> m;
    vector<string> s(n);
    for (int i = 0; i < n; i ++){
        cin >> s[i];
    }
    vector<int>pre(n * m, -1);
    vector<int>dist(n * m, -1);
    deque<array<int, 3>>q;
    q.push_back({0, -1, 0});
    while(q.size()){
        auto [u, v, d] = q.front();
        q.pop_front();
        if (dist[u] != -1)continue;
        dist[u] = d, pre[u] = v;
        int x = u / m, y = u % m;
        for (int k = 0; k < 4; k ++){
            int i = x + dx[k], j = y + dy[k];
            if(i < 0 || i >= n || j < 0 || j >= m)continue;
            if (dir[k] != s[x][y]) q.push_back({i * m + j, u, d + 1});
			else q.push_front({i * m + j, u, d});
        }
    }
    int x = n - 1, y = m - 1;
    cout << dist[n * m - 1] << "\n";
    while (x != 0 || y != 0) {
        int i = pre[x * m + y] / m;
        int j = pre[x * m + y] % m;
        for (int k = 0; k < 4; k ++){
        	if(i + dx[k] != x || j + dy[k] != y)continue;
        	if(dir[k] != s[i][j]){
        		cout << i + 1 << " " << j + 1 << " " << dir[k] << "\n";
			}
		}
		x = i, y = j;
    }
}
int main(){
	ios::sync_with_stdio(false);	
	cin.tie(0), cout.tie(0);
	cout << fixed << setprecision(10);
	//init();
	
	int T = 1;
	cin >> T;
	while(T --) solve();
		
	return 0;
}
```

### 10.处理并输出无向图的环

**题目来源：** https://codeforces.com/contest/1818/problem/D

**题目描述：** 给定一个图，要求找到一个子图是一个鱼图，鱼图定义为一个点在一个简单环中并且这个点和另外两个不在图中的点各有一条边。其中$n, m <= 2000$。

**思路分析：** 本题是处理无向环的问题，如果对于有向环我们一般采用拓扑序列，如果对于无向环，我们一般会采用并查集来实现，但是本题要求输出无向环，那么使用并查集就存在问题了，因为并查集无法输出一个简单环，这里我们考虑利用$dfs$。实质上如果一个点有四个以上的邻接点并且它在某个环中，那么就一定可以构成一个鱼图。具体思路是我们先假设删去一条$<u, v>$这个边，接着我们从$u$点$dfs$判断能否搜到$v$点，如果能搜到，那么说明存在一个环，那么我们利用$dfs$可以完成一个环的存储，但是我们还要找到两个不在这个环中的点且和$u$有连边，不能直接用$dfs$得到的$circle$进行判断，因为这个里面我们可以简化，有可能和$u$邻接的点都在$circle$里面了，所以我们需要将$circle$最小化，方法是遍历$circle$数组找到下标第二小的且和$u$邻接的点，记录它的下标，将$circle$数组缩小，根据这个思路我们就可以找到所有的点并且输出合法状态。

**时间复杂度：** 对于每一次的$dfs$，复杂度为$O(n+m)$，一共$m$条边，所以总的复杂度为$O(m\times(n+m))$。

**重要知识点(关于vector):**  如果要找到$vector$中的某一个元素，我们利用$find(v.begin(), v.end(), x)$，找不到返回$v.size()$，查找某个元素是否存在$count(v.begin(), v.end(), x)$，将$vector$取前面$len$个元素，即将$vector$大小改为$len$，$v.resize(len)$.

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;
#define x first
#define y second
int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[8] = {1, -1, 0, 0, -1, 1, 1, -1};
map<int, char>dir{{0, 'D'}, {1, 'U'}, {2, 'R'}, {3, 'L'}};
const int mod = 1e9 + 7, MOD = 998244353;
const int mod2 = 500000004, MOD2 = 499122177;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2010;
int n, m;
vector<int>g[N], cir, p;
bool st[N];
void dfs(int u, int s, int to){
    st[u] = true;
    p.push_back(u);
    if(u == to){
        cir = p;
        return;
    }
    for (auto v : g[u]){
        if(u == s && v == to)continue;
        if(st[v])continue;
        dfs(v, s, to);
    }
    p.pop_back();
}
void solve(){
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)g[i].clear();
    cir.clear();
    for (int i = 1; i <= m; i ++){
        int u, v;cin >> u >> v;
        g[u].push_back(v), g[v].push_back(u);
    }
    for (int u = 1; u <= n; u ++){
        if(g[u].size() >= 4){
            for(auto v : g[u]){
                p.clear();
                memset(st, 0, sizeof st);
                dfs(u, u, v);
                if(cir.empty())continue;
                int len = cir.size();
                for (auto x : g[u]){
                    int id = find(cir.begin(), cir.end(), x) - cir.begin();
                    if(id > 1){
                        len = min(len, id + 1);
                    }
                } 
                cir.resize(len);
                cout << "YES" << "\n";
                cout << len + 2 << "\n";
                vector<int>extra;
                for (auto x : g[u]){
                    if(count(cir.begin(), cir.end(), x) == 0){
                        extra.push_back(x);
                    }
                }
                int pre = cir.back();
                for (auto x : cir){
                    cout << pre << " " << x << "\n";
                    pre = x;
                }
                cout << u << " " << extra[0] << "\n";
                cout << u << " " << extra[1] << "\n";
                return;
            }
        }
    }
    cout << "NO" << "\n";
    return;
}
int main(){
   ios::sync_with_stdio(false);
   cin.tie(0), cout.tie(0);
   cout << fixed << setprecision(10);
   //init();
   
   int T = 1;
   cin >> T;
   while(T --) solve();
   
   return 0;
}
```

### 11.哈密顿回路解决访问顺序不定的要求点

**题目链接：** https://atcoder.jp/contests/abc301/tasks/abc301_e

**题目描述：** 给一个$n\times m$的地图，地图中有$S, o, G, .$等四种图案，要求从$S$走到$G$不超过$T$步，且获得的$o$尽量的多，求能够获得的最多的$o$的数量。$o的数量<=18$

**思路分析：** 首先我们可以用二进制枚举想要经过的$o$，并且利用哈密顿回路来进行求解，其中利用$bfs$初始化即可。

```c++
void solve(){
    int t;cin >> n >> m >> t;
    vector<vector<char>>a(n + 1, vector<char>(m + 1));
    for (int i = 1; i <= n; i ++){
        for (int j = 1; j <= m; j ++){
            cin >> a[i][j];
        }
    }
    vector<PII>v;
    string s = "SoG";
    for (auto c : s){
        for (int i = 1; i <= n; i ++){
            for (int j = 1; j <= m; j ++){
                if(a[i][j] == c){
                    v.push_back({i, j});
                }
            }
        }
    }
    int sz = v.size();
    vector<vector<int>>dist(sz, vector<int>(sz, inf));
    for (int i = 0; i < sz; i ++){
        queue<PII>q;
        q.push(v[i]);
        vector<vector<int>>d(n + 1, vector<int>(m + 1, inf));
        d[v[i].x][v[i].y] = 0;
        while(q.size()){
            auto t = q.front();q.pop();
            for (int i = 0; i < 4; i ++){
                int x = t.x + dx[i], y = t.y + dy[i];
                if(x < 1 || x > n || y < 1 || y > m || a[x][y] == '#' || d[x][y] != inf)continue;
                d[x][y] = d[t.x][t.y] + 1;
                q.push({x, y});
            }
        }
        for (int j = 0; j < sz; j ++){
            dist[i][j] = d[v[j].x][v[j].y];
        }
    }
    vector<vector<int>>dp(1 << sz, vector<int>(sz, t + 1));
    dp[1][0] = 0;
    int ans = -1;
    for (int i = 1; i < 1 << sz; i ++){
        int cnt = 0;
        for (int j = 0; j < sz; j ++){
            if(i >> j & 1)cnt ++;
        }
        if(dp[i][sz - 1] <= t){
            ans = max(ans, cnt - 2);
        }
        for (int j = 1; j < sz; j ++){
            if((i >> j & 1) == 0){
                for (int k = 0; k < sz; k ++){
                    if(i >> k & 1){
                        dp[i | 1 << j][j] = min(dp[i | 1 << j][j], dp[i][k] + dist[k][j]);
                    }
                }
            }
        }
    }
    cout << ans << "\n";
}
```

### 12.图论常见建图技巧整理

1.超级源点：建一个点能够到达其他所有的点，在求最短路、差分约数等题目常见。

2.利用二分法：二分的思路可以将图中的边的权重变为0或者1，之后就可以利用双端队列bfs，一般适用于求最小代价问题或者经过边的数目最少的问题。

3.拓扑序经常可以用来判断有向图中是否存在环，且拓扑序若按照层次再按照结点编号输出的话用到的是优先队列优化拓扑序。

4.建立一个虚拟结点，典型题目https://www.acwing.com/problem/content/458/，假设图中分成两块，其这两块中每两对结点都要连一条有向边，但是枚举$n^2$会超时，因此我们可以在这两块之间加入一个虚拟结点，然后两块分别向这个结点连边即可。

5.建立多个虚拟结点，典型题目https://codeforces.com/contest/1860/problem/E，本题有个限制就是相同的左右字母可以直接跳转，那么我们可以建立 $26 \times 26$ 个虚拟结点，如果 $i$ 两边字母分别为 $x, y$，那么我们向 $26 \times x + y$ 连一条长度为1的边，再从它向 $i$ 连一条长度为0的边即可。

### 13.分层图最短路（最短路数组记录状态）

**题目链接：** https://www.luogu.com.cn/problem/P4568

**题目描述：** 给定一个$n$个结点$m$个边的无向图，每个边有一定的权值，现在要求从$s$走到$t$，其中可以使得最多$k$条边变为免费的，求最少花费。$(k<=10)$

**思路分析：** 分层图最短路模板题，基本思路是可以把一个点拆成$k$个点，分别表示到达这个点用了$i$次免费券的最短路，但是实际并不需要真的拆点，用$dist[u][num]$表示到达$u$这个点用了$num$次免费券时的最小路径即可。

```c++
void solve(){
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<PII>>g(n + 1);
    vector<vector<int>>dist(n + 1, vector<int>(k + 1, 1e9));
    vector<vector<int>>st(n + 1, vector<int>(k + 1));
    int s, t;
    cin >> s >> t;
    for (int i = 1; i <= m; i ++){
        int u, v, w;
        cin >> u >> v >> w;
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
    auto dijkstra = [&](){
        priority_queue<State>q;
        q.push({s, 0, 0});
        dist[s][0] = 0;
        while(q.size()){
            auto t = q.top();q.pop();
            int u = t.u, num = t.num;
            if(st[u][num])continue;
            st[u][num] = true;
            for (int i = 0; i < g[u].size(); i ++){
                int v = g[u][i].x, w = g[u][i].y;
                if(num < k && dist[v][num + 1] > dist[u][num]){
                    dist[v][num + 1] = dist[u][num];
                    q.push({v, dist[v][num + 1], num + 1});
                } 
                if(dist[v][num] > dist[u][num] + w){
                    dist[v][num] = dist[u][num] + w;
                    q.push({v, dist[v][num], num});
                }
            }
        }
    };
    dijkstra();
    int ans = 1e9;
    for (int i = 0; i <= k; i ++){
        ans = min(ans, dist[t][i]);
    }
    cout << ans << "\n";
}
```

### 14.树的遍历中栈的应用

**题目链接：** https://codeforces.com/contest/1681/problem/F

**题目描述：** 给一个$n$个结点的树，每个边上有一个权值，定义$f(u, v)$为从$u$到$v$上的边出现且仅出现一次的值的个数，求$\sum f(u, v)$，其中$1 <= u, v <= n$。

**思路分析：** 首先我们思考本题的含义，本题可以转化为将某种颜色的边全部删除去后，求剩下的连通块的大小，并且根据一条边两边的连通块的乘积算出这个边的贡献值。对于所有的颜色都执行这个操作后我们就可以得到答案。我们考虑优化这个过程，首先我们用$sz$数组在$dfs$过程中记录以$u$为根的子树的大小，用$dp[u]$记录在$u$为根的子树中，能够到达多少个点，且路径上不经过和$u$颜色相同的点，其中结点的颜色被定义为这个点到它的父节点的这条边的权值。这个可以写成$sz[u]-\sum sz[v]$，其中$v$是$u$的子树中所有的离$u$最近的且和它同色的结点编号。这个过程我们可以利用一个栈来维护，因为$dfs$的过程中实质上就是按栈的性质出入的，所以一定也是最近的。我们维护好$dp$数组后，只需要再来一遍$dfs$，这一遍同样用栈来维护，找到两个最近的相同颜色的结点，将他们两个$dp$数组相乘即可。注意我们还需要每个颜色额外维护一个虚拟节点(可以理解为根节点)，来算第一次出现的颜色到根节点这路径上的贡献。

```c++
void solve(){
    int n; cin >> n;
    vector<vector<PII>>g(n + 1);
    for (int i = 0; i < n - 1; i ++){
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    vector<stack<int>>stk(n * 2 + 1);
    vector<int>dp(n * 2 + 1), sz(n * 2 + 1);
    for (int i = 1; i <= n; i ++){
        stk[i].push(n + i);
        dp[n + i] = n;
    }
    auto dfs1 = [&](auto &self, int u, int fa)->void{
        sz[u] = 1;
        for (int i = 0; i < g[u].size(); i ++){
            int v = g[u][i].x, w = g[u][i].y;
            if(v == fa)continue;
            stk[w].push(v);
            self(self, v, u);
            sz[u] += sz[v];
            stk[w].pop();
            dp[stk[w].top()] -= sz[v];
        }
        dp[u] += sz[u];
    };
    dfs1(dfs1, 1, -1);
    LL ans = 0;
    auto dfs2 = [&](auto &self, int u, int fa)->void{
        for (int i = 0; i < g[u].size(); i ++){
            int v = g[u][i].x, w = g[u][i].y;
            if(v == fa)continue;
            stk[w].push(v);
            self(self, v, u);
            stk[w].pop();
            ans += 1ll * dp[v] * dp[stk[w].top()];
        }
    };
    dfs2(dfs2, 1, -1);
    cout << ans << "\n";
}
```

### 15.bitset求距离为2的点对个数

**题目链接：** http://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1007

**核心题意：** 给定一个图，求出距离为2的点对的个数，不同的中间点对应不同的点对。

![1690118487266](C:/images/1690118487266-1690118490041.png)

**思路分析：** 利用$bitset$压位存储所有点的邻接点，然后暴力枚举两个点求他们邻接点的与运算，求出的即为他们的中间点个数，复杂度为$O(n^3/64)$。

### 16.倍增优化树上问题

**题目链接：** https://ac.nowcoder.com/acm/contest/57357/I

**题目描述：** 给一棵树，每个结点有一个颜色集合，其中颜色总种类不超过60个，询问从$u$到$v$的最小代价，移动一步需要一元，换一次颜色需要一元，必须保证要移动到的结点颜色集合包含当前颜色才能移动，否则必须更换颜色。对于给出的$q$组询问，求出最小代价。

**思路分析：** 对于给定的一棵树，从一个结点$u$移动到另一个结点$v$一定是从$u\rightarrow lca(u, v)$然后从$lca(u, v)\rightarrow v$，其中后面是可以反过来的不影响答案即从$v\rightarrow lca(u, v)$，接下来我们需要预处理出来两端分别的改变颜色的次数，以及到达$lca$后是否需要改变颜色。预处两端最少换颜色的次数，我们可以用倍增思路$cost[u][i]$表示从$u$开始改变颜色$1<<v$次最远可以到达的结点，那么我们需要知道$cost[u][0]$的值，也就是从$u$这个结点任意选一个颜色且只改变一次颜色能够到达的结点，那么我们就需要知道$u$开始不改变颜色能够到哪，所以我们定义$col[u][i]$表示从$u$开始跳到$1<<i$这个父节点这条路径上面共有的颜色集合，因此通过这些预处理我们可以得到我们想要的值。在在线询问过程中，我们每次处理结点到达某一个点后，不需要改变颜色就可以到达$lca$，然后剩下的直接倍增处理到父节点，看看两边有没有交集，决定$lca$是否需要变颜色。

```c++
void solve(){
    int n, q;
    cin >> n >> q;
    vector<int>c(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> c[i];
    }
    vector<vector<int>>g(n + 1);
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    vector<int>dep(n + 1);
    vector<vector<int>> fa(n + 1, vector<int>(21));
    vector<vector<int>> col(n + 1, vector<int>(21));
    vector<vector<int>> cost(n + 1, vector<int>(21));
    auto dfs = [&](auto &self, int u, int father) -> void{
        dep[u] = dep[father] + 1;
        fa[u][0] = father;
        col[u][0] = c[u] & c[father];
        for (int i = 1; i < 20; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            col[u][i] = col[u][i - 1] & col[fa[u][i - 1]][i - 1];
        }
        int t = u;
        int color = c[u];
        for (int i = 19; i >= 0; i--) {
            if(color & col[t][i]) {
                color &= col[t][i];
                t = fa[t][i];
            }
        }
        if(t == u)t = 0;
        cost[u][0] = t;
        for (int i = 1; i <= 19; i++) {
            cost[u][i] = cost[cost[u][i - 1]][i - 1];
        }
        for (auto v : g[u]) {
            if(v == father)continue;
            self(self, v, u);
        }
    };
    dfs(dfs, 1, 0);
    auto lca = [&](int x, int y) {
        if(dep[x] < dep[y])swap(x, y);
        for (int i = 19; i >= 0; i--) {
            if(dep[fa[x][i]] >= dep[y]) {
                x = fa[x][i];
            }
        }
        if(x == y)return y;
        for (int i = 19; i >= 0; i--) {
            if(fa[x][i] != fa[y][i]) {
                x = fa[x][i];
                y = fa[y][i];
            }
        }
        return fa[x][0];
    };
    while(q --) {
        int u, v;
        cin >> u >> v;
        int p = lca(u, v);
        int t1 = u, t2 = v;
        int ans = 0;
        for (int i = 19; i >= 0; i--) {
            if(dep[cost[t1][i]] > dep[p]) {
                ans += 1 << i;
                t1 = cost[t1][i];
            }
            if(dep[cost[t2][i]] > dep[p]) {
                ans += 1 << i;
                t2 = cost[t2][i];
            }
        }
        int c1 = c[t1], c2 = c[t2];
        for (int i = 19; i >= 0; i--) {
            if(dep[fa[t1][i]] >= dep[p]) {
                c1 &= col[t1][i];
                t1 = fa[t1][i]; 
            }
        }
        for (int i = 19; i >= 0; i--) {
            if(dep[fa[t2][i]] >= dep[p]) {
                c2 &= col[t2][i];
                t2 = fa[t2][i];     
            }
        }
        if(c1 == 0 || c2 == 0) {
            cout << -1 << "\n";
        } else {
            cout << ans + dep[u] + dep[v] - 2 * dep[p] + ((c1 & c2) ? 0 : 1) << "\n";
        }
    }
}
```

### 17.floyd应用

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7322

**题目描述：** 给一个图，求其中最小环以及最小环的个数，其中$n<=500$.

**思路分析：** 利用$floyd$算法，我们可以得出最小环的大小，但是个数的话统计会有重复，我们利用$floyd$具体定义，即$f[i][j][k]$表示$i$到$j$这条边经过的点都是小于等于编号$k$的，所以我们每个环只统计其中编号最大的一个点即可。

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    vector<vector<LL>>f(n + 1, vector<LL>(n + 1, inf));
    vector<vector<LL>>a(n + 1, vector<LL>(n + 1, inf));
    vector<vector<Z>>g(n + 1, vector<Z>(n + 1));
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        f[u][v] = w;
        a[u][v] = w;
        g[u][v] = 1;
    }
    LL minv = inf;
    Z cnt = 0;
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if(f[i][j] > f[i][k] + f[k][j]) {
                    f[i][j] = f[i][k] + f[k][j];
                    g[i][j] = g[i][k] * g[k][j];
                } else if(f[i][j] == f[i][k] + f[k][j]) {
                    g[i][j] += g[i][k] * g[k][j];
                }
            }
        }
        for (int i = 1; i <= k - 1; i++) {
            if(a[k][i] + f[i][k] < minv) {
                minv = a[k][i] + f[i][k];
                cnt = g[i][k];
            } else if(a[k][i] + f[i][k] == minv) {
                minv = a[k][i] + f[i][k];
                cnt += g[i][k];
            }
        }
    }
    if(minv == inf) {
        cout << -1 << " " << -1 << "\n";
        return;
    }
    cout << minv << " " << cnt << "\n";
}
```

### 18.树上博弈+ST表

**题目链接：** http://acm.hdu.edu.cn/showproblem.php?pid=7354

**题目描述：** 有两个人在一棵树上走，他们分别从两个结点出发，他们只能走到两个人均没有走到的点，求先手是否会胜利。

**思路分析：** 首先我们考虑两个人的共同策略就是要不然走这个点可以走到的最长路，这等价于将这个最长路之外的部分直接让给对方，必须要保证最长路严格大于对方走过的最长路，否则就会沿着$x \rightarrow y$这个链走，因此我们还需要维护这个链上每个点向下能够到达的最大路径，假设这个链的长度为$cnt$.那么设$a=cnt.b=1$，接着我们考虑到达中间一个点对于$a$来说就是$a-i$，对于$b$来说时间就是$i-b$，因此从$i$这个点到最深的点对于$a$来说就是$dist-i+a$，对于$b$来说就是$dist+i-b$，因此我们需要分别维护这个链上面的区间的$dist+i$和$dist-i$的最大值，只有当前两者所在点能够到达的最大深度大于这个最大值才可以保证胜利，因此我们可以利用$ST$表来维护。

```c++
void solve(){
    int n;
    cin >> n;
    int x, y;
    cin >> x >> y;
    vector<vector<int>>g(n + 1);
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    vector<int>p(n + 1);
    auto dfs1 = [&](auto &self, int u, int fa) -> void{
        p[u] = fa;
        // cerr << u << " " << fa << "\n";
        for (auto v: g[u]) {
            if(v == fa)continue;
            self(self, v, u);
        }
    };
    dfs1(dfs1, x, 0);
    vector<int>v;
    vector<int>st(n + 1);
    v.push_back(0);
    while(y) {
        v.push_back(y);
        st[y] = true;
        y = p[y];
    }
    vector<int> len(n + 1);
    int m = v.size() - 1;
    // cerr << m << "\n";
    auto dfs2 = [&](auto &self, int u, int fa) -> int{
        int res = 0;
        for (auto v : g[u]) {
            if(v == fa || st[v])continue;
            res = max(res, self(self, v, u) + 1);
        }
        return res;
    };
    vector<vector<int>>st1(m + 1, vector<int>(20));
    vector<vector<int>>st2(m + 1, vector<int>(20));
    for (int i = 1; i <= m; i++) {
        len[i] = dfs2(dfs2, v[i], 0);
        st1[i][0] = len[i] + i, st2[i][0] = len[i] - i;
    }
    for (int i = 1; i <= 19; i++) {
        for (int j = 1; j + (1 << i) - 1 <= m; j++) {
            st1[j][i] = max(st1[j][i - 1], st1[j + (1 << (i - 1))][i - 1]);
            st2[j][i] = max(st2[j][i - 1], st2[j + (1 << (i - 1))][i - 1]);
        }
    }
    auto query1 = [&](int l, int r) {
        int k = log2(r - l + 1);
        return max(st1[l][k], st1[r - (1 << k) + 1][k]);
    };
    auto query2 = [&](int l, int r) {
        int k = log2(r - l + 1);
        return max(st2[l][k], st2[r - (1 << k) + 1][k]);
    };
    int ca = m, cb = 1, cur = 1;
    while(true) {
        // cerr << ca << " " << cb << " " << cur << "\n";
        if(cur) {
            if(ca - 1 == cb){
                cout << (len[ca] > len[cb] ? 1 : 0) << "\n";
                break;
            } else {
                if(len[ca] > query1(cb, ca - 1) - cb) {
                    cout << 1 << "\n";
                    break;
                } else {
                    ca --;
                }
            }
        } else {
            if(cb + 1 == ca){
                cout << (len[cb] > len[ca] ? 0 : 1) << "\n";
                break;
            } else {
                if(len[cb] > query2(cb + 1, ca) + ca) {
                    cout << 0 << "\n";
                    break;
                } else {
                    cb ++;
                }
            }
        }
        cur ^= 1;
    }
}
```

### 19.记忆化搜索应用于数字变化

**题目链接：** https://ac.nowcoder.com/acm/contest/64384/F

**题目描述：** 给两个整数 $a$ 和 $b$，每次可以执行下面的任意一个操作 $a \rightarrow a + 1$，$a \rightarrow 2 \times a$，$a \rightarrow a ^2$ ，求将 $a$ 变成 $b$ 的最少操作次数。

**思路分析：** 我们考虑搜索，但是因为有加1操作，所以会导致时间超时，我们考虑如何进行搜索，首先，如果没有平方操作的话，那么一定是由 $b$ 变成 $a$ 的逆过程就是这个过程的最优解，考虑逆过程，那么加1操作就可以在用来判断是否是奇数的时候才会有，所以没有单独加1的操作，然后再加上平方操作，那么就可以得到答案。

```c++
void solve(){
    LL a, b;
    cin >> a >> b;
    map<LL, LL> mp;
    auto dfs = [&](auto &self, LL x) -> LL{
        if(x == a)return mp[a] = 0;
        if(mp[x])return mp[x];
        LL ans = x - a;
        if(x / 2 >= a) {
            ans = min(ans, self(self, x / 2) + 1 + x % 2);
        }
        int y = sqrt(x);
        if(y >= a) {
            ans = min(ans, self(self, y) + 1 + x - 1ll * y * y);
        }
        return mp[x] = ans;
    };
    dfs(dfs, b);
    cout << mp[b] << "\n";
}
```

### 20.数论+记忆化搜索

**题目链接：** https://codeforces.com/gym/103470/problem/J

**题目描述：** 给两个正整数 $a$ 和 $b$，可以执行下面三种操作之一：

1.将 $a$ 和 $b$ 都加一。   2.将 $a$ 和 $b$ 都减一。  3.将 $a$ 和 $b$ 同时除以他们的公共质因子。

求最少多少步可以让两者之一变为1。

**思路分析：** 首先我们发现第一步和第二步两步的差值是不会改变的，第三步操作实际上也是让他们的差值除以这个公约数，所以我们可以利用记忆化搜索实现。

```c++
void solve(){
    int a, b;
    cin >> a >> b;
    if(a > b) {
        swap(a, b);
    }
    int d = b - a;
    vector<int> factor;
    for (int i = 2; i <= d / i; i++) {
        if(d % i == 0) {
            while(d % i == 0) d /= i;
            factor.emplace_back(i);
        } 
    }
    if(d > 1) factor.emplace_back(d);
    map<LL, int> mp;
    auto get = [&](int a, int b) {
        return a * 1000000000ll + b;
    };
    auto dfs = [&](auto &self, int a, int b) -> int{
        if(a == 1) {
            return 0;
        }
        if(mp.count(get(a, b))) {
            return mp[get(a, b)];
        }
        if(b == 1) {
            return a - 1;
        }
        int step = a - 1;
        for (int i = 0; i < factor.size(); i++) {
            int x = factor[i];
            if(b % x == 0) {
                step = min(step, self(self, a / x, b / x) + 1 + a % x);
                step = min(step, self(self, a / x + 1, b / x) + 1 + x - a % x);
            }
        }
        return mp[get(a, b)] = step;
    };
    cout << dfs(dfs, a, b - a) << "\n"; 
}
```

### 21.dfs序+树状数组

**题目链接：** https://ac.nowcoder.com/acm/contest/64819/D

**题目描述：** 给一棵树，再给 $m$ 个点对 $p, q$，还有 $q$ 个询问，每次询问给出 $a, b$ ，求对于每个询问，有多少个点对满足，$p$ 是 $a$ 的父节点，$q$ 是 $b$ 的子节点。

**思路分析：** 我们考虑 $dfs$ ，首先我们遍历到一个点 $p$ 的时候，对于它对应的 $q$ 的值要加一，然后遍历到一个询问点 $a$ 的时候，我们要计算 $b$ 的子节点目前的权值和，因此我们考虑 $dfs$ 序，考虑将树形结构转化为线性结构，所以我们利用 $dfs$ 序再加上树状数组即可解决这个问题。

```c++
void solve(){
    int n, m, q;
    cin >> n >> m >> q;
    vector<vector<int>> g(n + 1);
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    vector<int> dfn(n + 1);
    vector<int> sz(n + 1, 1);
    int tim = 0;
    auto dfs = [&](auto &self, int u, int fa) -> void {
        dfn[u] = ++ tim;
        for (auto v : g[u]) {
            if(v == fa)continue;
            self(self, v, u);
            sz[u] += sz[v];
        }
    };
    dfs(dfs, 1, -1);
    vector<vector<int>> v(n + 1);
    while(m --) {
        int x, y;
        cin >> x >> y;
        v[x].emplace_back(y);
    }
    vector<vector<PII>> query(n + 1);
    for (int i = 1; i <= q; i++) {
        int x, y;
        cin >> x >> y;
        query[x].emplace_back(y, i);
    }
    BIT bit(n + 1);
    vector<int> ans(n + 1);
    auto dfs2 = [&](auto &self, int u, int fa) -> void {
        for (auto t : v[u]) {
            bit.modify(dfn[t], 1);
        }
        for (auto t : query[u]) {
            ans[t.y] = bit.query(dfn[t.x], dfn[t.x] + sz[t.x] - 1);
        }
        for (auto t : g[u]) {
            if(t == fa)continue;
            self(self, t, u);
        }
        for (auto t : v[u]) {
            bit.modify(dfn[t], -1);
        }
    };
    dfs2(dfs2, 1, -1);
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
}
```





## 六、贪心构造问题

### 1.树上构造问题

**题目链接：** https://codeforces.com/contest/1670/problem/E

**题目描述：** 给一个结点个数为 $n=2^p$ 的树，现在需要对点和边进行填数，要求数字范围是 $[1, 2 \times n-1]$ 这个范围内每个数字出现一次，求所有的染色方案中，从根节点到其他所有点和所有边路径上面异或值最小的一组构造。

输出根节点，所有点的数字，所有边上面的数字。

**思路分析：** 我们首先可以确定这个最小的最大值一定不会小于 $n$ ,因为小于 $n$，那么根节点一定小于 $n$, 那么就有下面某个点一定有大于n的一个数字，那么大于n的这个数字的第一位一定是1，那么就可以确定这个位置上的数字一定大于 $n$, 所以我们构造希望最大值恰好是 $n$。

如何构造呢？我们可以让除了跟结点外所有其他结点到根节点的异或值为 $0$。这个是可以实现的，我们将根节点上面数字设置为 $n$, 对于这条路径上面所有点的异或值只有两种取值可能：$0$ 和 $n$ ,为了实现这个目标，我们可以维护一个时间戳，对于一个点 $u$ 和他的儿子结点 $v$，以及他们之间的路径 $<u, v>$，如果 $s[u] = 0$，那么这条边就需要取 $tim$，$v$ 就要取 $n + tim$，那么这样的话一定能保证所有值 $<= n$。这个构造的思想就是把点和边看做一个整体，而要求取不同的数字就是维护时间戳的运用。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int>PII; 
const int N = 3e5 + 10;
int n, m;
int val[N];
vector<int>e[N];
vector<PII>ed;
map<PII, int>mp;
int tim;
void dfs(int u, int fa, int sum)
{
	++tim;
    if (sum == n) 
	{
        for (auto v : e[u]) 
		{
            if (v == fa)continue;
            mp[{min(u, v), max(u, v)}] = n + tim;
            val[v] = tim;
            dfs(v, u, 0);
        }
    }
    if (sum == 0) 
	{
        for (auto v : e[u]) 
		{
            if (v == fa)continue;
            mp[{min(u, v), max(u, v)}] = tim;
            val[v] = n + tim;
            dfs(v, u, n);
        }
    }
}
void solve()
{
	cin >> n;
	n = 1 << n;
	ed.clear(), mp.clear();tim = 0;
	for (int i = 1; i <= n; i ++)e[i].clear();
	for(int i = 1; i <= n - 1; i ++)
	{
		int u, v;cin >> u >> v;
		e[u].push_back(v), e[v].push_back(u);
		ed.push_back({min(u, v), max(u, v)});
	} 
	val[1] = n;
	dfs(1, -1, n);
	cout << 1 << "\n";
    for (int i = 1; i <= n; i++)cout << val[i] << " \n"[i == n];
    for (auto x : ed)cout << mp[x] << " ";
    cout << "\n";
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    int T = 1;
    cin >> T;
    while(T --)solve();
    
    return 0;
}
```

### 2.贪心公式推导

**题目链接：** https://codeforces.com/contest/1408/problem/D

**题目描述：** 在一个二维平面内有 $n$ 个点， 每个点有一个整数坐标，还有 $m$ 个灯，每个灯也有一个坐标，如果点在灯的左下方，即 $a[i] <= c[i], b[i] <= d[i]$ 同时成立那么这个点将会被发现，现在有两种操作：把所有点向上移动一格；把所有点向下移动一格。求最少多少次操作可以让没有点被发现。其中 $0 <= n, m <= 2000$。

**思路分析：** 首先这题的模型是:https://zhuanlan.zhihu.com/p/268630329

根据这个模型，我们可以把题目转化成每个点为了符合目标对于每一个灯它需要移动的次数后用上面的模型即可。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII; 
const int N = 2e5 + 10;
int n, m;
void solve()
{
	cin >> n >> m;
	vector<int>a(n), b(n);
	for (int i = 0; i < n; i ++){
		cin >> a[i] >> b[i];
	}
	vector<PII>u, v;
	for (int i = 0; i < m; i ++){
		int c, d; cin >> c >> d;
		for (int j = 0; j < n; j ++){
			if(a[j] <= c && b[j] <= d)u.push_back({c + 1 - a[j], d + 1 - b[j]});
		}
	}	
	if(!u.size()){
		cout << "0\n";
		return;
	}
	sort(u.begin(), u.end());
	v.push_back(u.back());
	for (int i = u.size() - 2; i >= 0; i --){
		if(u[i][1] > v.back()[1])v.push_back(u[i]);
	}
	int minv = min(v[0][0], v.back()[1]);
	for (int i = 0; i < v.size() - 1; i ++)minv = min(minv, v[i][1] + v[i + 1][0]);
	cout << minv << "\n";
} 
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    int T = 1;
    //cin >> T;
    while(T --)solve();
    
    return 0;
}
```

### 3.公式推导+二分

**题目链接：** https://codeforces.com/contest/1808/problem/D

**题目描述：** 给一个长度为 $n$ 的数组，需要让所有长度为 $k$ 的子数组形成回文串，即对称位置数字相同，其中保证 $k$ 是一个奇数，问最少修改多少个字符可以使得子数组为回文串，注意这里的修改只对此时的数组而言，不具有永久性。

**思路分析：** 首先由于$k$是一个奇数，那么我们会发现只有奇偶性相同的位置才会形成对称，我们现在想要计算的是有多少个对称位置不相同的数字，这个显然不好计算，我们考虑逆问题，有多少个对称位置相同的数字，将总共的修改个数减去1即可，总共的修改次数也就是假设所有对称位置数字都不相同，首先，一共有 $n-k+1$ 个长度为$k$ 的子串，其次每个长度为 $k$ 的子串有 $\frac k2$ 个对称位置，所以一共就会有 $(n - k + 1) * \frac k2$ 。下面我们只需要计算有多少对称位置且在长度为 $k$ 的子数组中即可，我们可以把数字相同且奇偶性相同的位置存起来，然后推导一下公式，对于位置 $i$, 其前面可以和他形成对称位置的左右边界分别可以计算，首先 $j$ 和 $i$ 之间的距离不能超过 $k$，也就是左边界要大于等于$i - k + 1$，其次 $i$ 和 $j$ 形成的子数组必须在长度为k的子数组中，这也就意味着他们的左右两边必须至少有 $(k - (i - j + 1)) / 2$ 个数，所以就有 $[k - (i - j + 1)] / 2 <= j - 1$ 和 $[k - (i - j + 1)] / 2 <= n - i$, 所以综上可以得出对于 $i$，其对应的左右边界位置为
$$
max(i - k + 1, k - i + 1) <= j <= min(2n - i - k + 1, i - 2)
$$
这个可以用二分解决。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef array<int, 2>PII;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
const int mod = 1e9 + 7, MOD = 998224353;
const int inf = 0x3f3f3f3f;
const LL INF = 1e18;
const int N = 2e5 + 10;
int n, m;
vector<int>pos[N][2];
void solve(){
	cin >> n >> m;
    LL ans = 1LL * (n - m + 1) * (m / 2);
    for(int i = 1; i <= n; i ++){
        int x;cin >> x;
        pos[x][i & 1].push_back(i);
    }
    auto get = [&](const vector<int> &v, int l, int r){
        return upper_bound(v.begin(), v.end(), r) - lower_bound(v.begin(), v.end(), l);
    };
    for(int i = 0; i < 2; i++){
        for(int j = 1; j <= 200000; j++){
            for(auto x : pos[j][i]){
                int l = max((m - 1) + 2 - x, x - m + 1), r = min(x - 2, 2 * n - (m - 1) - x);
                if (l <= r) ans -= get(pos[j][i], l, r);
            }
        }
    }
    cout << ans << "\n";
}
int main(){
	ios :: sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	int T = 1;
	//cin >> T;
	while(T --) solve();
	
	return 0;
}
```

### 4.摩尔投票问题

**题目链接：** https://codeforces.com/contest/1822/problem/E

**题目描述：** 给一个长度为$n$的字符串，我们现在要交换其中的字符，使得对于任意的$i$，$s[i] != s[n - i + 1]$恒成立，求最小的交换次数。

**思路分析：** 首先长度为奇数或者最大的字符数量大于总长度的一半都是不合法的。对于合法状态，答案是$max((num + 1)/ 2, max({cnt[i]}))$，其中$cnt[i]$是第$i$ 个字母出现的配对次数，$num$是配对的个数。即如果冲突最多的字母的对数少于总对数的一半的时候，就是总对数的一半，因为可以两两交换得到；如果冲突最多的字母多于总对数的一半的时候，就是冲突最多的字母的对数。

```c++
void solve(){
   cin >> n;
   string s; cin >> s;
   vector<int>a(26), cnt(26);
   for (int i = 0; i < n; i ++){
        a[s[i] - 'a'] ++;
   }
   for (int i = 0; i < 26; i ++){
        if(n % 2 || a[i] > n / 2){
            cout << -1 << "\n";
            return;
        }
   }
   int l = 0, r = n - 1;
   while(l < r){
        if(s[l] == s[r]){
            cnt[s[l] - 'a'] ++;
        }
        l ++, r --;
   }
   sort(cnt.begin(), cnt.end(), [&](int x, int y){
        return x > y;
   });
   int ans = 0, num = 0;;
   for (int i = 0; i < 26; i ++){
        num += cnt[i];
        ans = max(ans, cnt[i]);
   }
   ans = max((num + 1) / 2, ans);
   cout << ans << "\n";
}
```

## 七、字符串问题

### 1.失配树

**题目链接：** https://www.luogu.com.cn/problem/P5829

**题目描述：** $Border(s)$定义为对于$s∈(1, |s|)$，满足$pre[i] = suf[i]$的所有字符串的$pre$的集合，即这个字符串所有前缀和后缀相等的集合，例如$ababa$，其$Border(s)={a,aba}$。对于任意两个给定的前缀字符串，求他们的最长的公共前缀的长度。

**思路分析：** $kmp$中的$border$表示这个字符串的所有前后缀相等的集合，$fail$表示这个前缀中最大的$border$，根据$next$数组的定义我们知道，这里的$fail$实际是和$next$数组相同的，那么我们得到这个后，可以根据$next(fail)$数组建立一个失配树，通过$lca$即可求出最长公共前缀的长度。

**知识点总结：** 若$u$是$v$的$boder$，$v$是$x$的$border$，那么$u$是$x$的$border$。如果一个字符串$p$是$s$的周期，那么一定有$s-p$是$s$的$border$,求一个字符串的$border$的总长度的公式：
$$
cnt[i] = cnt[ne[i]] + 1 \\ans[i] = ans[ne[i]] + (i - ne[i]) * cnt[i]
$$

```c++
void solve(){
    string s; cin >> s;
    s = " " + s;
    int n = s.size() - 1;
    vector<vector<int>>fa(n + 1, vector<int>(22));
    vector<int>d(n + 1);
    d[1] = 1;
    for (int i = 2, j = 0; i <= n; i ++){
        while(j && s[i] != s[j + 1])j = fa[j][0];
        if(s[i] == s[j + 1])j ++;
        fa[i][0] = j;
        d[i] = d[j] + 1;
        for (int k = 1; k <= 21; k ++){
            fa[i][k] = fa[fa[i][k - 1]][k - 1];
        }
    }
    int m;cin >> m;
    auto lca = [&](int x, int y){
        if(d[x] < d[y])swap(x, y);
        for (int i = 21; i >= 0; i --){
            if(d[fa[x][i]] >= d[y]){
                x = fa[x][i];
            }
        }
        for (int i = 21; i >= 0; i --){
            if(fa[x][i] != fa[y][i]){
                x = fa[x][i];
                y = fa[y][i];
            }
        }
        return fa[x][0];
    };
    while(m --){
        int p, q;
        cin >> p >> q;
        cout << lca(p, q) << "\n"; 
    }
}
```

### 2.manacher算法应用

**题目链接：** https://ac.nowcoder.com/acm/contest/57356/G

**题目描述：** 给定一个字符，判断它是否是旋转对称的字符串的组合。

**思路分析：** 根据回文串修改规则，利用$manacher$算法计算，找到一个串即可截掉这个部分的前缀继续寻找下一部分即可。

```c++
void solve(){
    string t;
    cin >> t;
    string s = "$#";
    for (int i = 0; i < t.size(); i++) {
        s += t[i];
        s += '#';
    }
    int n = s.size();
    vector<int>d(n);
    auto check = [&](char a, char b){
        if(a == 's' && b == 's')return 1;
        if(a == 'o' && b == 'o')return 1;
        if(a == 'x' && b == 'x')return 1;
        if(a == 'z' && b == 'z')return 1;
        if(a == 'b' && b == 'q')return 1;
        if(a == 'd' && b == 'p')return 1;
        if(a == 'n' && b == 'u')return 1;
        if(a == 'p' && b == 'd')return 1;
        if(a == 'q' && b == 'b')return 1;
        if(a == 'u' && b == 'n')return 1;
        if(a == '#' && b == '#')return 1;
        return 0;
    };
    int start = 1;
    auto manacher = [&](){
        for (int i = 1, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d[l + r - i], r - i + 1);
            while(i - k >= 0 && i + k < n && check(s[i + k], s[i - k])) {
                k ++;
            }
            d[i] = k - 1;
            if(i + d[i] > r) {
                l = i - d[i];
                r = i + d[i];
            }
            if(d[i] >= 0 && i - d[i] <= start) {
                start = i + d[i] + 1;
                i += d[i];
                s[i] = '$';
            }
        }
    };
    manacher();
    cout << (start == n ? "Yes" : "No") << "\n";
}
```

## 八.常用技巧（对拍）

### 1.读取数据文件并且与数据输出对比

**注意事项：** 所有的数据文件必须和自己写的 $cpp$ 文件放在同一级目录下面。

**步骤：** 1.在存放数据文件和自己写的源文件的目录 （一般为D:\XCPC_lqb_tts_csp_Astar）的文件栏输入 $cmd$ 命令，然后输入 g++ std.cpp -o std -g 编译源程序。

2.读取数据文件 std <1.in> 2.txt，即让std.cpp运行1.in文件并把结果放入2.txt中。

3.对比标准答案和自己输出的文件，fc 2.txt 1.out

### 2.将自己的程序和暴力程序对比

```c++
g++ mkd.cpp -o mkd -g
g++ std.cpp -o std -g
g++ my.cpp -o my -g
:loop
    mkd >1.txt	
    std <1.txt >2.txt
    my <1.txt >3.txt
    fc 2.txt 3.txt
if not errorlevel 1 goto loop
pause
goto loop
```

```c++
mt19937_64 rndGen(chrono::steady_clock::now().time_since_epoch().count());
#define rint(l,r) uniform_int_distribution<int>(l,r)(rndGen)
#define rll(l,r) uniform_int_distribution<ll>(l,r)(rndGen)
#define rreal(l,r) uniform_real_distribution<double>(l,r)(rndGen)
//rint(1, 100)生成1~100的随机数
```

## 九.常用模板

### 1.__int128的读写

```c++
inline void scan(__int128 &x) {
    x = 0;
    int f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch=='-')f = -1;
        ch=getchar();
    }
    while(isdigit(ch)) {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
inline void print(__int128 x) {
    if(x < 0) {
        putchar('-');
        x = -x;
    }
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
```

### 2.excrt

```c++
typedef long long LL;
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
//m表示模数，a表示取模得到的数字，使用excrt要求a必须非负
bool merge(LL &m1, LL &a1, LL m2, LL a2) {
    LL u, v;
    LL g = exgcd(m1, m2, u, v);
    LL m = m1 / g * m2;
    if ((a2 - a1) % g != 0) {
        return false;
    }
    LL d = (a2 - a1) / g;
    LL x = (__int128(u) * m1 * d + a1) % m;
    if (x < 0) {
        x += m;
    }
    m1 = m, a1 = x;
    return true;
}
```

### 3.树状数组

```c++
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;

    Fenwick(int n) : n(n), tr(n + 1, 0){}

    int lowbit(int x){
        return x & -x;
    }

    void modify(int x, T c){
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }

    void modify(int l, int r, T c){
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }

    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }

    T query(int l, int r){
        return query(r) - query(l - 1);
    }

};
using BIT = Fenwick<int>;
```

### 4.类欧定理

```c++
//求解(a * i + b) / m下取整的和,其中i范围是[0, n - 1]
LL floor_sum(LL n, LL m, LL a, LL b) {
    if(n == 0) return 0;
    LL ans = 0;
    ans += (a / m) * n * (n - 1) / 2, a %= m;
    ans += (b / m) * n, b %= m;
    LL y_max = a * n + b;
    ans += floor_sum(y_max / m, a, m, y_max % m);
    return ans;
}
```

### 5.manacher

```c++
 string s = "#";
    for (int i = 0; i < t.size(); i++) {
        s += t[i];
        s += '#';
    }
    int n = s.size();
    vector<int>d(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d[l + r - i], r - i + 1);
        while(i - k >= 0 && i + k < n && s[i - k] == s[i + k]) {
            k ++;
        }
        d[i] = k - 1;
        if(i + d[i] > r) {
            l = i - d[i];
            r = i + d[i];
        }
    }
```

### 6.大质数分解

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

int t;
LL max_factor, n;
LL gcd(LL a, LL b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

LL quick_pow(LL x, LL p, LL mod) {  // 快速幂
    LL ans = 1;
    while (p) {
      if (p & 1) ans = (__int128)ans * x % mod;
      x = (__int128)x * x % mod;
      p >>= 1;
    }
    return ans;
}

bool Miller_Rabin(LL p) {  // 判断素数
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (p == 3) return 1;
    LL d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
    for (LL k = 0; k < 10; ++k) {
      LL a = rand() % (p - 2) + 2;
      LL x = quick_pow(a, d, p);
      if (x == 1 || x == p - 1) continue;
      for (int i = 0; i < r - 1; ++i) {
        x = (__int128)x * x % p;
        if (x == p - 1) break;
      }
      if (x != p - 1) return 0;
    }
    return 1;
}

LL Pollard_Rho(LL x) {
    LL s = 0, t = 0;
    LL c = (LL)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    LL val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
      for (step = 1; step <= goal; ++step) {
        t = ((__int128)t * t + c) % x;
        val = (__int128)val * abs(t - s) % x;
        if ((step % 127) == 0) {
          LL d = gcd(val, x);
          if (d > 1) return d;
        }
      }
      LL d = gcd(val, x);
      if (d > 1) return d;
    }
}

void fac(LL x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {              // 如果x为质数
      max_factor = max(max_factor, x);  // 更新答案
      return;
    }
    LL p = x;
    while (p >= x) p = Pollard_Rho(x);  // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
    scanf("%d", &t);
    while (t--) {
      srand((unsigned)time(NULL));
      max_factor = 0;
      scanf("%lld", &n);
      fac(n);
      if (max_factor == n)  // 最大的质因数即自己
        printf("Prime\n");
      else
        printf("%lld\n", max_factor);
    }
    return 0;
}

```

### 7.主席树

```c++
#include <bits/stdc++.h>
const int N = 1e5 + 10;
struct PST{
    int idx = 0;
    struct Node {
        int l, r;
        int cnt;
    }tr[N * 25];
    int build(int l, int r) {
        int p = ++ idx;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        tr[p].l = build(l, mid);
        tr[p].r = build(mid + 1, r);
        return p;
    }
    int insert(int q, int l, int r, int x) {
        int p = ++ idx;
        tr[p] = tr[q];
        tr[p].cnt++;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        if(mid >= x)tr[p].l = insert(tr[q].l, l, mid, x);
        else tr[p].r = insert(tr[q].r, mid + 1, r, x);
        return p;
    }
    int query(int p, int q, int l, int r, int k) {
        if(l == r) {
            return r;
        }
        int cnt = tr[tr[p].l].cnt - tr[tr[q].l].cnt;
        int mid = l + r >> 1;
        if(cnt >= k)return query(tr[p].l, tr[q].l, l, mid, k);
        else return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
    }
}pst;
```

### 8.rand加强

```c++
mt19937_64 rndGen(chrono::steady_clock::now().time_since_epoch().count());
#define rint(l,r) uniform_int_distribution<int>(l,r)(rndGen)
#define rll(l,r) uniform_int_distribution<ll>(l,r)(rndGen)
#define rreal(l,r) uniform_real_distribution<double>(l,r)(rndGen)
```

### 9.线段树

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int a[N];
struct SegmentTree {
    struct Node{
        int l, r;
        int s;
        int tag1, tag2;
    }tr[N * 4];
    void settag(int u, int t1, int t2){
        tr[u].s = tr[u].s * t2 + (tr[u].r - tr[u].l + 1) * t1;
        tr[u].tag1 = tr[u].tag1 * t2 + t1;
        tr[u].tag2 *= t2;
    }
    void pushup(int u){
        tr[u].s = tr[u << 1].s + tr[u << 1 | 1].s;
    }
    void pushdown(int u){
        settag(u << 1, tr[u].tag1, tr[u].tag2);
        settag(u << 1 | 1, tr[u].tag1, tr[u].tag2);
        tr[u].tag1 = 0;
        tr[u].tag2 = 1;
    }
    void build(int u, int l, int r){
        tr[u] = {l, r, 0, 0, 1};
        if(l == r){
            tr[u].s = a[l];
            tr[u].tag1 = 0;
            tr[u].tag2 = 1;
            return;
        } 
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int l, int r, int t1, int t2) {
        if(tr[u].l >= l && tr[u].r <= r){
            settag(u, t1, t2);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= l)modify(u << 1, l, r, t1, t2);
        if(mid < r)modify(u << 1 | 1, l, r, t1, t2);
        pushup(u);
    }
    int query(int u, int l, int r){
        if(tr[u].l >= l && tr[u].r <= r){
            return tr[u].s;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= r)return query(u << 1, l, r);
        else if(mid < l)return query(u << 1 | 1, l, r);
        else {
            return query(u << 1, l, r) + query(u << 1 | 1, l, r);
        }
    }
}tree;
```

### 10.字符串哈希

```c++
struct Hash {
    static constexpr LL P = (LL)1E16 + 99;
    static constexpr int B = 233;
    int n;
    vector<LL> h, p;
    Hash(const string &s) : n(s.size()), h(n + 1), p(n + 1) {
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * B % P;
            h[i + 1] = (h[i] * B + s[i]) % P;
        }
    }

    LL get(int l, int r) {
        return (h[r] + (__int128)h[l] * (P - p[r - l])) % P;
    }
};
```

### 11.Z取模

```c++
template<class T>
constexpr T power(T a, LL b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt(LL x = 0) : x(norm(x % P)) {}
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr MInt operator-() const {
        return MInt(P - x);
    }
    constexpr MInt inv() const {
        // assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(const MInt &rhs) {
        x = LL(x) * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(const MInt &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(const MInt &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(const MInt &rhs) {
        return *this *= rhs.inv();
    }
    constexpr friend MInt operator*(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    constexpr friend MInt operator+(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    constexpr friend MInt operator-(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    constexpr friend MInt operator/(const MInt &lhs, const MInt &rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    constexpr friend std::istream &operator>>(std::istream &is, MInt &a) {
        LL v;
        is >> v;
        a = MInt(v);
        return is;
    }
    constexpr friend std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    constexpr friend bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    constexpr friend bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
const int P = 998244353;
using Z = MInt<P>;

```

### 12.tarjan

```c++
vector<int>dfn(n + 1), low(n + 1);
vector<int>st(n + 1), sz(n + 1), id(n + 1), dout(n + 1);
stack<int>stk;
int time = 0, scc_cnt = 0;
auto tarjan = [&](auto self, int u) ->void {
    dfn[u] = low[u] = ++ time;
    stk.push(u);
    st[u] = true;
    for (int i = 0; i < g[u].size(); i++) {
        int v = g[u][i]; 
        if(!dfn[v]) {
            self(self, v);
            low[u] = min(low[u], low[v]);
        } else if(st[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if(dfn[u] == low[u]){
        ++ scc_cnt;
        int y;
        do {
            y = stk.top();stk.pop();
            st[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt] ++ ;
        } while (y != u);
    }
};
```

