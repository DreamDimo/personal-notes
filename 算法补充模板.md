## 算法补充模板

### 1.EXCRT

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
//m表示模数，a表示取模得到的数字，使用excrt要求a必须非负
bool merge(LL &m1, LL &a1, LL m2, LL a2) {
    LL u, v;
    LL g = exgcd(m1, m2, u, v);
    LL m = m1 / g * m2;
    if ((a2 - a1) % g != 0) {
        return false;
    }
    LL d = (a2 - a1) / g;
    LL x = (__int128(u) * m1 * d + a1) % m;
    if (x < 0) {
        x += m;
    }
    m1 = m, a1 = x;
    return true;
}
```

### 2.类欧定理

```c++
//求解(a * i + b) / m下取整的和,其中i范围是[0, n - 1]
LL floor_sum(LL n, LL m, LL a, LL b) {
    if(n == 0) return 0;
    LL ans = 0;
    ans += (a / m) * n * (n - 1) / 2, a %= m;
    ans += (b / m) * n, b %= m;
    LL y_max = a * n + b;
    ans += floor_sum(y_max / m, a, m, y_max % m);
    return ans;
}
```

### 3.manacher

```c++
#include<bits./stdc++.h>
using namespace std;

int main() {
    string t;
    cin >> t;
    //---------------------------------------------------------------
    string s = "#";
    for (int i = 0; i < t.size(); i++) {
        s += t[i];
        s += '#';
    }
    int n = s.size();
    vector<int>d(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d[l + r - i], r - i + 1);
        while(i - k >= 0 && i + k < n && s[i - k] == s[i + k]) {
            k ++;
        }
        d[i] = k - 1;
        if(i + d[i] > r) {
            l = i - d[i];
            r = i + d[i];
        }
    }
    //----------------------------------------------------------------
}
```

### 4.大质数分解

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

int t;
LL max_factor, n;
LL gcd(LL a, LL b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

LL quick_pow(LL x, LL p, LL mod) {  // 快速幂
    LL ans = 1;
    while (p) {
      if (p & 1) ans = (__int128)ans * x % mod;
      x = (__int128)x * x % mod;
      p >>= 1;
    }
    return ans;
}

bool Miller_Rabin(LL p) {  // 判断素数
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (p == 3) return 1;
    LL d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
    for (LL k = 0; k < 10; ++k) {
      LL a = rand() % (p - 2) + 2;
      LL x = quick_pow(a, d, p);
      if (x == 1 || x == p - 1) continue;
      for (int i = 0; i < r - 1; ++i) {
        x = (__int128)x * x % p;
        if (x == p - 1) break;
      }
      if (x != p - 1) return 0;
    }
    return 1;
}

LL Pollard_Rho(LL x) {
    LL s = 0, t = 0;
    LL c = (LL)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    LL val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
      for (step = 1; step <= goal; ++step) {
        t = ((__int128)t * t + c) % x;
        val = (__int128)val * abs(t - s) % x;
        if ((step % 127) == 0) {
          LL d = gcd(val, x);
          if (d > 1) return d;
        }
      }
      LL d = gcd(val, x);
      if (d > 1) return d;
    }
}

void fac(LL x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {              // 如果x为质数
      max_factor = max(max_factor, x);  // 更新答案
      return;
    }
    LL p = x;
    while (p >= x) p = Pollard_Rho(x);  // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
    scanf("%d", &t);
    while (t--) {
      srand((unsigned)time(NULL));
      max_factor = 0;
      scanf("%lld", &n);
      fac(n);
      if (max_factor == n)  // 最大的质因数即自己
        printf("Prime\n");
      else
        printf("%lld\n", max_factor);
    }
    return 0;
}

```

### 5.主席树

```c++
#include <bits/stdc++.h>
const int N = 1e5 + 10;
struct PST{
    int idx = 0;
    struct Node {
        int l, r;
        int cnt;
    }tr[N * 25];
    int build(int l, int r) {
        int p = ++ idx;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        tr[p].l = build(l, mid);
        tr[p].r = build(mid + 1, r);
        return p;
    }
    int insert(int q, int l, int r, int x) {
        int p = ++ idx;
        tr[p] = tr[q];
        tr[p].cnt++;
        if(l == r) {
            return p;
        }
        int mid = l + r >> 1;
        if(mid >= x)tr[p].l = insert(tr[q].l, l, mid, x);
        else tr[p].r = insert(tr[q].r, mid + 1, r, x);
        return p;
    }
    int query(int p, int q, int l, int r, int k) {
        if(l == r) {
            return r;
        }
        int cnt = tr[tr[p].l].cnt - tr[tr[q].l].cnt;
        int mid = l + r >> 1;
        if(cnt >= k)return query(tr[p].l, tr[q].l, l, mid, k);
        else return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
    }
}pst;
```

### 6.线段树

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int a[N];
struct SegmentTree {
    struct Node{
        int l, r;
        int s;
        int tag1, tag2;
    }tr[N * 4];
    void settag(int u, int t1, int t2){
        tr[u].s = tr[u].s * t2 + (tr[u].r - tr[u].l + 1) * t1;
        tr[u].tag1 = tr[u].tag1 * t2 + t1;
        tr[u].tag2 *= t2;
    }
    void pushup(int u){
        tr[u].s = tr[u << 1].s + tr[u << 1 | 1].s;
    }
    void pushdown(int u){
        settag(u << 1, tr[u].tag1, tr[u].tag2);
        settag(u << 1 | 1, tr[u].tag1, tr[u].tag2);
        tr[u].tag1 = 0;
        tr[u].tag2 = 1;
    }
    void build(int u, int l, int r){
        tr[u] = {l, r, 0, 0, 1};
        if(l == r){
            tr[u].s = a[l];
            tr[u].tag1 = 0;
            tr[u].tag2 = 1;
            return;
        } 
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void modify(int u, int l, int r, int t1, int t2) {
        if(tr[u].l >= l && tr[u].r <= r){
            settag(u, t1, t2);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= l)modify(u << 1, l, r, t1, t2);
        if(mid < r)modify(u << 1 | 1, l, r, t1, t2);
        pushup(u);
    }
    int query(int u, int l, int r){
        if(tr[u].l >= l && tr[u].r <= r){
            return tr[u].s;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= r)return query(u << 1, l, r);
        else if(mid < l)return query(u << 1 | 1, l, r);
        else {
            return query(u << 1, l, r) + query(u << 1 | 1, l, r);
        }
    }
}tree;
```

### 7.字符串哈希

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

struct Hash {
    static constexpr LL P = (LL)1E16 + 99;
    static constexpr int B = 233;
    int n;
    vector<LL> h, p;
    Hash(const string &s) : n(s.size()), h(n + 1), p(n + 1) {
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * B % P;
            h[i + 1] = (h[i] * B + s[i]) % P;
        }
    }

    LL get(int l, int r) {
        return (h[r] + (__int128)h[l] * (P - p[r - l])) % P;
    }
};
```

### 8.字符串最小表示法

```c++
int get_min(char s[])
{//1—base,返回开头的下标
    int i = 0, j = 1;
    while (i < n && j < n)
    {
        int k = 0;
        while (k < n && s[i + k] == s[j + k]) k ++ ;
        if (k == n) break;
        if (s[i + k] > s[j + k]) i += k + 1;
        else j += k + 1;
        if (i == j) j ++ ;
    }
    int k = min(i, j);
    s[k + n] = 0;
    return k;
}
```

### 9.堆和集合的重载

```c++
//set维护
struct Node{
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz > t.sz;
        return id < t.id;
    }
};
set<Node>s[N];
//大根堆
struct Node{//按照sz递减，id递增
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz > t.sz;
        return id < t.id;
    }
};
priority_queue<Node>q;
//小根堆
struct Node{//按照sz递增，id递减
    int sz, id;
    bool operator<(const Node &t) const{
        if (sz != t.sz) return sz < t.sz;
        return id > t.id;
    }
};
priority_queue<Node>q;
```

### 10.单链表式并查集

```c++
for (int i = 1; i <= m; i ++){
        int l, r;
        cin >> l >> r;
        for (int i = dsu.find(l); i <= r; i = dsu.find(i)){
            id[i] = ++tot;
            dsu.p[i] = i + 1;
        }
}
```

### 11.莫队

```c++
void solve(){
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1), b(n + 1);
    BIT bit(n);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = bit.query(a[i] - 1);
        bit.modify(a[i], 1);
    }
    vector<array<int, 3>>query;
    int K = sqrt(n);
    for (int i = 1; i <= m; i++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r, i});
    }
    sort(query.begin(), query.end(), [&](array<int, 3>A, array<int, 3>B){
        int c = A[0] / K;
        if(c != B[0] / K) return c < B[0] / K;
        return(c % 2 ? A[1] > B[1] : A[1] < B[1]);
    });
    vector<int>ans(m + 1), sum(n + 1), cnt(n + 1);
    int l = 1, r = 0, res = 0;
    auto addR = [&](int x){
        res += cnt[a[x]] * b[x] - sum[a[x]];
        cnt[a[x]]++, sum[a[x]] += b[x];
    };
    auto addL = [&](int x){
        res += sum[a[x]] - cnt[a[x]] * b[x];
        cnt[a[x]]++, sum[a[x]] += b[x];
    };
    auto delR = [&](int x){
        cnt[a[x]]--, sum[a[x]] -= b[x];
        res -= cnt[a[x]] * b[x] - sum[a[x]];
    };
    auto delL = [&](int x){
        cnt[a[x]]--, sum[a[x]] -= b[x];
        res -= sum[a[x]] - cnt[a[x]] * b[x];
    };
    for (auto evt : query){
        while(r < evt[1])r++, addR(r);
        while(l > evt[0])l--, addL(l);
        while(r > evt[1])delR(r), r--;
        while(l < evt[0])delL(l), l++;
        ans[evt[2]] = res;
    }
    for (int i = 1; i <= m; i++) {
        cout << ans[i] << "\n";
    }
}
```

### 12.LCA

```c++
void dfs(int u, int fat){
	for (int i = 0; i < g[u].size(); i ++){
		int v = g[u][i];
		if(v == fat)continue;
		d[v] = d[u] + 1;
		fa[v][0] = u;
		for (int i = 1; i <= 19; i ++){
			fa[v][i] = fa[fa[v][i - 1]][i - 1];
		}
		dfs(v, u);
	}
}
int lca(int x, int y){
	if(d[x] < d[y])swap(x, y);
	for (int i = 18; i >= 0; i --){
		if(d[fa[x][i]] >= d[y]){
			x = fa[x][i];
		}
	}
	if(x == y)return x;
	for (int i = 19; i >= 0; i --){
		if(fa[x][i] != fa[y][i]){
			x = fa[x][i];
			y = fa[y][i];
		}
	}
	return fa[x][0];
}
```

### 13.强联通分量

```c++
#include <bits/stdc++.h>
using namespace std;
void solve(){
   int n, m;
   cin >> n >> m;
   vector<vector<int>>g(n + 1);
   vector<int>dfn(n + 1), low(n + 1);
   vector<int>st(n + 1), sz(n + 1), id(n + 1), dout(n + 1);
   stack<int>stk;
   int time = 0, scc_cnt = 0;
   for (int i = 1; i <= m; i ++){
      int a, b;
      cin >> a >> b;
      g[a].push_back(b);
   }
   auto tarjan = [&](auto self, int u) ->void{
      dfn[u] = low[u] = ++ time;
      stk.push(u);
      st[u] = true;
      for (int i = 0; i < g[u].size(); i ++){
         int v = g[u][i];
         if(!dfn[v]){
            self(self, v);
            low[u] = min(low[u], low[v]);
         } else if(st[v]){
            low[u] = min(low[u], dfn[v]);
         }
      }

      if(dfn[u] == low[u]){
         ++ scc_cnt;
        int y;
        do {
            y = stk.top();stk.pop();
            st[y] = false;
            id[y] = scc_cnt;
            sz[scc_cnt] ++ ;
        } while (y != u);
      }
   };
   for (int i = 1; i <= n; i ++){
      if(!dfn[i])tarjan(tarjan, i);
   }
   //上面主要是缩点，即把有向图中的环缩成一个点，之后就可以利用拓扑关系
   //scc_cnt表示连通分量的个数，id表示这个点所在的连通分量编号
   for (int i = 1; i <= n; i ++){
      for (int j = 0; j < g[i].size(); j ++){
         int v = g[i][j];
         int a = id[i], b = id[v];
         if(a != b){
            dout[a] ++;
         }
      }
   }
   int zeros = 0, sum = 0;
   for (int i = 1; i <= scc_cnt; i ++){
      if(dout[i] == 0){
         zeros ++;
         sum += sz[i];
      }
   }
   cout << (zeros > 1 ? 0 : sum) << "\n";
}
int main(){
   ios::sync_with_stdio(false);
   cin.tie(0); cout.tie(0);
   
   int T = 1;
   while(T --)solve();
   return 0;
}
```

### 14.边的双联通分量

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5010, M = 20010;
int e[M], ne[M], h[N], idx;
int n, m, timestamp;
int dfn[N], low[N], d[N];
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void tarjan(int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[++ top] = u;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if(dfn[u] < low[j])is_bridge[i] = is_bridge[i ^ 1] = true;
        }
        else if(i != (from ^ 1))low[u] = min(low[u], low[j]);
    }
    if(dfn[u] == low[u])
    {
        int y;
        dcc_cnt++;
        do
        {
            y = stk[top --];
            id[y] = dcc_cnt;
        }while(y != u);
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    tarjan(1, -1);
    for (int i = 0; i < idx; i ++ )
        if (is_bridge[i])
            d[id[e[i]]] ++ ;
    int cnt = 0;
    for (int i = 1; i <= dcc_cnt; i ++ )
        if (d[i] == 1)
            cnt ++ ;
    printf("%d\n", (cnt + 1) / 2);

    return 0;
}
```

### 15.匈牙利算法

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 510, M = 1e5 + 10;
int match[N];
int e[M], ne[M], h[N], idx;
bool st[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
bool dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(st[j])continue;
        st[j] = true;
        if(match[j] == 0 || dfs(match[j]))
		{
			match[j] = u;
			return true;
		}
    }
    return false;
}
int main()
{
    memset(h, -1, sizeof h);
    int n1, n2, m;scanf("%d%d%d", &n1, &n2, &m);
    while (m -- )
    {
        int u, v;scanf("%d%d", &u, &v);
        add(u, v);
    }
    int cnt = 0;
    for (int i = 1; i <= n1; i ++)
    {
        memset(st, 0, sizeof st);
        if(dfs(i))cnt ++;
    }
    printf("%d\n", cnt);
    return 0;
}
```

### 16.染色法判断二分图

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = 2 * N;
int e[M], ne[M], h[N], idx;
int c[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
bool dfs(int u, int color)
{
    c[u] = color;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(c[j] != -1)
        {
            if(!dfs(j, color ^ 1)) return false;
        }
        else if(c[j] == color)return false;
    }
    return true;
}
int main()
{
    memset(h, -1, sizeof h);
    memset(c, -1, sizeof h);
    int n, m;scanf("%d%d", &n, &m);
    while(m -- )
    {
        int a, b;scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    bool flag = true;
    for (int i = 1; i <= n; i ++)
    {
        if(c[i] == -1)
        {
            if(!dfs(i, 0)) flag = false;
        }
    }
    printf("%s\n", (flag ? "Yes" : "No"));
    return 0;
}
```

